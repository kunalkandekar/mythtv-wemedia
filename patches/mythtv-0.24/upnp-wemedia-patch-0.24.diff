Index: libs/libmythupnp/upnpcdsobjects.cpp
===================================================================
--- libs/libmythupnp/upnpcdsobjects.cpp	(revision 4503)
+++ libs/libmythupnp/upnpcdsobjects.cpp	(working copy)
@@ -847,3 +847,127 @@
 
     return( pObject );
 }
+
+/////////////////////////////////////////////////////////////////////////////
+
+CDSObject *CDSObject::CreateEpgItem( QString sId, QString sTitle, QString sParentId, CDSObject *pObject )
+{
+    if (pObject == NULL)
+    {
+        pObject = new CDSObject( sId, sTitle, sParentId );
+        pObject->m_sClass = "object.item.epgItem";
+    }
+
+    CreateItem( sId, sTitle, sParentId, pObject );
+
+    pObject->AddProperty( new Property( "channelGroupName"   , "upnp" ));
+    pObject->AddProperty( new Property( "epgProviderName"    , "upnp" ));
+    pObject->AddProperty( new Property( "serviceProvider"    , "upnp" ));
+    pObject->AddProperty( new Property( "channelName"        , "upnp" ));
+    pObject->AddProperty( new Property( "channelNr"          , "upnp" ));
+    pObject->AddProperty( new Property( "programTitle"       , "upnp" ));
+    pObject->AddProperty( new Property( "seriesTitle"        , "upnp" ));
+    pObject->AddProperty( new Property( "programID"          , "upnp" ));
+    pObject->AddProperty( new Property( "seriesID"           , "upnp" ));
+    pObject->AddProperty( new Property( "channelID"          , "upnp" ));
+    pObject->AddProperty( new Property( "episodeCount"       , "upnp" ));
+    pObject->AddProperty( new Property( "episodeNumber"      , "upnp" ));
+    pObject->AddProperty( new Property( "programCode"        , "upnp" ));
+    pObject->AddProperty( new Property( "rating"             , "upnp" ));
+    pObject->AddProperty( new Property( "episodeType"        , "upnp" ));
+    pObject->AddProperty( new Property( "genre"              , "upnp" ));
+    pObject->AddProperty( new Property( "artist"             , "upnp" ));
+    pObject->AddProperty( new Property( "actor"              , "upnp" ));
+    pObject->AddProperty( new Property( "author"             , "upnp" ));
+    pObject->AddProperty( new Property( "producer"           , "upnp" ));
+    pObject->AddProperty( new Property( "director"           , "upnp" ));
+    pObject->AddProperty( new Property( "publisher"          , "dc"   ));
+    pObject->AddProperty( new Property( "contributer"        , "dc"   ));
+    pObject->AddProperty( new Property( "callSign"           , "upnp" ));
+    pObject->AddProperty( new Property( "networkAffiliation" , "upnp" ));
+    pObject->AddProperty( new Property( "price"              , "upnp" ));
+    pObject->AddProperty( new Property( "payPerView"         , "upnp" ));
+    pObject->AddProperty( new Property( "epgProviderName"    , "upnp" ));
+    pObject->AddProperty( new Property( "description"        , "dc"   ));
+    pObject->AddProperty( new Property( "longDescription"    , "upnp" ));
+    pObject->AddProperty( new Property( "icon"               , "upnp" ));
+    pObject->AddProperty( new Property( "region"             , "upnp" ));
+    pObject->AddProperty( new Property( "rights"             , "upnp" ));
+    pObject->AddProperty( new Property( "language"           , "dc"   ));
+    pObject->AddProperty( new Property( "relation"           , "dc" ));
+    pObject->AddProperty( new Property( "scheduledStartTime" , "upnp" ));
+    pObject->AddProperty( new Property( "scheduledEndTime"   , "upnp" ));
+    pObject->AddProperty( new Property( "recordable"         , "upnp" ));
+    pObject->AddProperty( new Property( "foreignMetadata"    , "upnp" ));
+
+    return( pObject );
+} // CreateEpgItem
+
+/////////////////////////////////////////////////////////////////////////////
+
+CDSObject *CDSObject::CreateAudioProgram( QString sId, QString sTitle, QString sParentId, CDSObject *pObject )
+{
+    if (pObject == NULL)
+    {
+        pObject = new CDSObject( sId, sTitle, sParentId );
+        pObject->m_sClass = "object.item.epgItem.audioProgram";
+    }
+
+    CreateEpgItem( sId, sTitle, sParentId, pObject );
+
+    pObject->AddProperty( new Property( "radioCallSign"    , "upnp" ));
+    pObject->AddProperty( new Property( "radioStationID"   , "upnp" ));
+    pObject->AddProperty( new Property( "radioBand"        , "upnp" ));
+
+
+    return( pObject );
+} // CreateAudioProgram
+
+/////////////////////////////////////////////////////////////////////////////
+
+CDSObject *CDSObject::CreateVideoProgram( QString sId, QString sTitle, QString sParentId, CDSObject *pObject )
+{
+    if (pObject == NULL)
+    {
+        pObject = new CDSObject( sId, sTitle, sParentId );
+        pObject->m_sClass = "object.item.epgItem.videoProgram";
+    }
+
+    CreateEpgItem( sId, sTitle, sParentId, pObject );
+
+    return( pObject );
+} // CreateVideoProgram
+
+/////////////////////////////////////////////////////////////////////////////
+
+CDSObject *CDSObject::CreateEpgContainer( QString sId, QString sTitle, QString sParentId, CDSObject *pObject )
+{
+    if (pObject == NULL)
+    {
+        pObject = new CDSObject( sId, sTitle, sParentId );
+        pObject->m_sClass = "object.container.epgContainer";
+    }
+
+    CreateContainer( sId, sTitle, sParentId, pObject );
+
+    pObject->AddProperty( new Property( "channelGroupName"   , "upnp" ));
+    pObject->AddProperty( new Property( "epgProviderName"    , "upnp" ));
+    pObject->AddProperty( new Property( "serviceProvider"    , "upnp" ));
+    pObject->AddProperty( new Property( "channelName"        , "upnp" ));
+    pObject->AddProperty( new Property( "channelNr"          , "upnp" ));
+    pObject->AddProperty( new Property( "channelID"          , "upnp" ));
+    pObject->AddProperty( new Property( "radioCallSign"      , "upnp" ));
+    pObject->AddProperty( new Property( "radioStationID"     , "upnp" ));
+    pObject->AddProperty( new Property( "radioBand"          , "upnp" ));
+    pObject->AddProperty( new Property( "callSign"           , "upnp" ));
+    pObject->AddProperty( new Property( "networkAffiliation" , "upnp" ));
+    pObject->AddProperty( new Property( "price"              , "upnp" ));
+    pObject->AddProperty( new Property( "payPerView"         , "upnp" ));
+    pObject->AddProperty( new Property( "icon"               , "upnp" ));
+    pObject->AddProperty( new Property( "region"             , "upnp" ));
+    pObject->AddProperty( new Property( "language"           , "dc"   ));
+    pObject->AddProperty( new Property( "relation"           , "dc" ));
+    pObject->AddProperty( new Property( "dateTimeRange"      , "upnp" ));
+
+    return( pObject );
+} // CreateEpgContainer
Index: libs/libmythupnp/httprequest.cpp
===================================================================
--- libs/libmythupnp/httprequest.cpp	(revision 4503)
+++ libs/libmythupnp/httprequest.cpp	(working copy)
@@ -97,6 +97,7 @@
     // Similarly, this could be audio/flac or application/flac:
     { "flac", "audio/x-flac"               },
     { "m4a" , "audio/x-m4a"                },
+    { "flv" , "video/x-flv"                },
 };
 
 static const int g_nMIMELength = sizeof( g_MIMETypes) / sizeof( MIMETypes );
@@ -210,7 +211,7 @@
                         "Content-Length: %3\r\n" )
                         .arg( GetKeepAlive() ? "Keep-Alive" : "Close" )
                         .arg( sContentType )
-                        .arg( nSize );
+                        .arg( nSize < 0 ? "*" : QString::number(nSize) );
 
     // ----------------------------------------------------------------------
     // Temp Hack to process DLNA header
@@ -252,6 +253,13 @@
 
             return( SendResponseFile( m_sFileName ));
 
+        case ResponseTypeStream:
+            VERBOSE(VB_UPNP,QString("HTTPRequest::SendResponse( Stream ) :%1 -> %2:")
+                            .arg(GetResponseStatus())
+                            .arg(GetPeerAddress()));
+
+            return( SendResponseFile( m_sFileName ));
+
         case ResponseTypeXML:
         case ResponseTypeHTML:
         case ResponseTypeOther:
@@ -325,6 +333,8 @@
 
     VERBOSE(VB_UPNP, QString("SendResponseFile ( %1 )").arg(sFileName));
 
+    ResponseType eOriginalResponseType = m_eResponseType;
+
     m_eResponseType     = ResponseTypeOther;
     m_sResponseTypeText = "text/plain";
 
@@ -358,7 +368,8 @@
         // Get File size
         // ------------------------------------------------------------------
 
-        llSize = llEnd = tmpFile.size( );
+        llSize = llEnd = (eOriginalResponseType == ResponseTypeStream ?
+                            INT_MAX : tmpFile.size( ));    //max size if the file is still recording
 
         m_nResponseStatus = 200;
 
@@ -386,7 +397,8 @@
                     m_mapRespHeaders[ "Content-Range" ] = QString("bytes %1-%2/%3")
                                                               .arg( llStart )
                                                               .arg( llEnd   )
-                                                              .arg( llSize  );
+                                                              .arg( eOriginalResponseType == ResponseTypeStream ?
+                                                                      "*" : QString::number(llSize)  );
                     llSize = (llEnd - llStart) + 1;
                 }
             }
@@ -421,13 +433,13 @@
         m_nResponseStatus = 404;
     }
 
-    // -=>TODO: Should set "Content-Length: *" if file is still recording
+    // -=> FIXED: Pass size < 0 if file is still recording to set "Content-Length: *"
 
     // ----------------------------------------------------------------------
     // Write out Header.
     // ----------------------------------------------------------------------
 
-    QString    rHeader = BuildHeader( llSize );
+    QString    rHeader = BuildHeader( eOriginalResponseType == ResponseTypeStream? -llSize : llSize );
     QByteArray sHeader = rHeader.toUtf8();
     nBytes = WriteBlockDirect( sHeader.constData(), sHeader.length() );
 
@@ -435,10 +447,10 @@
     // Write out File.
     // ----------------------------------------------------------------------
 
-    //VERBOSE(VB_UPNP, QString("SendResponseFile : size = %1, start = %2, end = %3").arg(llSize).arg(llStart).arg(llEnd));
+    //VERBOSE(VB_UPNP, QString("SendResponseFile : size = %1, start = %2, end = %3 hdr = %4").arg(llSize).arg(llStart).arg(llEnd).arg(rHeader));
     if (( m_eType != RequestTypeHead ) && (llSize != 0))
     {
-        long long sent = SendFile( tmpFile, llStart, llSize );
+        long long sent = SendFile( tmpFile, llStart, (eOriginalResponseType == ResponseTypeStream? -llSize : llSize) );
 
         if (sent == -1)
         {
@@ -474,6 +486,10 @@
 qint64 HTTPRequest::SendFile( QFile &file, qint64 llStart, qint64 llBytes )
 {
     qint64 sent = 0;
+    bool blive = (llBytes < 0);
+    llBytes = (llBytes < 0 ? -llBytes : llBytes);
+    int nMaxTries = 5;    //max number of tries before giving up on file growing
+    int nTries    = nMaxTries;
 
 #if CONFIG_DARWIN || CONFIG_CYGWIN || defined(__FreeBSD__) || defined(USING_MINGW)
 
@@ -491,8 +507,20 @@
     qint64 llBytesRead      = 0;
     qint64 llBytesWritten   = 0;
 
-    while ((sent < llBytes) && !file.atEnd())
+    while (sent < llBytes) 
     {
+        if (file.atEnd())
+        {
+            if (blive && (--nTries > 0))
+            {
+                sleep(3);
+                continue; 
+            }
+
+            VERBOSE(VB_UPNP, QString("SendResponseFile : Stopping after %1 tries.")   
+                .arg(nMaxTries));
+            break;  //file ended and not growing any more, stop
+        }
         llBytesToRead  = std::min( (qint64)SENDFILE_BUFFER_SIZE, llBytesRemaining );
         
         if (( llBytesRead = file.read( aBuffer, llBytesToRead )) != -1 )
@@ -504,6 +532,7 @@
 
             sent             += llBytesRead;
             llBytesRemaining -= llBytesRead;
+            nTries = nMaxTries;
         }
     }
 
@@ -534,7 +563,23 @@
             llBytes  -= ( offset - llStart ); 
             VERBOSE(VB_UPNP, QString("SendResponseFile : --- " 
             "size = %1, offset = %2, sent = %3") 
-            .arg(llBytes).arg(offset).arg(sent)); 
+            .arg(llBytes).arg(offset).arg(sent));
+            if (blive && (sent == 0))
+            {
+                if (--nTries > 0)
+                {
+	               sleep(3);  //it's a live file, so wait a few secs and let it grow
+	               continue;
+                } 
+                else
+                {
+                    VERBOSE(VB_UPNP, QString("SendResponseFile : Stopping after %1 tries.")   
+                        .arg(nMaxTries));
+                    break;    //live file not growing anymore, break
+                }
+            } 
+            else
+                nTries = nMaxTries;
         } 
         while (( sent >= 0 ) && ( llBytes > 0 )); 
     } 
Index: libs/libmythupnp/upnpsrsobjects.h
===================================================================
--- libs/libmythupnp/upnpsrsobjects.h	(revision 0)
+++ libs/libmythupnp/upnpsrsobjects.h	(revision 0)
@@ -0,0 +1,315 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: upnpsrsobjects.cpp
+// Created     : Dec 10, 2009
+// Modified    : Mar 01, 2010
+//
+// Author      : Kunal Kandekar
+//
+// Purpose     : UPnP Scheduled Recording Service Object Definitions
+//                                                                            
+// Copyright (c) 2010
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef __UPNPSRSSOBJECTS_H_
+#define __UPNPSRSOBJECTS_H_
+
+#include <QDateTime>
+#include <QString>
+#include <QList>
+#include <QMap>
+
+#include "httprequest.h"
+#include "upnpcds.h"
+#include "upnpcdsobjects.h"
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////////////////////////////////////////////////
+class SRSDependentProperty : public Property
+{
+    public:
+        explicit SRSDependentProperty( const QString &sName,
+                              bool           bRequired    = false,
+                              const QString &sValue       = "" )
+            : Property(sName, "", bRequired, sValue)
+        { }
+
+        virtual ~SRSDependentProperty() { }
+
+        void SetValue(const QString &sValue)
+        {
+            this->m_sValue = sValue;
+        }
+
+        QString GetValue() const
+        {
+            return this->m_sValue;
+        }
+};
+
+class SRSPropertyValue;
+class SRSProperty;
+
+typedef QMap<QString,SRSDependentProperty*> SRSDependentPropertyMap;
+typedef QMap<QString,SRSPropertyValue*>     SRSPropertyValueMap;
+typedef QList<SRSPropertyValue*>            SRSPropertyValueList;
+typedef QMap<QString,SRSProperty*>          SRSPropertyMap;
+typedef QList<SRSProperty*>                 SRSPropertyList;
+
+class SRSPropertyValue : public Property
+{
+    public:
+        explicit SRSPropertyValue(const QString &sName               ,
+        		                  const QString &sNameSpace   = ""   ,
+        		                  bool           bRequired    = false,
+        		                  const QString &sValue       = ""    )
+            : Property(sName, sNameSpace, bRequired, sValue)
+        {
+
+        }
+
+        virtual ~SRSPropertyValue()
+        {
+            //iterate and delete
+        	SRSDependentPropertyMap::iterator itrpl = m_dependentProperties.begin();
+            for (; itrpl != m_dependentProperties.end(); ++itrpl)
+            {
+                SRSDependentProperty *pProp = *itrpl;
+                delete pProp;
+            }
+        }
+        SRSDependentPropertyMap m_dependentProperties;
+
+        SRSDependentProperty   *SetDependentProperty   (const QString  &sName,
+                                                        const QString  &sValue,
+                                                        bool  required=false);
+        SRSDependentProperty   *GetDependentProperty   (const QString  &sName);
+        SRSDependentPropertyMap GetDependentProperties ( );
+        SRSDependentProperty   *AddDependentProperty   (SRSDependentProperty* pProp);
+        SRSDependentProperty   *RemoveDependentProperty(const QString  &sName);
+        SRSPropertyValue       *SetValue               (const QString  &sValue);
+        QString                 GetValue               ( );
+        bool                    toXMLSnippet           (QTextStream    &os);
+};
+
+class SRSProperty : private SRSPropertyValue
+{
+    private:
+	    SRSPropertyValueList  m_lValues;
+        QString               m_sFullName;
+
+    public:
+        bool                  m_bMultiValued;
+        explicit SRSProperty( const QString &sName,
+                              const QString &sNameSpace   = "",
+                              bool           bRequired    = false,
+                              bool           bMultiValued = false)
+            : SRSPropertyValue(sName, sNameSpace, bRequired, QString::null),
+              m_bMultiValued(bMultiValued)
+        {
+            if (!sNameSpace.isEmpty())
+                m_sFullName = sNameSpace + ':'+sName;
+            else
+                m_sFullName = sName;
+        }
+
+        virtual ~SRSProperty()
+        {
+            //iterate and delete
+            SRSPropertyValueList::iterator itrpl = m_lValues.begin();
+            for (; itrpl != m_lValues.end(); ++itrpl)
+            {
+                SRSPropertyValue *pProp = *itrpl;
+                delete pProp;
+            }
+        }
+        QString              GetName         ( ) { return m_sName;          }
+        QString              GetNameSpace    ( ) { return m_sNameSpace;     }
+        QString              GetFullName     ( ) { return m_sFullName;      }
+        bool                 IsRequired      ( ) { return m_bRequired;      }
+        bool                 IsMultiValued   ( ) { return m_bMultiValued;   }
+        int                  NumValues       ( ) { return m_lValues.size(); }
+
+        SRSDependentProperty *SetDependentProperty (const QString  &sName,
+													const QString &sValue,
+													bool  required=false)
+		{
+			return SRSPropertyValue::SetDependentProperty(sName, sValue, required);
+		}
+
+        SRSDependentProperty *GetDependentProperty (const QString  &sName)
+		{
+        	return SRSPropertyValue::GetDependentProperty(sName);
+		}
+
+        SRSDependentProperty *AddDependentProperty (SRSDependentProperty* pProp)
+		{
+        	return SRSPropertyValue::AddDependentProperty(pProp);
+		}
+        SRSDependentPropertyMap GetDependentProperties ( )
+        {
+        	return SRSPropertyValue::GetDependentProperties();
+        }
+
+        SRSPropertyValue    *AddValue        (SRSPropertyValue *pProp);
+        SRSPropertyValueList GetValues       ( );
+        SRSPropertyValue	*SetValue        (const QString      &sValue);
+        SRSPropertyValue	*GetFirstValue   ( );
+        QStringList          GetValueStrings ( );
+        virtual bool         toXMLSnippet    (QTextStream  &os);
+};
+
+class SRSObject
+{
+    public:
+        short           m_nUpdateId;
+
+        QString         m_sContextID;
+        QString         m_sDataStructureType;
+
+
+        // Required
+
+        QString         m_sId;
+        QString         m_sTitle;
+        QString         m_sClass;
+
+
+        //
+
+        SRSPropertyMap  m_properties;
+
+        //sort of hack for sorting
+        QStringList     *m_lsSortCriteria;
+        void            SetSortCriteria(QStringList *fields) { m_lsSortCriteria     = fields; }
+
+    public:
+
+        explicit      SRSObject( const QString sId = "-1",
+                                 const QString sTitle = "")
+        {
+            m_sId    = sId;
+            m_sTitle = sTitle;
+        }
+
+        virtual      ~SRSObject()
+        {
+            SRSPropertyMap::iterator it = m_properties.begin();
+            for (; it != m_properties.end(); ++it)
+                delete *it;
+            m_properties.clear();
+        }
+
+        SRSProperty       *AddProperty                ( SRSProperty *pProp   );
+        SRSProperty       *RemoveProperty             ( const QString &sName );
+        SRSProperty       *GetProperty                ( const QString &sName );
+        SRSPropertyValue  *SetPropValue               ( const QString &sName,
+                                                        const QString &sNameSpace,
+                                                        const QString &sValue,
+                                                        bool bRequired    = false,
+                                                		bool bMultiValued = false);
+        SRSPropertyValue  *GetPropFirstValue          ( const QString &sName ) const;
+
+        SRSPropertyValueList GetPropValues            ( const QString &sName );
+
+        QString            toXml                      ( FilterMap &filter ) const;
+        void               toXml                      ( QTextStream &os, FilterMap &filterIn ) const;
+
+        QStringList        GetPropertyList            ( );
+
+    private:
+        static  SRSObject *CreateSRSObject            ( const QString &sId       , const QString &sTitle,
+                                                        const QString &sSRSClass , SRSObject *pObject = NULL );
+        static  SRSObject *CreateRecordSchedule       ( const QString &sId       , const QString &sTitle,
+                                                        const QString &sSRSClass , SRSObject *pObject = NULL );
+        static  SRSObject *CreateRecordScheduleDirect ( const QString &sId       , const QString &sTitle,
+                                                        const QString &sSRSClass , SRSObject *pObject = NULL );
+        static  SRSObject *CreateRecordScheduleQuery  ( const QString &sId       , const QString &sTitle,
+                                                        const QString &sSRSClass , SRSObject *pObject );
+
+    public:
+
+        static  SRSObject *CreateRecordScheduleDirectManual      ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+        static  SRSObject *CreateRecordScheduleDirectCdsEPG      ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+        static  SRSObject *CreateRecordScheduleDirectCdsNonEPG   ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+        static  SRSObject *CreateRecordScheduleDirectProgramCode ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+
+        static  SRSObject *CreateRecordScheduleParts             ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+
+        static  SRSObject *CreateRecordTask                      ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+
+        static  SRSObject *CreateRecordScheduleQueryContentName  ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+        static  SRSObject *CreateRecordScheduleQueryContentID    ( const QString &sId, const QString &sTitle, SRSObject *pObject );
+
+        static  QList<SRSObject*>  fromXML                       ( const QString &sXML );
+        static  void      SyncSRSObjects                         (SRSObject *objFrom , SRSObject *objTo);
+
+        //utility functions
+        static QString   SecsToDuration  ( int           secs     );
+        static int       DurationToSecs  ( const QString &duration);
+        static QString   DateTimeToString( QDateTime     &qdt     );
+        static QDateTime StringToDateTime( const QString &sdt, QStringList *days=NULL);
+
+        static QString   SRS_SCHEDULESTATE_VAL_OPERATIONAL;
+        static QString   SRS_SCHEDULESTATE_VAL_ERROR;
+        static QString   SRS_SCHEDULESTATE_VAL_COMPLETED;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_NONE;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_GENERAL;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_MAX_TASKS;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_EPG_MISSING;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_DISABLED;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_OUTOFMEMORY;
+        static QString   SRS_SCHEDULESTATE_CURRENTERROR_VAL_RESOURCE;
+
+        static QString   SRS_TASKSTATE_VAL_IDLE_READY;
+        static QString   SRS_TASKSTATE_VAL_IDLE_ATRISK;
+        static QString   SRS_TASKSTATE_VAL_ACTIVE_REC_FROMSTART_OK;
+        static QString   SRS_TASKSTATE_VAL_ACTIVE_REC_FROMSTART_ATRISK;
+        static QString   SRS_TASKSTATE_VAL_ACTIVE_NOTRECORDING;
+        static QString   SRS_TASKSTATE_VAL_DONE_FULL;
+        static QString   SRS_TASKSTATE_VAL_DONE_PARTIAL;
+        static QString   SRS_TASKSTATE_VAL_DONE_EMPTY;
+
+        static QString   SRS_TASKSTATE_PHASE_VAL_IDLE;
+        static QString   SRS_TASKSTATE_PHASE_VAL_ACTIVE;
+        static QString   SRS_TASKSTATE_PHASE_VAL_DONE;
+
+        static QString   SRS_TASKSTATE_ERROR_VAL_GENERAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_DISABLED;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SCHED_OVERRIDE;
+        static QString   SRS_TASKSTATE_ERROR_VAL_MEDIA_GENERAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_MEDIA_NO_MEDIA;
+        static QString   SRS_TASKSTATE_ERROR_VAL_MEDIA_WRITE_PROT;
+        static QString   SRS_TASKSTATE_ERROR_VAL_MEDIA_INSUFF_SPACE;
+        static QString   SRS_TASKSTATE_ERROR_VAL_MEDIA_LOW_SPACE;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_GENERAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_INSUFF_MEM;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_INSUFF_CPU;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_MEM;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_CPU;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_NO_SIGNAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_SIGNAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_SYSTEM_NO_EPG;
+        static QString   SRS_TASKSTATE_ERROR_VAL_CONTENT_GENERAL;
+        static QString   SRS_TASKSTATE_ERROR_VAL_CONTENT_CONFLICT_LOSE;
+        static QString   SRS_TASKSTATE_ERROR_VAL_CONTENT_CONFLICT_WIN;
+        static QString   SRS_TASKSTATE_ERROR_VAL_CONTENT_PAYPERVIEW;
+        static QString   SRS_TASKSTATE_ERROR_VAL_CONTENT_RESCHEDULED;
+};
+
+#endif
Index: libs/libmythupnp/libmythupnp.pro
===================================================================
--- libs/libmythupnp/libmythupnp.pro	(revision 4503)
+++ libs/libmythupnp/libmythupnp.pro	(working copy)
@@ -22,12 +22,14 @@
 HEADERS += eventing.h upnpcmgr.h upnptaskevent.h upnptaskcache.h ssdpcache.h
 HEADERS += upnpimpl.h multicast.h broadcast.h configuration.h
 HEADERS += soapclient.h mythxmlclient.h mmembuf.h upnpexp.h
+HEADERS += upnpsrsobjects.h
 
 SOURCES += httprequest.cpp upnp.cpp ssdp.cpp taskqueue.cpp upnputil.cpp
 SOURCES += upnpdevice.cpp upnptasknotify.cpp upnptasksearch.cpp threadpool.cpp
 SOURCES += httpserver.cpp upnpcds.cpp upnpcdsobjects.cpp bufferedsocketdevice.cpp
 SOURCES += eventing.cpp upnpcmgr.cpp upnpmsrr.cpp upnptaskevent.cpp ssdpcache.cpp
 SOURCES += configuration.cpp soapclient.cpp mythxmlclient.cpp mmembuf.cpp
+SOURCES += upnpsrsobjects.cpp
 
 INCLUDEPATH += ../libmythdb ..
 DEPENDPATH  += ../libmythdb ..
Index: libs/libmythupnp/upnpcds.cpp
===================================================================
--- libs/libmythupnp/upnpcds.cpp	(revision 4503)
+++ libs/libmythupnp/upnpcds.cpp	(working copy)
@@ -359,6 +359,19 @@
                      i++)
                 {
                     UPnpCDSExtension *pExtension = m_extensions[i];
+
+                    // EPG compatibility HACK BEGIN
+                    // We don't want the EPG container to be listed under the root object
+                    if ((pExtension->m_sExtensionId == "epg") ||
+						(pExtension->m_sExtensionId == "Epg"))
+                    {
+                    	//skip it
+                    	if (nTotalMatches > 0)
+							nTotalMatches--;
+                    	continue;
+                    }
+                    // EPG compatibility HACK END
+
                     childRequest.m_sObjectId = pExtension->m_sExtensionId;
 
                     pResult = pExtension->Browse( &childRequest );
Index: libs/libmythupnp/upnpsrsobjects.cpp
===================================================================
--- libs/libmythupnp/upnpsrsobjects.cpp	(revision 0)
+++ libs/libmythupnp/upnpsrsobjects.cpp	(revision 0)
@@ -0,0 +1,1146 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: upnpsrsobjects.cpp
+// Created     : Dec 10, 2009
+// Modified    : Mar 01, 2010
+//
+// Author      : Kunal Kandekar
+//
+// Purpose     : UPnP Scheduled Recording Service Object Definitions
+//                                                                            
+// Copyright (c) 2010
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#include <QTextStream>
+#include <QTextCodec>
+#include <QUrl>
+
+#include <QtXml>
+#include <QDomNamedNodeMap>
+#include <QDomNodeList>
+
+#include "upnpsrsobjects.h"
+
+//public static declarations
+QString SRSObject::SRS_SCHEDULESTATE_VAL_OPERATIONAL = "OPERATIONAL";
+QString SRSObject::SRS_SCHEDULESTATE_VAL_ERROR       = "ERROR"      ;
+QString SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED   = "COMPLETED"  ;
+
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_NONE        = ""   ;
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_GENERAL     = "100";
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_MAX_TASKS   = "101";
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_EPG_MISSING = "102";
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_DISABLED    = "103";
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_OUTOFMEMORY = "104";
+QString SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_RESOURCE    = "105";
+
+
+QString SRSObject::SRS_TASKSTATE_VAL_IDLE_READY                   = "IDLE.READY"                       ;
+QString SRSObject::SRS_TASKSTATE_VAL_IDLE_ATRISK                  = "IDLE.ATRISK"                      ;
+QString SRSObject::SRS_TASKSTATE_VAL_ACTIVE_REC_FROMSTART_OK      = "ACTIVE.RECORDING.FROMSTART.OK"    ;
+QString SRSObject::SRS_TASKSTATE_VAL_ACTIVE_REC_FROMSTART_ATRISK  = "ACTIVE.RECORDING.FROMSTART.ATRISK";
+QString SRSObject::SRS_TASKSTATE_VAL_ACTIVE_NOTRECORDING          = "ACTIVE.NOTRECORDING"              ;
+QString SRSObject::SRS_TASKSTATE_VAL_DONE_FULL                    = "DONE.FULL"                        ;
+QString SRSObject::SRS_TASKSTATE_VAL_DONE_PARTIAL                 = "DONE.PARTIAL"                     ;
+QString SRSObject::SRS_TASKSTATE_VAL_DONE_EMPTY                   = "DONE.EMPTY"                       ;
+
+QString SRSObject::SRS_TASKSTATE_PHASE_VAL_IDLE                   = "IDLE"  ;
+QString SRSObject::SRS_TASKSTATE_PHASE_VAL_ACTIVE                 = "ACTIVE";
+QString SRSObject::SRS_TASKSTATE_PHASE_VAL_DONE                   = "DONE"  ;
+
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_GENERAL                = "100";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_DISABLED               = "101";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SCHED_OVERRIDE         = "102";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_MEDIA_GENERAL          = "200";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_MEDIA_NO_MEDIA         = "201";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_MEDIA_WRITE_PROT       = "202";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_MEDIA_INSUFF_SPACE     = "203";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_MEDIA_LOW_SPACE        = "204";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_GENERAL         = "300";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_INSUFF_MEM      = "301";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_INSUFF_CPU      = "302";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_MEM         = "303";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_CPU         = "304";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_NO_SIGNAL       = "305";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_LOW_SIGNAL      = "306";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_NO_EPG          = "307";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_CONTENT_GENERAL        = "400";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_CONTENT_CONFLICT_LOSE  = "401";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_CONTENT_CONFLICT_WIN   = "402";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_CONTENT_PAYPERVIEW     = "403";
+QString SRSObject::SRS_TASKSTATE_ERROR_VAL_CONTENT_RESCHEDULED    = "404";
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+static const QString empty = "";
+
+SRSDependentProperty *SRSPropertyValue::AddDependentProperty(SRSDependentProperty* pProp)
+{
+	SRSDependentProperty *existing = RemoveDependentProperty(pProp->m_sName);
+	if (existing)
+		delete existing;
+    m_dependentProperties.insert(pProp->m_sName, pProp);
+    return pProp;
+}
+
+SRSDependentProperty *SRSPropertyValue::SetDependentProperty (const QString &sName,
+		const QString &sValue, bool required)
+{
+    SRSDependentPropertyMap::iterator itr    = m_dependentProperties.find(sName);
+    SRSDependentProperty             *pProp = NULL;
+    if (itr !=  m_dependentProperties.end() && *itr)
+    {
+        pProp = (*itr);
+        pProp->SetValue(sValue);
+    }
+    else
+    {
+        //create one
+        pProp = AddDependentProperty( new SRSDependentProperty(sName, required, sValue) );
+    }
+    return pProp;
+}
+
+SRSDependentProperty *SRSPropertyValue::GetDependentProperty (const QString &sName)
+{
+    SRSDependentPropertyMap::iterator itr    = m_dependentProperties.find(sName);
+    SRSDependentProperty             *pProp = NULL;
+    if (itr !=  m_dependentProperties.end() && *itr)
+    {
+        pProp = (*itr);
+    }
+    return pProp;
+}
+
+SRSDependentPropertyMap SRSPropertyValue::GetDependentProperties( )
+{
+	return m_dependentProperties;
+}
+
+SRSDependentProperty *SRSPropertyValue::RemoveDependentProperty (const QString &sName)
+{
+    SRSDependentProperty *pProp = NULL;
+    SRSDependentPropertyMap::iterator it = m_dependentProperties.find(sName);
+	if (it != m_dependentProperties.end())
+	{
+		pProp = *it;
+		m_dependentProperties.erase(it);
+	}
+    return pProp;
+}
+
+
+SRSPropertyValue *SRSPropertyValue::SetValue(const QString &sValue)
+{
+    this->m_sValue = HTTPRequest::Encode(sValue);
+    return this;
+}
+
+QString SRSPropertyValue::GetValue()
+{
+	return QUrl::fromPercentEncoding(this->m_sValue.toLatin1());
+}
+
+bool SRSPropertyValue::toXMLSnippet(QTextStream &os)
+{
+    os << "<"  << m_sName;
+    if (m_dependentProperties.size())
+    {
+        SRSDependentPropertyMap::const_iterator itr = m_dependentProperties.begin();
+        for (; itr != m_dependentProperties.end(); ++itr)
+        {
+            SRSDependentProperty *pProp = *itr;
+            //don't include if value is empty
+            if (pProp->m_sValue.isEmpty() && !pProp->m_bRequired)
+                continue;
+            os << " " << pProp->m_sName << "=\"" << pProp->m_sValue <<"\"";
+        }
+    }
+    os << ">";
+    os << m_sValue;
+    os << "</" << m_sName << ">";
+    return true;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSPropertyValue *SRSProperty::SetValue(const QString &sValue)
+{
+    SRSPropertyValue *pProp = AddValue( new SRSPropertyValue(m_sName,
+								m_sNameSpace, m_bRequired,
+								HTTPRequest::Encode(sValue)));
+    //add dependent properties?
+    SRSDependentPropertyMap::const_iterator itr = m_dependentProperties.begin();
+    for (; itr != m_dependentProperties.end(); ++itr)
+    {
+        SRSDependentProperty *pDepProp = *itr;
+        pProp->AddDependentProperty(new SRSDependentProperty(pDepProp->m_sName,
+										pDepProp->m_bRequired, pDepProp->m_sValue));
+    }
+    return pProp;
+}
+
+SRSPropertyValue *SRSProperty::GetFirstValue()
+{
+	//return the first value
+	if (m_lValues.size())
+		return m_lValues.front();
+	return NULL;	//else return empty value
+}
+
+QStringList SRSProperty::GetValueStrings()
+{
+	//return the first value
+	QStringList retList;
+    SRSPropertyValueList::const_iterator itr = m_lValues.begin();
+    for (; itr != m_lValues.end(); ++itr)
+    {
+        SRSPropertyValue *pProp = *itr;
+        retList << pProp->GetValue();
+    }
+	return retList;	//else return empty value
+}
+
+SRSPropertyValueList SRSProperty::GetValues()
+{
+	return m_lValues;
+}
+
+SRSPropertyValue *SRSProperty::AddValue(SRSPropertyValue* pProp)
+{
+	if (m_bMultiValued)
+		m_lValues.append(pProp);
+	else
+	{
+		//delete current props
+		while(m_lValues.size())
+		{
+			SRSPropertyValue *pPropValTmp = m_lValues.front();
+			delete pPropValTmp;
+			m_lValues.pop_front();
+		}
+		m_lValues.append(pProp);
+	}
+    return pProp;
+}
+
+bool SRSProperty::toXMLSnippet(QTextStream &os)
+{
+    SRSPropertyValueList::const_iterator itr = m_lValues.begin();
+    for (; itr != m_lValues.end(); ++itr)
+    {
+        SRSPropertyValue *pProp = *itr;
+        pProp->toXMLSnippet(os);
+    }
+    return true;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QString SRSObject::SecsToDuration( int secs )
+{
+    int hh = (int) (secs / (60 * 60));
+    char tmp[32];
+    if (hh > 24)
+    {
+    	int dd = (int)( hh / 24 );
+    	hh = hh % 24;
+    	snprintf(tmp, 32, "P%dD%.2d:%.2d:%.2d", dd, hh, ((secs - (hh * 3600))/60), (secs % 60));
+    }
+    else
+    	snprintf(tmp, 32, "P%.2d:%.2d:%.2d", hh, ((secs - (hh * 3600))/60), (secs % 60));
+    return QString::fromAscii(tmp);
+}
+
+int SRSObject::DurationToSecs(const QString &duration)
+{
+    QStringList tokens = duration.split(':', QString::SkipEmptyParts);//QRegExp("P\\d{0,2}\\:\\d{0,2}\\:\\d{0,2}")
+    int secs = 0;
+    if (tokens.size() >= 3)
+    {
+        if (tokens[0].startsWith('P'))
+            tokens[0] = tokens[0].mid(1);
+        int dmark = tokens[0].indexOf('D');
+        if (dmark >= 0)
+        {
+        	QString days = tokens[0].left(dmark);
+        	tokens[0] = tokens[0].mid(dmark + 1);
+        	secs += days.toInt() * 24 * 3600;
+        }
+        secs += (tokens[0].toInt()*3600 + tokens[1].toInt()*60 + tokens[2].toInt());
+    }
+    return secs;
+}
+
+QString SRSObject::DateTimeToString(QDateTime &qdt)
+{
+    return qdt.toString("yyyy-MM-ddThh:mm:ss");
+}
+
+QDateTime SRSObject::StringToDateTime(const QString &sdt, QStringList *days)
+{
+    if (sdt == "NOW")
+        return QDateTime::currentDateTime();
+    QDateTime qdt;
+    //regex
+    if (sdt.indexOf(QRegExp("\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}")) == 0)
+    {
+    	qdt = QDateTime::fromString(sdt, "yyyy-MM-ddThh:mm:ss");
+    }
+    else if (sdt.indexOf(QRegExp("\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}")) == 0)
+    {
+    	qdt = QDateTime::fromString(sdt, "MM-ddThh:mm:ss");
+    	qdt.addYears(QDate::currentDate().year() - qdt.date().year());
+    }
+    else if (sdt.indexOf(QRegExp("T\\d{2}:\\d{2}:\\d{2}")) == 0)
+    {
+    	qdt = QDateTime::fromString(sdt, "Thh:mm:ss");
+    	qdt.setDate(QDate::currentDate());
+		if (days && qdt.isValid())
+			days->append("Everyday");
+    }
+    else if (sdt.indexOf(QRegExp("[A-Z]{3}T\\d{2}:\\d{2}:\\d{2}")) == 0)
+    {
+		QString sdtcc = sdt;
+		sdtcc.replace("MON", "Mon").replace("TUE", "Tue")
+			 .replace("WED", "Wed").replace("THU", "Thu")
+			 .replace("FRI", "Fri").replace("SAT", "Sat")
+			 .replace("SUN", "Sun");
+		qdt = QDateTime::fromString(sdtcc, "dddThh:mm:ss");
+		qdt.setDate(QDate::currentDate());
+		if (days && qdt.isValid())
+			days->append(qdt.toString("ddd"));
+    }
+    else if (sdt.indexOf(QRegExp("[A-Z]{3}-[A-Z]{3}T\\d{2}:\\d{2}:\\d{2}")) == 0)
+    {
+    	QStringList range = sdt.split('-', QString::SkipEmptyParts);
+		QDateTime qdf = QDateTime::fromString(range[0], "ddd");
+		qdt = QDateTime::fromString(range[1], "dddThh:mm:ss");
+		qdt.setDate(QDate::currentDate());
+		if (days && qdf.isValid() && qdt.isValid())
+		{
+			days->append(qdf.toString("ddd"));
+			days->append(qdt.toString("ddd"));
+		}
+    }
+    if (!qdt.isValid())    //assume something
+    	qdt = QDateTime::currentDateTime();
+    return qdt;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSProperty *SRSObject::AddProperty( SRSProperty *pProp )
+{
+    if (pProp)
+    {
+        SRSPropertyMap::iterator it = m_properties.find(pProp->GetName());
+        if (it != m_properties.end())
+        {
+            SRSProperty *pSRSProp = *it;
+            m_properties.erase(it);
+            delete pSRSProp;
+        }
+        m_properties[pProp->GetName()] = pProp;
+    }
+
+    return pProp;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+SRSProperty *SRSObject::RemoveProperty( const QString &sName )
+{
+	SRSProperty *pProp = NULL;
+	SRSPropertyMap::iterator it = m_properties.find(sName);
+	if (it != m_properties.end())
+	{
+		pProp = *it;
+		m_properties.erase(it);
+	}
+    return pProp;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+//
+//SRSDependentProperty *SRSObject::AddDependentProperty( const QString &sName, SRSDependentProperty *pProp )
+//{
+//    if (pProp)
+//    {
+//    	SRSPropertyMap::iterator it = m_properties.find(sName);
+//        if (it !=  m_properties.end() && *it)
+//        {
+//            SRSPropertyValue *propVal = (*it)->GetFirstValue();
+//            if (propVal)
+//            	pProp = propVal->AddDependentProperty(pProp);
+//            else
+//            	pProp = NULL;
+//        }
+//    }
+//
+//    return pProp;
+//}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSProperty *SRSObject::GetProperty( const QString &sName )
+{
+    SRSPropertyMap::const_iterator itr = m_properties.find(sName);
+
+    if (itr !=  m_properties.end() && *itr)
+    {
+        SRSProperty *pProp = *itr;
+        return pProp;
+    }
+    return NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSPropertyValue *SRSObject::SetPropValue( const QString &sName,
+		const QString &sNameSpace, const QString &sValue, bool bRequired,
+		bool bMultiValued)
+{
+	SRSPropertyValue *ret = NULL;
+    SRSPropertyMap::iterator it = m_properties.find(sName);
+    if (it !=  m_properties.end() && *it)
+    {
+    	SRSProperty *pProp = (*it);
+        ret = pProp->SetValue(sValue);
+    }
+    else
+    {
+    	SRSProperty *pProp = AddProperty( new SRSProperty(sName, sNameSpace,
+								bRequired, bMultiValued));
+    	ret = pProp->SetValue(sValue);
+    }
+    return ret;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSPropertyValue *SRSObject::GetPropFirstValue(const QString &sName) const
+{
+	SRSPropertyValue *ret = NULL;
+    SRSPropertyMap::const_iterator it = m_properties.find(sName);
+
+    if (it !=  m_properties.end() && *it)
+    {
+    	//return QUrl::fromPercentEncoding((*t)->GetValue().toLatin1());
+    	ret = (*it)->GetFirstValue();
+    }
+
+    return ret;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSPropertyValueList SRSObject::GetPropValues(const QString &sName)
+{
+	SRSPropertyValueList ret;
+    SRSPropertyMap::const_iterator it = m_properties.find(sName);
+
+    if (it !=  m_properties.end() && *it)
+    {
+    	ret = (*it)->GetValues();
+    }
+
+    return ret;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QString SRSObject::toXml( FilterMap &filter ) const
+{
+    QString     sXML;
+    QTextStream os( &sXML, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    toXml(os, filter);
+    os << flush;
+    return( sXML );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void SRSObject::toXml(QTextStream &os, FilterMap &filterIn) const
+{
+    QString sEndTag = "";
+    bool    bFilter = true;
+
+    FilterMap filter;
+    //edit it to handle dependent properties by extracting only the property part
+    for(FilterMap::iterator itr = filterIn.begin(); itr != filterIn.end(); itr++)
+    {
+    	QString sFilter = *itr;
+    	int atIndex = sFilter.indexOf("@");
+    	if (atIndex > 0)
+    		sFilter = sFilter.left(atIndex);
+    	if (sFilter.endsWith(":"))
+    		sFilter.append("*");   //in case filter property is like "srs:@id"
+    	filter.append(sFilter);
+    }
+
+
+    if ((filter.indexOf( "*" ) != -1) || (filter.indexOf( "*:*" ) != -1))
+        bFilter = false;
+
+    os << "<item id=\"" << m_sId << "\">";
+    os << "<title>" << m_sTitle << "</title>";
+    os << "<class>" << m_sClass << "</class>";
+
+    sEndTag = "</item>";
+
+    // ----------------------------------------------------------------------
+    // Output all Properties
+    // ----------------------------------------------------------------------
+
+    SRSPropertyMap::const_iterator it = m_properties.begin();
+    for (; it != m_properties.end(); ++it)
+    {
+        SRSProperty *pProp = *it;
+
+        if (pProp->IsRequired() || (pProp->NumValues() > 0))
+        {
+            QString sName;
+            bool bNameSpaceFilter = false;
+
+            if (pProp->GetNameSpace().length() > 0)
+            {
+                sName = pProp->GetFullName();
+                bNameSpaceFilter = ( filter.indexOf( QString(pProp->GetNameSpace())
+														.append(":*") ) != -1);
+            }
+            else
+                sName = pProp->GetName();
+
+            if (pProp->IsRequired() || !bFilter
+                || ( filter.indexOf( sName ) != -1) || bNameSpaceFilter)
+            {
+                pProp->toXMLSnippet(os);
+            }
+        }
+    }
+
+    os << sEndTag;
+    os << flush;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+QStringList SRSObject::GetPropertyList()
+{
+    QStringList retList;
+    retList << "srs:@id" << "srs:title" << "srs:class";    //required for all objects
+
+    // ----------------------------------------------------------------------
+    // Add all other Property names
+    // ----------------------------------------------------------------------
+    SRSPropertyMap::const_iterator it = m_properties.begin();
+    for (; it != m_properties.end(); ++it)
+    {
+        SRSProperty *pProp = *it;
+        retList << pProp->GetFullName();
+        SRSDependentPropertyMap depProps = pProp->GetDependentProperties();
+		SRSDependentPropertyMap::const_iterator itdep = depProps.begin();
+		for (; itdep != depProps.end(); ++itdep)
+		{
+			SRSDependentProperty *pPropDep = *itdep;
+			retList << pProp->GetFullName() + "@" + pPropDep->m_sName;
+		}
+    }
+    return retList;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+
+SRSObject *SRSObject::CreateSRSObject( const QString &sId,
+		const QString &sTitle,const QString &sSRSClass, SRSObject *pObject )
+{
+    if (pObject == NULL)
+    {
+        pObject = new SRSObject( sId, sTitle );
+        pObject->m_sClass = sSRSClass;
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordSchedule( const QString &sId, const QString &sTitle, const QString &sSRSClass, SRSObject *pObject )
+{
+    pObject = CreateSRSObject(sId, sTitle, sSRSClass, pObject);
+
+    // Base Properties
+    {
+        pObject->AddProperty( new SRSProperty( "additionalStatusInfo", "srs" ));
+    }
+
+    // Priority Properties
+    {
+        SRSProperty *pProp   = pObject->AddProperty( new SRSProperty("priority",
+																"srs", true ));
+        pProp->SetDependentProperty ("orderedValue", empty );
+
+        SRSProperty *pPropDP = pObject->AddProperty( new SRSProperty(
+													"desiredPriority", "srs" ));
+        pPropDP->SetDependentProperty("type", empty, true );
+    }
+
+
+    // Output Control Properties
+    {
+        SRSProperty *pPropRD = pObject->AddProperty(new SRSProperty(
+											"recordDestination", "srs", true, true));
+        pPropRD->SetDependentProperty( "mediaType"  , empty , true );
+        pPropRD->SetDependentProperty( "targetURL"  , empty , false);
+        pPropRD->SetDependentProperty( "preference" , empty , true );
+
+        SRSProperty      *pPropDRQ = pObject->AddProperty( new SRSProperty(
+										"desiredRecordQuality", "srs", false));
+        SRSPropertyValue *pValDRQ  = pPropDRQ->SetValue("AUTO" );
+        //QString defVal = "DEFAULT";
+        pValDRQ->SetDependentProperty ( "type", "DEFAULT" );
+
+    }
+
+    // Schedule State Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty("scheduleState",
+																"srs", true));
+        pProp->SetDependentProperty( "currentErrors", empty, true );
+
+        pObject->AddProperty( new SRSProperty( "abnormalTasksExist", "srs",
+												true, true));
+    }
+
+     // Statistics Properties
+    {
+        pObject->AddProperty( new SRSProperty( "currentRecordTaskCount", "srs", true));
+        //optional
+        //pObject->AddProperty( new SRSProperty( "totalCreatedRecordTasks", "srs"));
+        //pObject->AddProperty( new SRSProperty( "totalCompletedRecordTasks", "srs"));
+    }
+
+
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleDirect( const QString &sId,
+		const QString &sTitle, const QString &sSRSClass, SRSObject *pObject )
+{
+    pObject = CreateRecordSchedule(sId, sTitle, sSRSClass, pObject);
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleQuery( const QString &sId,
+		const QString &sTitle, const QString &sSRSClass, SRSObject *pObject )
+{
+    pObject = CreateRecordSchedule(sId, sTitle, sSRSClass, pObject);
+    // Content Control Properties (optional?)
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty(
+													"durationLimit", "srs" ));
+        pProp->SetDependentProperty("effect"  , empty );
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleDirectManual( const QString &sId,
+		const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleDirect(sId, sTitle, "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL", pObject);
+
+    // Content Identification Related Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty(
+										"scheduledChannelID", "srs", true));
+        pProp->SetDependentProperty("type"             , empty, true);
+        pProp->SetDependentProperty("distriNetworkName", empty);
+        pProp->SetDependentProperty("distriNetworkID"  , empty);
+
+        pObject->AddProperty(new SRSProperty( "scheduledStartDateTime", "srs",
+											  true, true));
+        pObject->AddProperty(new SRSProperty( "scheduledDuration", "srs", true));
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleDirectCdsEPG( const QString &sId,
+		const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleDirect(sId, sTitle, "OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG", pObject);
+
+    // Base Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty("cdsReference",
+																   "srs" ));
+        pProp->SetDependentProperty("link"  , empty );
+    }
+
+    // Content Identification Related Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty(
+											"scheduledCDSObjectID" , "srs" ));
+        pProp->SetDependentProperty("link"  , empty );
+    }
+
+    // Content Control Properties (optional?)
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty(
+													"durationLimit" , "srs" ));
+        pProp->SetDependentProperty("effect"  , empty );
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleDirectCdsNonEPG( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleDirect(sId, sTitle, "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG", pObject);
+
+    // Base Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty("cdsReference",
+																  "srs" ));
+        pProp->SetDependentProperty("link"  , empty );
+    }
+
+    // Content Identification Related Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty(
+											"scheduledCDSObjectID" , "srs" ));
+        pProp->SetDependentProperty("link"  , empty );
+
+        pObject->AddProperty(new SRSProperty( "scheduledStartDateTime", "srs",
+											  false, true ));
+        pObject->AddProperty(new SRSProperty( "scheduledDuration", "srs" ));
+    }
+
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleDirectProgramCode( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleDirect(sId, sTitle, "OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE", pObject);
+
+    // Content Identification Related Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty(
+											"scheduledProgramCode", "srs" ));
+        pProp->SetDependentProperty("type"  , empty);
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleParts( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+	//not properly implemented, currently used as dummy object only
+    pObject = CreateRecordScheduleDirect(sId, sTitle, "OBJECT.RECORDSCHEDULEPARTS", pObject);
+    return pObject;
+}
+
+
+SRSObject *SRSObject::CreateRecordTask( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateSRSObject(sId, sTitle, "OBJECT.RECORDTASK", pObject);
+
+    // Base Properties
+    {
+        pObject->AddProperty( new SRSProperty( "additionalStatusInfo", "srs" ));
+
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty("cdsReference",
+														"srs", false, true ));
+        pProp->SetDependentProperty("link"  , empty );
+    }
+
+    // Priority Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty("priority",
+														"srs", true ));
+        pProp->SetDependentProperty ("orderedValue", empty );
+
+        pObject->AddProperty( new SRSProperty( "desiredPriority", "srs" ));
+    }
+
+
+    // Output Control Properties
+    {
+        SRSProperty *pPropRD = pObject->AddProperty(new SRSProperty(
+										"recordDestination", "srs",true, true));
+        pPropRD->SetDependentProperty( "mediaType"  , empty , true);
+        pPropRD->SetDependentProperty( "targetURL"  , empty , false);
+        pPropRD->SetDependentProperty( "preference" , empty , true);
+
+        SRSProperty *pPropDRQ = pObject->AddProperty( new SRSProperty(
+								"desiredRecordQuality", "srs", false, "AUTO" ));
+        QString defVal = "DEFAULT";
+        pPropDRQ->SetDependentProperty ( "type", defVal );
+
+    }
+
+     // General Properties
+    {
+        pObject->AddProperty( new SRSProperty( "recordScheduleID", "srs"));
+        //optional
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty( "recordedCDSObjectID", "srs"));
+        pProp->SetDependentProperty("link", empty);
+    }
+
+     // Content ID Related Properties
+    {
+        SRSProperty *pPropTCOI = pObject->AddProperty(new SRSProperty(
+													"taskCDSObjectID", "srs"));
+        pPropTCOI->SetDependentProperty("link" , empty);
+
+        SRSProperty *pPropTCI = pObject->AddProperty( new SRSProperty(
+												"taskChannelID", "srs", true));
+        pPropTCI->SetDependentProperty("type"             , empty, true);
+        pPropTCI->SetDependentProperty("distriNetworkName", empty);
+        pPropTCI->SetDependentProperty("distriNetworkID"  , empty);
+
+        pObject->AddProperty(new SRSProperty( "taskStartDateTime", "srs", true));
+        pObject->AddProperty(new SRSProperty( "taskDuration"     , "srs", true));
+
+        SRSProperty *pPropPC = pObject->AddProperty(new SRSProperty(
+													"taskProgramCode", "srs"));
+        pPropPC->SetDependentProperty("type", empty, true);
+
+        SRSProperty *pPropRQ = pObject->AddProperty(new SRSProperty(
+												"recordQuality", "srs", true));
+        pPropRQ->SetDependentProperty("type", empty, true);
+    }
+
+    // Matched Content Criteria
+    {
+        SRSProperty *pPropMN = pObject->AddProperty(new SRSProperty(
+														"matchedName", "srs"));
+        pPropMN->SetDependentProperty("type" , empty);
+
+        SRSProperty *pPropMI = pObject->AddProperty(new SRSProperty(
+														"matchedID", "srs"));
+        pPropMI->SetDependentProperty("type" , empty);
+    }
+
+    // Matched Qualifying Criteria
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty(
+													"matchedRating", "srs"));
+        pProp->SetDependentProperty("type" , empty);
+
+        pObject->AddProperty(new SRSProperty( "matchedEpisodeType",
+											  "srs"));
+    }
+
+    // Content Control Properties
+    {
+        pObject->AddProperty(new SRSProperty( "taskStartDateTimeAdjust", "srs"));
+        pObject->AddProperty(new SRSProperty( "taskDurationAdjust"     , "srs"));
+
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty(
+												"taskDurationLimit", "srs"));
+        pProp->SetDependentProperty("effect" , empty);
+
+        pObject->AddProperty(new SRSProperty( "taskChannelMigration", "srs"));
+        pObject->AddProperty(new SRSProperty( "taskTimeMigration"   , "srs"));
+    }
+
+    //Task State Properties
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty( "taskState",
+																	"srs", true));
+        pProp->SetDependentProperty("phase"            , empty, true );
+        pProp->SetDependentProperty("startDateTimeMet" , empty, false);
+        pProp->SetDependentProperty("endDateTimeMet"   , empty, false);
+        pProp->SetDependentProperty("recording"        , empty, true );
+        pProp->SetDependentProperty("someBitsRecorded" , empty, true );
+        pProp->SetDependentProperty("someBitsMissing"  , empty, true );
+        pProp->SetDependentProperty("firstBitsRecorded", empty, false);
+        pProp->SetDependentProperty("lastBitsRecorded" , empty, false);
+        pProp->SetDependentProperty("fatalError"       , empty, true );
+        pProp->SetDependentProperty("currentErrors"    , empty, true );
+        pProp->SetDependentProperty("errorHistory"     , empty, true );
+        pProp->SetDependentProperty("pendingErrors"    , empty, true );
+        pProp->SetDependentProperty("infoList"         , empty, true );
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleQueryContentName( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleQuery(sId, sTitle, "OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME", pObject);
+    // Matching Content Criteria
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty(
+													"matchingName", "srs" ));
+        pProp->SetDependentProperty("type"           , empty );
+        pProp->SetDependentProperty("subStringMatch" , empty );
+    }
+
+    // Matching Qualifying Criteria
+    {
+        SRSProperty *pProp = pObject->AddProperty(new SRSProperty(
+												"matchingChannelID", "srs" ));
+        pProp->SetDependentProperty("type", empty );
+
+        SRSProperty *pPropMRL = pObject->AddProperty(new SRSProperty(
+												"matchingRatingLimit", "srs" ));
+        pPropMRL->SetDependentProperty("type", empty );
+    }
+    return pObject;
+}
+
+SRSObject *SRSObject::CreateRecordScheduleQueryContentID( const QString &sId, const QString &sTitle, SRSObject *pObject )
+{
+    pObject = CreateRecordScheduleQuery(sId, sTitle, "OBJECT.RECORDSCHEDULE.QUERY.CONTENTID", pObject);
+    // Matching Content Criteria
+    {
+        SRSProperty *pProp = pObject->AddProperty( new SRSProperty( "matchingID",
+																	"srs" ));
+        pProp->SetDependentProperty("type", empty );
+    }
+
+    // Matching Qualifying Criteria
+    {
+        SRSProperty *pPropMRL = pObject->AddProperty( new SRSProperty(
+											"matchingRatingLimit", "srs" ));
+        pPropMRL->SetDependentProperty("type", empty );
+    }
+    return pObject;
+}
+
+void SRSObject::SyncSRSObjects(SRSObject *objFrom, SRSObject *objTo)
+{
+	if (objTo->m_nUpdateId == 0)       objTo->m_nUpdateId  = objFrom->m_nUpdateId;
+	if (objTo->m_sContextID.isEmpty()) objTo->m_sContextID = objFrom->m_sContextID;
+	if (objTo->m_sDataStructureType.isEmpty())
+		objTo->m_sDataStructureType  = objFrom->m_sDataStructureType;
+
+	if (objTo->m_sId.isEmpty()   )     objTo->m_sId    = objFrom->m_sId;
+	if (objTo->m_sTitle.isEmpty())     objTo->m_sTitle = objFrom->m_sTitle;
+	if (objTo->m_sClass.isEmpty())     objTo->m_sClass = objFrom->m_sClass;
+
+//	if (objTo->m_lsSortCriteria && objTo->m_lsSortCriteria->isEmpty())
+//		objTo->m_lsSortCriteria     = objFrom->m_lsSortCriteria;
+
+	SRSPropertyMap::iterator itrProp = objFrom->m_properties.begin();
+	for(; itrProp != objFrom->m_properties.end(); ++itrProp)
+	{
+		QString     sName      = itrProp.key();
+		SRSProperty *pPropFrom = itrProp.value();
+		SRSProperty *pPropTo   = NULL;
+		bool add = false;
+
+		if (objTo->m_properties.contains(sName))
+		{
+			pPropTo = objTo->m_properties.value(sName);
+			if (pPropFrom->m_bMultiValued)
+			{
+				pPropTo->m_bMultiValued = true;	//just to be sure
+				add = true;
+			}
+			else if (pPropTo->GetFirstValue()->GetValue().isEmpty())
+				add = true;
+			else
+				add = false;
+		}
+		else
+		{
+			pPropTo = objTo->AddProperty(new SRSProperty(pPropFrom->GetName(),
+													pPropFrom->GetNameSpace(),
+													pPropFrom->IsRequired(),
+													pPropFrom->IsMultiValued()));
+			add = true;
+		}
+
+		if (add)
+		{
+			SRSPropertyValueList mPropsFrom = pPropFrom->GetValues();
+			SRSPropertyValueList mPropsTo   = pPropTo->GetValues();
+			SRSPropertyValueList addList;
+			for(int i = 0; i < mPropsFrom.size(); ++i)
+			{
+				bool addMval = true;
+				SRSPropertyValue *vPropFrom = mPropsFrom.at(i);
+
+				for(int j = 0; j < mPropsTo.size(); ++j)
+				{
+					SRSPropertyValue *vPropTo = mPropsTo.at(j);
+					if (!vPropFrom->GetValue().isEmpty()
+							&& (vPropFrom->GetValue() == vPropTo->GetValue()))
+					{
+						addMval = false;
+						break;
+					}
+				}
+				if (addMval)
+					addList.append(vPropFrom);
+			}
+
+			for(int i = 0; i < addList.size(); ++i)
+			{
+				SRSPropertyValue *pValFrom = addList.at(i);
+
+				SRSPropertyValue *pValTo = pPropTo->SetValue(pValFrom->GetValue());
+				//dup dependent properties
+				SRSDependentPropertyMap::const_iterator itrDep
+							= pValFrom->m_dependentProperties.begin();
+				for (; itrDep != pValFrom->m_dependentProperties.end(); ++itrDep)
+				{
+					SRSDependentProperty *pDepProp = itrDep.value();
+					pValTo->AddDependentProperty(
+								new SRSDependentProperty(pDepProp->m_sName,
+													pDepProp->m_bRequired,
+													pDepProp->m_sValue) );
+				}
+			}
+		}
+	}
+}
+
+//little or no validation is done against the spec
+QList<SRSObject*> SRSObject::fromXML( const QString &sXML )
+{
+	QList<SRSObject*> list;
+	QDomDocument doc("SRSObject");
+	if (!doc.setContent(sXML))
+	{
+        VERBOSE(VB_UPNP, QString("SRSObject::fromXML : unable to parse XML: [%1]")
+                			.arg(sXML));
+        return list;
+	}
+	//VERBOSE(VB_UPNP, QString("SRSObject::fromXML : Parsing XMl=[%1]").arg(sXML));
+
+	QDomElement rootElement = doc.documentElement();	//<srs ...>
+	if (rootElement.isNull() || (rootElement.tagName() != "srs"))
+	{
+		VERBOSE(VB_UPNP, QString("SRSObject::fromXML : root element no 'srs' "));
+		return list;
+	}
+	QDomNode itemNode = rootElement.firstChild();			//<item id="">
+	while (!itemNode.isNull())
+	{
+		QDomElement itemElement = itemNode.toElement(); // convert the node to an element.
+		if (itemElement.isNull() || (itemElement.tagName() != "item"))
+		{
+			VERBOSE(VB_UPNP, QString("SRSObject::fromXML : not found expected "
+								"tag 'item'"));
+			continue;
+		}
+		QString sId = itemElement.attribute("id", "");
+
+		QDomElement element;
+		QDomNode node = itemNode.firstChild();	//<title>
+		element = node.toElement();
+		if (node.isNull() || element.isNull() || (node.nodeName() != "title"))
+		{
+			VERBOSE(VB_UPNP, QString("SRSObject::fromXML : not found expected "
+								"tag 'class'"));
+			continue;
+		}
+		QString sTitle = element.text();
+
+		node    = node.nextSibling();	//<class>
+		element = node.toElement();
+		if (node.isNull() || element.isNull() || (node.nodeName() != "class"))
+		{
+			VERBOSE(VB_UPNP, QString("SRSObject::fromXML : not found expected "
+								"tag 'title'"));
+			continue;
+		}
+		QString sClass = element.text();
+
+		VERBOSE(VB_UPNP, QString("SRSObject::fromXML : Creating SRS Object "
+							"id='%1' title='%2' class='%3'").arg(sId)
+							.arg(sTitle).arg(sClass));
+		SRSObject *pObject = CreateSRSObject(sId, sTitle, sClass, NULL);
+
+		//now add all child nodes as properties in the srs object
+		node  = node.nextSibling();
+		while( !node.isNull() )
+		{
+			QDomElement e = node.toElement(); // convert the node to an element.
+			if( !e.isNull() )
+			{ // the node was really an element.
+				QString sTag = e.tagName();
+				QString sVal = e.text();
+				SRSProperty      *pProp = NULL;
+				SRSPropertyValue *pVal  = NULL;
+
+				QDomNodeList nodeList = itemElement.elementsByTagName(sTag);
+				if (nodeList.size() == 1) //check if it is multivalued
+				{
+					pProp = pObject->AddProperty(new SRSProperty(sTag, "srs"));
+					pVal  = pProp->SetValue(sVal);
+				}
+				else
+				{
+					pProp = pObject->AddProperty(new SRSProperty(sTag,"srs",
+																false, true));
+					pVal  = pProp->SetValue(sVal);
+				}
+
+//				QString sLog = QString("SRSObject::fromXML : Added SRS Property"
+//									" name='%1' value='%2'").arg(sTag).arg(sVal);
+
+				QDomNamedNodeMap attrs = e.attributes();
+				for(unsigned int i = 0; i < attrs.length(); ++i)
+				{
+					QDomAttr attr = attrs.item(i).toAttr();
+					if (!attr.isNull())
+					{
+						pVal->SetDependentProperty(attr.name(), attr.value());
+						//sLog.append(QString(" @%1='%2'").arg(attr.name()).arg(attr.value()));
+					}
+				}
+				//VERBOSE(VB_UPNP, sLog);
+			}
+			node = node.nextSibling();
+		}
+
+		list.append(pObject);
+
+		itemNode = itemNode.nextSibling();
+	}
+	return list;
+}
Index: libs/libmythupnp/upnp.h
===================================================================
--- libs/libmythupnp/upnp.h	(revision 4503)
+++ libs/libmythupnp/upnp.h	(working copy)
@@ -91,6 +91,55 @@
     UPnPResult_CMGR_InvalidConnectionRef     = 706,
     UPnPResult_CMGR_NotInNetwork             = 707,
 
+    UPnPResult_AVT_IllegalMimeType           = 714,
+    UPnPResult_AVT_ContentBusy               = 715,
+    UPnPResult_AVT_ResourceNotFound          = 716,
+    UPnPResult_AVT_InvalidInstanceID         = 718,
+    UPnPResult_AVT_DRMError                  = 719,
+    UPnPResult_AVT_ExpiredContent            = 720,
+    UPnPResult_AVT_NonAllowedUse             = 721,
+    UPnPResult_AVT_CantDetermineAllowedUsers = 722,
+    UPnPResult_AVT_ExhaustedAllowedUse       = 723,
+    UPnPResult_AVT_DeviceAuthFailure         = 724,
+    UPnPResult_AVT_DeviceRevocation          = 725,
+    UPnPResult_AVT_TransitionNotAvailable    = 701,
+    UPnPResult_AVT_TransportLocked           = 705,
+    UPnPResult_AVT_NoContents                = 702,
+    UPnPResult_AVT_ReadError                 = 703,
+    UPnPResult_AVT_FormatNotSupported        = 704,
+    UPnPResult_AVT_SeekModeNotSupported      = 710,
+    UPnPResult_AVT_IllegalSeekTarget         = 711,
+    UPnPResult_AVT_RecordQualityNotSupported = 713,
+    UPnPResult_AVT_InvalidStateVariableList  = 726,
+    UPnPResult_AVT_IllFormedCSVList          = 727,
+    UPnPResult_AVT_InvalidStateVariableValue = 728,
+    UPnPResult_AVT_InvalidServiceType        = 729,
+    UPnPResult_AVT_InvalidServiceId          = 730,
+
+    UPnPResult_AVT_InvalidDataTypeID         = 711,
+
+    UPnPResult_SRS_InvalidSyntax             = 701,
+    UPnPResult_SRS_InvalidValue              = 703,
+    UPnPResult_SRS_NoSuchRecordScheduleID    = 704,
+    UPnPResult_SRS_ActiveRecordTask          = 705,
+    UPnPResult_SRS_ReadOnlyProperty	         = 707,
+    UPnPResult_SRS_RequiredProperty          = 708,
+    UPnPResult_SRS_InvalidSortCriteria       = 709,
+    UPnPResult_SRS_InvalidDataTypeID         = 711,
+    UPnPResult_SRS_NoSuchRecordTaskID        = 713,
+    UPnPResult_SRS_CannotProcessRequest      = 720,
+    UPnPResult_SRS_Conflict                  = 730,
+    UPnPResult_SRS_ProtectedContents         = 731,
+    UPnPResult_SRS_NoMedia                   = 732,
+    UPnPResult_SRS_MediaWriteProtect         = 733,
+    UPnPResult_SRS_MediaNoSpace              = 734,
+    UPnPResult_SRS_MediaError                = 735,
+    UPnPResult_SRS_TooManyRecordSchedules    = 736,
+    UPnPResult_SRS_ResourceError             = 737,
+    UPnPResult_SRS_CannotDisOrEnable         = 739,
+    UPnPResult_SRS_RecordScheduleCompleted   = 740,
+    UPnPResult_SRS_RecordTaskDone            = 741,
+
     UPnPResult_MS_AccessDenied               = 801
 
 } UPnPResultCode;
Index: libs/libmythupnp/upnpcdsobjects.h
===================================================================
--- libs/libmythupnp/upnpcdsobjects.h	(revision 4503)
+++ libs/libmythupnp/upnpcdsobjects.h	(working copy)
@@ -230,6 +230,10 @@
         static  CDSObject *CreateStorageSystem    ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
         static  CDSObject *CreateStorageVolume    ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
         static  CDSObject *CreateStorageFolder    ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
+        static  CDSObject *CreateEpgItem          ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
+        static  CDSObject *CreateAudioProgram     ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
+        static  CDSObject *CreateVideoProgram     ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
+        static  CDSObject *CreateEpgContainer     ( QString sId, QString sTitle, QString sParentId, CDSObject *pObject = NULL ); 
 
 };        
 
Index: libs/libmythupnp/httprequest.h
===================================================================
--- libs/libmythupnp/httprequest.h	(revision 4503)
+++ libs/libmythupnp/httprequest.h	(working copy)
@@ -73,7 +73,8 @@
     ResponseTypeXML      =  1,
     ResponseTypeHTML     =  2,
     ResponseTypeFile     =  3,
-    ResponseTypeOther    =  4
+    ResponseTypeOther    =  4,
+    ResponseTypeStream   =  5
 
 } ResponseType;
 
Index: programs/mythbackend/SRS_scpd.xml
===================================================================
--- programs/mythbackend/SRS_scpd.xml	(revision 0)
+++ programs/mythbackend/SRS_scpd.xml	(revision 0)
@@ -0,0 +1,377 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+  <major>1</major>
+  <minor>0</minor>
+</specVersion>
+<actionList>
+	<action>
+		<name>GetSortCapabilities</name>
+		<argumentList>
+			<argument>
+				<name>SortCaps</name>
+				<direction>out</direction>
+				<relatedStateVariable>SortCapabilities</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>SortLevelCap</name>
+				<direction>out</direction>
+				<relatedStateVariable>SortLevelCapability</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetPropertyList</name>
+		<argumentList>
+			<argument>
+				<name>DataTypeID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_DataTypeID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>PropertyList</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetAllowedValues</name>
+		<argumentList>
+			<argument>
+				<name>DataTypeID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_DataTypeID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Filter</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>PropertyInfo</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyInfo</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+	        <name>GetStateUpdateID</name>
+		<argumentList>
+			<argument>
+				<name>Id</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>BrowseRecordSchedules</name>
+		<argumentList>
+			<argument>
+				<name>Filter</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>StartingIndex</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_Index</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>RequestedCount</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>SortCriteria</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_SortCriteria</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Result</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordSchedule</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>NumberReturned</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>TotalMatches</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>BrowseRecordTasks</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Filter</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>StartingIndex</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_Index</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>RequestedCount</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>SortCriteria</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_SortCriteria</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Result</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordTask</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>NumberReturned</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>TotalMatches</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_Count</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>CreateRecordSchedule</name>
+		<argumentList>
+			<argument>
+				<name>Elements</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordScheduleParts</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Result</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordSchedule</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>DeleteRecordSchedule</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetRecordSchedule</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Filter</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Result</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordSchedule</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>EnableRecordSchedule</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>DisableRecordSchedule</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetRecordTask</name>
+		<argumentList>
+			<argument>
+				<name>RecordTaskID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Filter</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_PropertyList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>Result</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_RecordTask</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetRecordScheduleConflicts</name>
+		<argumentList>
+			<argument>
+				<name>RecordScheduleID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>RecordScheduleConflictIDList</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectIDList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+	<action>
+		<name>GetRecordTaskConflicts</name>
+		<argumentList>
+			<argument>
+				<name>RecordTaskID</name>
+				<direction>in</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectID</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>RecordTaskConflictIDList</name>
+				<direction>out</direction>
+				<relatedStateVariable>A_ARG_TYPE_ObjectIDList</relatedStateVariable>
+			</argument>
+			<argument>
+				<name>UpdateID</name>
+				<direction>out</direction>
+				<relatedStateVariable>StateUpdateID</relatedStateVariable>
+			</argument>
+		</argumentList>
+	</action>
+</actionList>
+<serviceStateTable>
+	<stateVariable sendEvents="no">
+		<name>SortCapabilities</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>SortLevelCapability</name>
+		<dataType>ui4</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>StateUpdateID</name>
+		<dataType>ui4</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="yes">
+		<name>LastChange</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_PropertyList</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_DataTypeID</name>
+		<dataType>string</dataType>
+		<allowedValueList>
+			<allowedValue>A_ARG_TYPE_RecordSchedule</allowedValue>
+			<allowedValue>A_ARG_TYPE_RecordTask</allowedValue>
+			<allowedValue>A_ARG_TYPE_RecordScheduleParts</allowedValue>
+		</allowedValueList>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_ObjectID</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<Optional/>
+		<name>A_ARG_TYPE_ObjectIDList</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_PropertyInfo</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_Index</name>
+		<dataType>ui4</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_Count</name>
+		<dataType>ui4</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_SortCriteria</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_RecordSchedule</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_RecordTask</name>
+		<dataType>string</dataType>
+	</stateVariable>
+	<stateVariable sendEvents="no">
+		<name>A_ARG_TYPE_RecordScheduleParts</name>
+		<dataType>string</dataType>
+	</stateVariable>
+</serviceStateTable>
+</scpd>
Index: programs/mythbackend/mythxml.cpp
===================================================================
--- programs/mythbackend/mythxml.cpp	(revision 4503)
+++ programs/mythbackend/mythxml.cpp	(working copy)
@@ -5,6 +5,9 @@
 //
 // Created By  : David Blain                    Created On : Oct. 24, 2005
 // Modified By : Daniel Kristjansson            Modified On: Oct. 31, 2007
+// Modified By : Harold Sutherland              Modified On: Jul. 13, 2009
+// Modified By : Kunal Kandekar                 Modified On: Mar. 01, 2010
+// Modified By :                                Modified On:
 //
 //////////////////////////////////////////////////////////////////////////////
 
@@ -17,6 +20,7 @@
 #include <QBuffer>
 #include <QEventLoop>
 #include <QImage>
+#include <QThreadPool>
 
 #include "mythxml.h"
 #include "backendutil.h"
@@ -124,6 +128,9 @@
     if (sURI == "GetInternetSearch"     ) return MXML_GetInternetSearch;
     if (sURI == "GetInternetSources"    ) return MXML_GetInternetSources;
 
+    if (sURI == "ChangeChannel"        ) return MXML_ChangeChannel;
+    if (sURI == "GetLiveTV"            ) return MXML_GetLiveTV;
+
     return MXML_Unknown;
 }
 
@@ -240,7 +247,16 @@
                     GetVideoArt    ( pRequest );
                     return true;
 
+                //WeMedia-specific functions
+                case MXML_ChangeChannel:
+                    ChangeChannel ( pRequest );
+                    return true;
 
+                case MXML_GetLiveTV:
+                    GetLiveTV ( pThread, pRequest );
+                    return true;
+                //End WeMedia-specific functions
+
                 default:
                 {
                     UPnp::FormatErrorResponse( pRequest,
@@ -1472,7 +1488,15 @@
 
     if (bIndexFile)
         pRequest->m_sFileName += ".idx";
+    else
+    {
+        // ----------------------------------------------------------------------
+        // Transcode file if so requested
+        // ----------------------------------------------------------------------
 
+        TranscodeVideo(pThread, pRequest, "", false, false, false);
+    }
+
     // ----------------------------------------------------------------------
     // check to see if the file exists
     // ----------------------------------------------------------------------
@@ -1754,6 +1778,13 @@
     }
 
     // ----------------------------------------------------------------------
+    // Transcode file if so requested
+    // ----------------------------------------------------------------------
+
+    TranscodeVideo(pThread, pRequest, sId, false, false, false);
+
+
+    // ----------------------------------------------------------------------
     // check to see if the file exists
     // ----------------------------------------------------------------------
 
@@ -1971,4 +2002,511 @@
     }
 }
 
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+static void transcoder_dtor(void *data)
+{
+    if (data)
+    {
+        LiveTranscoder *transcoder = (LiveTranscoder*)data;
+        transcoder->Stop();
+        VERBOSE(VB_UPNP, QString("transcoder_dtor: Transcoding stopped.") );
+    }
+}
+
+static void crash_handler(int sig)
+{
+    VERBOSE(VB_UPNP, QString("*******************************"));
+    VERBOSE(VB_UPNP, QString("crash_handler: Transcoding caused sig=%1 (%2)!")
+                        .arg(sig).arg((sig == SIGSEGV ? "segfault" : "other")));
+    VERBOSE(VB_UPNP, QString("*******************************"));
+    exit(sig);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void MythXML::ConfigureTranscoder(HTTPRequest *pRequest, LiveTranscoder *transcoder)
+{
+    QString sVCodec      = pRequest->m_mapParams[ "videocodec"       ];
+    QString sVFormat     = pRequest->m_mapParams[ "videoformat"      ];
+    QString sVideoBR     = pRequest->m_mapParams[ "videobitrate"     ];
+    QString sVideoHeight = pRequest->m_mapParams[ "videoheight"      ];
+    QString sVideoWidth  = pRequest->m_mapParams[ "videowidth"       ];
+    QString sVideoFRN    = pRequest->m_mapParams[ "videoframeratenum"];
+    QString sVideoFRD    = pRequest->m_mapParams[ "videoframerateden"];
+    QString sDeinterlace = pRequest->m_mapParams[ "deinterlace"      ];
+    QString sACodec      = pRequest->m_mapParams[ "audiocodec"       ];
+    QString sAFormat     = pRequest->m_mapParams[ "audioformat"      ];
+    QString sAudioBR     = pRequest->m_mapParams[ "audiobitrate"     ];
+    QString sAudioSR     = pRequest->m_mapParams[ "audiosamplerate"  ];
+
+    //defaults
+    if (sVFormat.isEmpty() && sVCodec.isEmpty())
+    {
+        sVFormat = "flv";
+        sVCodec  = "flv";
+    }
+    if (sACodec.isEmpty())  sACodec  = "mp3";
+    int nVideoBR     = (sVideoBR.isEmpty()     ? 5000 : sVideoBR.toInt() );
+    int nAudioBR     = (sAudioBR.isEmpty()     ? 128  : sAudioBR.toInt() );
+    int nAudioSR     = (sAudioSR.isEmpty()     ? 0    : sAudioSR.toInt() );
+    int nVideoFRN    = (sVideoFRN.isEmpty()    ? 1    : sVideoFRN.toInt());
+    int nVideoFRD    = (sVideoFRD.isEmpty()    ? 25   : sVideoFRD.toInt());
+    int bVideoDIL    = (sDeinterlace.isEmpty() ? 0    : 1);
+    int nVideoWd     = (sVideoWidth.isEmpty()  ? 0    : sVideoWidth.toInt() );
+    int nVideoHt     = (sVideoHeight.isEmpty() ? 0    : sVideoHeight.toInt() );
+
+    transcoder->setParam("videocodec"       , sVCodec  );
+    transcoder->setParam("videoformat"      , sVFormat );
+    transcoder->setParam("videobitrate"     , nVideoBR );
+    transcoder->setParam("videoheight"      , nVideoHt );
+    transcoder->setParam("videowidth"       , nVideoWd );
+    transcoder->setParam("videoframeratenum", nVideoFRN);
+    transcoder->setParam("videoframerateden", nVideoFRD);
+    transcoder->setParam("deinterlace"      , bVideoDIL);
+    transcoder->setParam("audiocodec"       , sACodec  );
+    transcoder->setParam("audioformat"      , sAFormat );
+    transcoder->setParam("audiosamplerate"  , nAudioSR );
+    transcoder->setParam("audiobitrate"     , nAudioBR );
+
+    VERBOSE(VB_UPNP, QString("MythXML::ConfigureTranscoder : "
+                        "vcodec=%1 vfmt=%2 vbr=%3 vfr=%4/%5 "
+                        "acodec=%6 afmt=%7 abr=%8 dimensions=%9.")
+                        .arg(sVCodec).arg(sVFormat).arg(nVideoBR)
+                        .arg(nVideoFRN).arg(nVideoFRD)
+                        .arg(sACodec).arg(sAFormat).arg(nAudioBR)
+                        .arg((nVideoHt && nVideoWd ?
+                                QString("%10x%11").arg(nVideoWd).arg(nVideoHt)
+                                : "same")));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int MythXML::TranscodeVideo( HttpWorkerThread *pThread, HTTPRequest *pRequest,
+        const QString &sId, bool bTranscodeByDefault, bool bForkByDefault, bool bIsLive )
+{
+    ThreadData *pData = (ThreadData *)pThread->GetWorkerData();
+    if (pData == NULL)
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Null ThreadData."));
+        return 0;
+    }
+
+    if ((pData->m_eType != ThreadData::DT_Video)
+            && (pData->m_eType != ThreadData::DT_Recording))
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Not video data."));
+        return 0;
+    }
+
+    //check if we should transcode if user-agent is of specific type
+    QString sUserAgent = pRequest->m_mapHeaders[ "User-Agent" ];
+    if (sUserAgent.isEmpty())
+        sUserAgent = pRequest->m_mapHeaders[ "user-agent" ];
+    VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Checking if transcoding"
+                        " needed for User-Agent='%1'.").arg(sUserAgent));
+    if (!bTranscodeByDefault && !sUserAgent.isEmpty())
+    {
+        if ((sUserAgent.indexOf("AdobeAIR", 0, Qt::CaseInsensitive) >= 0) ||
+            (sUserAgent.indexOf("WeMedia" , 0, Qt::CaseInsensitive) >= 0))
+        {
+            bTranscodeByDefault = true;
+        }
+    }
+
+    if (!bTranscodeByDefault && pRequest->m_mapParams[ "transcode" ].isEmpty())
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Transcoding not requested."));
+        return 0;
+    }
+    if (pRequest->m_mapParams[ "transcode" ] == "0")
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Transcoding not requested."));
+        return 0;
+    }
+
+    QString sOutFile     = pData->m_sFileName;
+
+    QString sVFormat     = pRequest->m_mapParams[ "videoformat" ];
+    //transcode to flash by default for now
+    if (sVFormat.isEmpty()) sVFormat = "flv";
+
+    //if OutFile is already a transcoded file of the right format, we are good
+    if (sOutFile.endsWith("."+sVFormat))
+    {
+        if (pRequest->m_mapParams[ "transcode" ] == "overwrite")
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                                "Overwriting file %1 that's probably already transcoded to %2.")
+                                .arg(sOutFile).arg(sVFormat));
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                                "File %1 probably already is transcoded to %2.")
+                                .arg(sOutFile).arg(sVFormat));
+            return 0;
+        }
+    }
+
+    QString sTranscodeFile = sOutFile;
+    sTranscodeFile.append(".").append(sVFormat);
+
+    if (QFile::exists( sTranscodeFile ))
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                "Transcoding may have already begun, not restarting...") );
+        pData->m_sFileName    = sTranscodeFile;
+        pRequest->m_sFileName = sTranscodeFile;
+        pRequest->m_nResponseStatus = 200;
+        return 0;
+    }
+
+    bool b_fork = ( (pRequest->m_mapParams[ "fork" ].isEmpty() && bForkByDefault)
+                    || (pRequest->m_mapParams[ "fork" ] == "1"));    //false by default
+    bool b_recording   = true;
+
+    //wait for input file to be ready, if necessary...
+    int nTries = 3;
+    while (!QFile::exists( sOutFile ) && --nTries)
+    {
+        sleep(1);
+    }
+    if (!QFile::exists( sOutFile ))
+    {
+        pRequest->m_eResponseType   = ResponseTypeNone;
+        pRequest->m_nResponseStatus = 404;
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                "File input %1 not found.")
+                .arg(sOutFile));
+        b_recording = false;
+    }
+
+    if (b_recording)
+    {
+        LiveTranscoder *transcoder = NULL;
+
+        if (b_fork)
+        {
+            signal(SIGCHLD, SIG_IGN);
+            pid_t child = fork();
+            if (child < 0)
+            {
+                VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                        "fork failed, spawning thread instead "));
+                b_fork = false;
+            }
+            else if (child == 0) //child process
+            {
+                signal(SIGSEGV, crash_handler);
+                signal(SIGABRT, crash_handler);
+                signal(SIGTERM, crash_handler);
+
+                VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                                    "Child started transcoding %1 to %2.")
+                                    .arg(sOutFile).arg(sTranscodeFile));
+                transcoder = new LiveTranscoder(sOutFile, sTranscodeFile);
+                ConfigureTranscoder(pRequest, transcoder);
+                transcoder->run();
+
+                delete transcoder;
+
+                VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Child ended, exiting..."));
+                exit(0);
+            }
+            else    //parent process
+            {
+                VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                        "fork child pid=%1.")
+                        .arg(child));
+            }
+        }
+        if (!b_fork)
+        {
+            transcoder = new LiveTranscoder(sOutFile, sTranscodeFile);
+            ConfigureTranscoder(pRequest, transcoder);
+
+            transcoder->setAutoDelete(true);    //let QThreadPool call delete
+            QThreadPool::globalInstance()->start(transcoder);
+        }
+
+        // ----------------------------------------------------------------------
+        // check and wait to see if the file exists
+        // ----------------------------------------------------------------------
+        int nTries = 3;
+        do
+        {
+            sleep(1);
+            VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : filename=%1 not found, tries left=%2")
+                                .arg(sTranscodeFile).arg(nTries));
+        }
+        while (!QFile::exists( sTranscodeFile ) && nTries--);
+
+        if (!QFile::exists( sTranscodeFile ))
+        {
+            b_recording = false;
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : output filename=%1 ")
+                                .arg(sTranscodeFile) );
+            if (pData->m_eType == ThreadData::DT_Video)
+            {
+                pData = new ThreadData( ThreadData::DT_Video, sId, sTranscodeFile,
+                                        transcoder, &transcoder_dtor );
+            }
+            else
+            {
+                ThreadData *pOldData  = pData; //automatically deleted by pThread->SetWorkerData()
+                pData = new ThreadData( pOldData->m_sChanId,
+                                        pOldData->m_sStartTime, sTranscodeFile);
+                pData->m_oData        = transcoder;
+                pData->m_pfdestructor = &transcoder_dtor;
+            }
+            pThread->SetWorkerData( pData );
+        }
+    }
+
+    if (b_recording)
+    {
+        pRequest->m_sFileName       = pData->m_sFileName;
+        pRequest->m_eResponseType   = (bIsLive ? ResponseTypeStream : ResponseTypeFile);
+        pRequest->m_nResponseStatus = 200;
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : Success, response=%1.").arg(pRequest->m_sFileName) );
+        return 1;
+    }
+    else
+    {
+        VERBOSE(VB_UPNP, QString("MythXML::TranscodeVideo : "
+                            "Files in=%1 and/or out=%2 not found... "
+                            "recording or transcoding may have failed")
+                            .arg(sOutFile)
+                            .arg(sTranscodeFile));
+        pRequest->m_eResponseType   = ResponseTypeNone;
+        pRequest->m_nResponseStatus = 404;
+    }
+    return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+//static member declaration
+QMutex MythXML::recordingInstanceLock;
+
+void MythXML::GetLiveTV( HttpWorkerThread *pThread, HTTPRequest *pRequest )
+{
+    //default response?
+    pRequest->m_eResponseType   = ResponseTypeHTML;
+    pRequest->m_mapRespHeaders[ "Cache-Control" ] = "no-cache=\"Ext\", "
+                                                    "max-age = 5000";
+    pRequest->m_nResponseStatus = 404;
+
+    //test code
+    if (!pRequest->m_mapParams["testavsettings"].isEmpty())
+    {
+        LiveTranscoder transcoder(pRequest->m_mapParams["testavsettings"]);
+        ConfigureTranscoder(pRequest, &transcoder);
+        bool bAvTest = false;
+        bAvTest = transcoder.TestAVOutputSettings();
+        VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : TestAVOutputSettings=%1")
+                            .arg(bAvTest));
+        if (bAvTest) pRequest->m_nResponseStatus = 200;
+        return;
+    }
+
+    QString sChanid   = pRequest->m_mapParams[ "ChanId" ];
+    QString sSourceid = pRequest->m_mapParams[ "SourceId" ];
+
+    uint sourceId     = ChannelUtil::GetSourceIDForChannel(sChanid.toUInt());
+    if (!sSourceid.isEmpty())
+        sourceId = sSourceid.toUInt();
+
+    VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : %1 on source %2").arg(sChanid).arg(sourceId));
+
+    QMap<int, EncoderLink *>::Iterator enciter = m_pEncoders->begin();
+
+    EncoderLink *encoder = NULL;
+
+    //find a recorder that is recording the source we want
+    for (; enciter != m_pEncoders->end(); ++enciter)
+    {
+        EncoderLink *enc = *enciter;
+
+        VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV attempt on encoder %1").arg( enc->GetCardID() ) );
+
+        uint chanid, srcid = 0;
+        QString callsign, channum, channame, xmltv;
+        chanid = sChanid.toUInt();
+
+        if (enc->GetChannelInfo(chanid, srcid, callsign, channum, channame, xmltv) )
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : channum='%1' channame='%2'"
+                                    " src='%3' card=%4").arg(channum)
+                                .arg(channame).arg(srcid).arg(enc->GetCardID()));
+            if ( srcid == sourceId )
+            {
+                VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : "
+                                        "The encoder we may be looking for...") );
+                encoder = enc;
+                break;
+            }
+            else
+                VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : "
+                                        "not the encoder we are looking for. Moving on") );
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : could not get channel info"
+                                    " for channid=%1 on encoder %2")
+                                .arg(chanid).arg(enc->GetCardID()));
+        }
+    }
+
+    if (encoder)
+    {
+        ProgramInfo *pginfo = encoder->GetRecording();
+        if(pginfo)
+        {
+            if (pginfo->chanid == sChanid)
+            {
+                //make sure we only process one request at a time
+                //since this can take a few seconds and cause threading errors
+                QMutexLocker locker(&MythXML::recordingInstanceLock);
+
+                QString sOutFile = pginfo->GetFileName();    //get filename
+                QString sId      = QString("%1_%2_%3").arg(sChanid).arg(sourceId)
+                                        .arg(sOutFile);
+
+                // ----------------------------------------------------------------------
+                // Check to see if this is another request for the same stream...
+                // ----------------------------------------------------------------------
+
+                ThreadData *pData = (ThreadData *)pThread->GetWorkerData();
+
+                if (pData != NULL)
+                {
+                    VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : "
+                            "pData=%1|%2, expected=%3|%4, pData-file=%5 exp-file=%6.")
+                            .arg(pData->m_eType).arg(pData->m_sVideoID)
+                            .arg(ThreadData::DT_Video).arg(sId)
+                            .arg(pData->m_sFileName).arg(sOutFile));
+                    if ((pData->m_eType == ThreadData::DT_Video)
+                        && (pData->m_sVideoID == sId ))
+                    {
+                        pRequest->m_sFileName = pData->m_sFileName;
+                    }
+                    else
+                        pData = NULL;
+                }
+
+                // ----------------------------------------------------------------------
+                // New request if pData == NULL
+                // ----------------------------------------------------------------------
+
+                if (pData == NULL)
+                {
+                    pRequest->m_sFileName = sOutFile;
+
+                    // ------------------------------------------------------------------
+                    // Store information in WorkerThread Storage for next request (cache)
+                    // ------------------------------------------------------------------
+
+                    pData = new ThreadData( sId, pRequest->m_sFileName );
+
+                    pThread->SetWorkerData( pData );
+                }
+
+                pRequest->m_sFileName       = pData->m_sFileName;
+                pRequest->m_eResponseType   = ResponseTypeStream;
+                pRequest->m_nResponseStatus = 200;
+                VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : Success, response=%1.").arg(pRequest->m_sFileName) );
+
+
+                // ----------------------------------------------------------------------
+                // Transcode file if so requested
+                // ----------------------------------------------------------------------
+
+                TranscodeVideo(pThread, pRequest, sId, false, true, true);
+            }
+            else
+            {
+                VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : "
+                                    "Not the channel we are looking for:"
+                                    "wanted=%1 got=%2.").arg(sChanid).arg(pginfo->chanid) );
+            }
+            delete pginfo;
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::GetLiveTV : Could not get ProgramInfo.") );
+        }
+    }
+} // GetLiveTV
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void MythXML::ChangeChannel( HTTPRequest *pRequest )
+{
+    QString sChanid   = pRequest->m_mapParams[ "ChanId" ];
+    QString sSourceid = pRequest->m_mapParams[ "SourceId" ];
+    uint sourceId      = -1;
+    if (!sSourceid.isEmpty())
+        sourceId = sSourceid.toUInt();
+    
+    VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel : %1 on source %2").arg(sChanid).arg(sSourceid));
+
+    QMap<int, EncoderLink *>::Iterator enciter =
+      m_pEncoders->begin();
+    
+    for (; enciter != m_pEncoders->end(); ++enciter)
+    {
+        EncoderLink *enc = *enciter;
+
+        /*if (enc->GetState() != kState_WatchingLiveTV)
+            continue;    //not the encoder we are looking for*/
+
+        VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel attempt on encoder %1").arg( enc->GetCardID() ) );
+
+        uint chanid, srcid = 0;
+        QString callsign, channum, channame, xmltv;
+        chanid = sChanid.toUInt();
+
+        if (enc->GetChannelInfo(chanid, srcid, callsign, channum, channame, xmltv) )
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel : num='%1' name='%2' src='%3' card=%4")
+                                .arg(channum)
+                                .arg(channame)
+                                .arg(srcid)
+                                .arg(enc->GetCardID()));
+
+            //if (enc->GetRecording() && (!enc->GetRecording()->chanid.isEmpty()) )
+            if ( srcid == sourceId)
+            {
+                VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel : the encoder we are looking for...") );
+                if (enc->IsBusyRecording())
+                    enc->PauseRecorder();
+                enc->SetChannel(channum);
+            }
+            else
+                VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel : not the encoder we are looking for. Moving on") );
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("MythXML::ChangeChannel : could not get channel info for channid=%1 on encoder %2")
+                                .arg(chanid)
+                                .arg(enc->GetCardID()));
+        }
+    }
+} // ChangeChannel
+
 // vim:set shiftwidth=4 tabstop=4 expandtab:
Index: programs/mythbackend/mediaserver.cpp
===================================================================
--- programs/mythbackend/mediaserver.cpp	(revision 4503)
+++ programs/mythbackend/mediaserver.cpp	(working copy)
@@ -4,6 +4,8 @@
 // Purpose - uPnp Media Server main Class
 //
 // Created By  : David Blain                    Created On : Jan. 15, 2007
+// Modified By : Harold Sutherland              Modified On: Oct. 16, 2009
+// Modified By : Kunal Kandekar                 Modified On: Oct. 20, 2009
 // Modified By :                                Modified On:
 //
 //////////////////////////////////////////////////////////////////////////////
@@ -16,6 +18,7 @@
 #include "upnpcdsmusic.h"
 #include "upnpcdsvideo.h"
 #include "upnpmedia.h"
+#include "upnpcdsepg.h"
 
 //////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////
@@ -144,6 +147,8 @@
                                        "http-get:*:audio/wav:*,"
                                        "http-get:*:video/mpeg:*,"
                                        "http-get:*:video/nupplevideo:*,"
+                                       "http-get:*:video/flv:*,"
+                                       "http-get:*:video/mp4:*,"
                                        "http-get:*:video/x-ms-wmv:*";
 
             VERBOSE(VB_UPNP, "MediaServer::Registering MSRR Service." );
@@ -157,6 +162,16 @@
                                         m_sSharePath, sSourceProtocols );
             m_pHttpServer->RegisterExtension( m_pUPnpCMGR );
 
+            VERBOSE(VB_UPNP, "MediaServer::Registering SRS Service." );
+
+            m_pUPnpSRS = new UPnpSRS( RootDevice(), m_sSharePath );
+            m_pHttpServer->RegisterExtension( m_pUPnpSRS );
+
+            VERBOSE(VB_UPNP, "MediaServer::Registering AVT Service." );
+
+            m_pUPnpAVT = new UPnpAVT( RootDevice(), m_sSharePath );
+            m_pHttpServer->RegisterExtension( m_pUPnpAVT );
+
             VERBOSE(VB_UPNP, "MediaServer::Registering CDS Service." );
 
             m_pUPnpCDS = new UPnpCDS ( RootDevice(), m_sSharePath );
@@ -170,6 +185,12 @@
 
             RegisterExtension(new UPnpCDSTv());
 
+            // This should actually be handled by the CDS when an object id of "epg"
+            // is provided.
+
+            VERBOSE(VB_UPNP, "MediaServer::Registering UPnpCDSEpg Extension");
+            RegisterExtension(new UPnpCDSEpg());
+
             VERBOSE(VB_UPNP, "MediaServer::Registering UPnpCDSMusic Extension");
 
             RegisterExtension(new UPnpCDSMusic());
Index: programs/mythbackend/upnpcdsepg.cpp
===================================================================
--- programs/mythbackend/upnpcdsepg.cpp	(revision 0)
+++ programs/mythbackend/upnpcdsepg.cpp	(revision 0)
@@ -0,0 +1,400 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: upnpcdsepg.cpp
+//                                                                            
+// Purpose - uPnp Content Directory Extension for Recorded EPG  
+//                                                                            
+// Created By  : Harold Sutherland              Created On : Jun. 23, 2009
+// Modified By : Kunal Kandekar                 Modified On: Nov. 11, 2009
+// Modified By : Harold Sutherland              Modified On: Feb. 02, 2010
+// Modified By :                                Modified On:                  
+//                                                                            
+//////////////////////////////////////////////////////////////////////////////
+
+// POSIX headers
+#include <limits.h>
+
+// MythEPG headers
+#include "upnpcdsepg.h"
+#include "httprequest.h"
+#include "storagegroup.h"
+#include "util.h"
+#include "mythcontext.h"
+
+
+/*
+   Programs                                Epg
+    - All Programs                         Epg/All
+*/
+
+
+UPnpCDSRootInfo UPnpCDSEpg::g_RootNodes[] = 
+{
+    {   "All Programs", 
+        "*",
+        "SELECT 0 as key, "
+          "CONCAT( title, ': ', subtitle) as name, "
+          "1 as children "
+            "FROM program "
+            "%1 "
+            "ORDER BY starttime DESC",
+        "" },
+};
+
+int UPnpCDSEpg::g_nRootCount = sizeof( g_RootNodes ) / sizeof( UPnpCDSRootInfo );
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpCDSRootInfo *UPnpCDSEpg::GetRootInfo( int nIdx )
+{ 
+    if ((nIdx >=0 ) && ( nIdx < g_nRootCount ))
+        return &(g_RootNodes[ nIdx ]); 
+
+    return NULL;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpCDSEpg::GetRootCount()
+{
+    return g_nRootCount;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QString UPnpCDSEpg::GetTableName( QString /* sColumn */)
+{
+    return "program";
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QString UPnpCDSEpg::GetItemListSQL( QString /* sColumn */ )
+{
+  QString query =         
+    "SELECT DISTINCT program.chanid, "
+                   "program.starttime, "
+            "program.endtime, "
+                    "program.title, "
+            "program.subtitle, "
+            "program.description, "
+                    "program.category, "
+            "channel.channum, "
+            "channel.callsign, "
+                    "channel.name, "
+            "program.previouslyshown, "
+            "channel.commmethod, "
+                    "channel.outputfilters, "
+            "program.seriesid, "
+            "program.programid, "
+                    "program.airdate, "
+            "program.stars, "
+            "program.originalairdate, "
+                    "program.category_type, "
+            "channelgroupnames.name, "
+            "callsignnetworkmap.network, "
+            "channel.sourceid "
+        "FROM program "
+        "LEFT JOIN channel ON program.chanid = channel.chanid "
+    "LEFT JOIN channelgroup ON program.chanid = channelgroup.chanid "
+        "LEFT JOIN channelgroupnames ON channelgroup.grpid = channelgroupnames.grpid "
+    "LEFT JOIN callsignnetworkmap ON channel.callsign = callsignnetworkmap.callsign "
+    "WHERE program.starttime >= TIMESTAMPADD(MINUTE, -59, NOW()) AND "
+              "program.endtime <= TIMESTAMPADD(HOUR, 2, NOW()) "
+    "GROUP BY program.starttime, channel.channum, channel.callsign, program.title "
+        "ORDER BY program.starttime";
+
+  return query;
+ 
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpCDSEpg::BuildItemQuery( MSqlQuery &query, const QStringMap &mapParams )
+{
+    int     nChanId    = mapParams[ "ChanId"    ].toInt();
+    QString sStartTime = mapParams[ "StartTime" ];
+
+    QString sSQL = QString( "%1 WHERE chanid=:CHANID and starttime=:STARTTIME " )
+                      .arg( GetItemListSQL() );
+
+    query.prepare( sSQL );
+
+    query.bindValue(":CHANID"   , (int)nChanId    );
+    query.bindValue(":STARTTIME", sStartTime );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+bool UPnpCDSEpg::IsBrowseRequestForUs( UPnpCDSRequest *pRequest )
+{
+    // ----------------------------------------------------------------------
+    // See if we need to modify the request for compatibility
+    // ----------------------------------------------------------------------
+
+    // WMP11 compatibility code
+
+    if (( pRequest->m_sObjectId                  == "13") && 
+        ( gContext->GetSetting("UPnP/WMPSource") !=  "1") )
+    {
+        pRequest->m_sObjectId = "Epg/0";
+
+        VERBOSE( VB_UPNP, "UPnpCDSEpg::IsBrowseRequestForUs - Yes, ObjectId == 13" );
+        return true;
+    }
+
+    //WeMedia compatibility code - we want a flat list of EPG items for objectId = "epg"
+    if ( pRequest->m_sObjectId == "epg" )
+    {
+        pRequest->m_sObjectId = "Epg/WeMedia/0";
+
+        VERBOSE( VB_UPNP, "UPnpCDSEpg::IsBrowseRequestForUs - Yes, ObjectId == epg" );
+        return true;
+    }
+    //End WeMedia compatibility code
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::IsBrowseRequestForUs - Not sure... Calling base class." );
+
+    return UPnpCDSExtension::IsBrowseRequestForUs( pRequest );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+bool UPnpCDSEpg::IsSearchRequestForUs( UPnpCDSRequest *pRequest )
+{
+    // ----------------------------------------------------------------------
+    // See if we need to modify the request for compatibility
+    // ----------------------------------------------------------------------
+
+    // ----------------------------------------------------------------------
+    // XBox 360 compatibility code
+    // ----------------------------------------------------------------------
+
+    if ((pRequest->m_sObjectId == "") && (pRequest->m_sContainerID != ""))
+        pRequest->m_sObjectId = pRequest->m_sContainerID;
+
+    // ----------------------------------------------------------------------
+
+    bool bOurs = UPnpCDSExtension::IsSearchRequestForUs( pRequest );
+
+    // ----------------------------------------------------------------------
+    // WMP11 compatibility code
+    // ----------------------------------------------------------------------
+
+    if ( bOurs && ( pRequest->m_sObjectId == "0" ))
+    {
+        if ( gContext->GetSetting("UPnP/WMPSource") != "1")
+        {
+            pRequest->m_sObjectId = "Epg/0";
+            pRequest->m_sParentId = "8";        // -=>TODO: Not sure why this was added
+        }
+        else
+            bOurs = false;
+    }
+
+    return bOurs;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpCDSEpg::AddItem(const QString           &sObjectId,
+                         UPnpCDSExtensionResults *pResults,
+                         bool                     bAddRef,
+                         MSqlQuery               &query )
+{
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::AddItem." );
+
+    int            nChanid      = query.value( 0).toInt();
+    QDateTime      dtStartTime  = query.value( 1).toDateTime();
+    QDateTime      dtEndTime    = query.value( 2).toDateTime();
+    QString        sTitle       = query.value( 3).toString();
+    QString        sSubtitle    = query.value( 4).toString();
+    QString        sDescription = query.value( 5).toString();
+    QString        sCategory    = query.value( 6).toString();
+    QString        sChanNum     = query.value( 7).toString();
+    QString        sCallSign    = query.value( 8).toString();
+    QString        sChanName    = query.value( 9).toString();
+    QString        sPrevShown   = query.value(10).toString();
+    QString        sCommMethod  = query.value(11).toString();
+    QString        sOutFilters  = query.value(12).toString();
+    int            nSeriesID    = query.value(13).toInt();
+    int            nProgramID   = query.value(14).toInt();
+    QDateTime      dtAirDate    = query.value(15).toDateTime();
+    int            nStars       = query.value(16).toInt();
+    QDateTime      dtOrigDate   = query.value(17).toDateTime();
+    QString        sCatType     = query.value(18).toString();
+    QString        sChanGroup   = query.value(19).toString();
+    QString        sNetwork     = query.value(20).toString();
+    int            nSourceID    = query.value(21).toInt();
+
+
+    // ----------------------------------------------------------------------
+    // Cache Host ip Address & Port
+    // ----------------------------------------------------------------------
+
+    QString sServerIp = gContext->GetSetting("BackendServerIp"   );
+    QString sPort     = gContext->GetSetting("BackendStatusPort" );
+
+    // ----------------------------------------------------------------------
+    // Build Support Strings
+    // ----------------------------------------------------------------------
+
+    //    QString sName = "< " + sChanNum + " > " + sTitle;
+    QString sName = sTitle;
+    if ( !sSubtitle.isEmpty() )
+      sName += ": " + sSubtitle;
+    else if ( !sDescription.isEmpty() )
+      sName += ": " + sDescription;
+
+    QString sURIBase   = QString( "http://%1:%2/Myth/" )
+                            .arg( sServerIp ) 
+                            .arg( sPort );
+
+    QString sURIParams = QString( "?ChanId=%1" )
+                            .arg( sChanNum );
+
+    QString sId        = QString( "%1/item%2")
+                            .arg( sObjectId )
+                            .arg( sURIParams );
+
+    //WeMedia compatibility code - we want a more expressive and unique ID
+    QString sObjectIdEpg = sObjectId;    //this is passed to CreateEpgItem below
+    if (sObjectId == "Epg/WeMedia/0")
+    {
+        sURIParams     = QString( "?ChanId=%1" )
+                            .arg( nChanid );
+        sObjectIdEpg   = "epg";
+        //sId          = QString( "epg/key=%1" ).arg( nProgramID );
+        //If the above is not unique enough, use the code below
+        sId            = QString( "epg/%1-%2-%3" )
+                            .arg( nChanid )
+                            .arg( dtStartTime.toTime_t() )
+                            .arg( dtEndTime.toTime_t() );
+    }
+    //WeMedia compatibility code END
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Creating Epg Item." );
+    CDSObject *pItem   = CDSObject::CreateEpgItem( sId, 
+                                                   sName, 
+                                                   sObjectIdEpg );
+    pItem->m_bRestricted  = false;
+    pItem->m_bSearchable  = true;
+    pItem->m_sWriteStatus = "WRITABLE";
+
+    if ( bAddRef )
+    {
+        QString sRefId = QString( "%1/0/item%2")
+                            .arg( m_sExtensionId )
+                            .arg( sURIParams     );
+
+        pItem->SetPropValue( "refID", sRefId );
+    }
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Setting Properties." );
+    QString sDateTimeRange = QString( "%1/%2" )
+      .arg( dtStartTime.toString(Qt::ISODate))
+                            .arg( dtEndTime.toString(Qt::ISODate));
+
+    pItem->SetPropValue( "channelGroupName"            , sChanGroup );
+    pItem->SetPropValue( "channelName"                 , sChanName );
+    pItem->SetPropValue( "channelNr"                   , sChanNum );
+    pItem->SetPropValue( "seriesTitle"                 , sTitle );
+    pItem->SetPropValue( "programTitle"                , sSubtitle );
+    pItem->SetPropValue( "channelName"                 , sChanName );
+    pItem->SetPropValue( "programID"                   , QString::number( nProgramID ) );
+    pItem->SetPropValue( "seriesID"                    , QString::number( nSeriesID ) );
+    pItem->SetPropValue( "channelID"                   , QString::number( nChanid ) );
+    pItem->SetPropValue( "episodeType"                 , sCategory );
+    pItem->SetPropValue( "callSign"                    , sCallSign );
+    pItem->SetPropValue( "networkAffiliation"          , sNetwork );
+    pItem->SetPropValue( "description"                 , sDescription );
+
+    pItem->SetPropValue( "scheduledStartTime"          , dtStartTime.toString(Qt::ISODate) );
+    pItem->SetPropValue( "scheduledEndTime"            , dtEndTime.toString(Qt::ISODate) );
+    pItem->SetPropValue( "dateTimeRange"               , sDateTimeRange );
+
+
+    // ----------------------------------------------------------------------
+    // Needed for Microsoft Media Player Compatibility 
+    // (Won't display correct Title without them)
+    // ----------------------------------------------------------------------
+
+    //pItem->SetPropValue( "creator"       , "[Unknown Author]" );
+    //pItem->SetPropValue( "artist"        , "[Unknown Author]" );
+    //pItem->SetPropValue( "album"         , "[Unknown Series]" );
+    //pItem->SetPropValue( "actor"         , "[Unknown Author]" );
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding Item." );
+    pResults->Add( pItem );
+
+    // ----------------------------------------------------------------------
+    // Add Video Resource Element based on File contents/extension (HTTP)
+    // ----------------------------------------------------------------------
+
+    // DLNA string below is temp fix for ps3 seeking.
+    QString sProtocol = QString( "http-get:*:video/mpeg:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01500000000000000000000000000000" );
+    QString sURI      = QString( "%1GetLiveTV%2").arg( sURIBase   )
+                                                 .arg( sURIParams );
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding Protocol Info." );
+    Resource *pRes = pItem->AddResource( sProtocol, sURI );
+
+    uint uiStart = dtStartTime.toTime_t();
+    uint uiEnd   = dtEndTime.toTime_t();
+    uint uiDur   = uiEnd - uiStart;
+
+    QString sDur;
+
+    sDur.sprintf("%02d:%02d:%02d",
+                  (uiDur / 3600) % 24,
+                  (uiDur / 60) % 60,
+                   uiDur % 60);
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding duration and size attributes." );
+
+    pRes->AddAttribute( "duration"  , sDur      );
+    pRes->AddAttribute( "size"      , QString::number( 0 ) );
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding allowedUse attribute." );
+
+    QString sAllowedUse   = QString("PLAY:-1,STOP:-1,PAUSE:-1,SEEK:-1");
+    pRes->AddAttribute( "allowedUse"  , sAllowedUse      );
+
+    // res tag for RECORD
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding Protocol Info to Record." );
+    QString sURIParamsRec = QString( "?ChanId=%1&amp;StartTime=%2&amp;SourceId=%3&amp;ItemId=%4" )
+                                .arg( nChanid )
+                                .arg( dtStartTime.toTime_t() )
+                                .arg( nSourceID )
+                                .arg( sId );
+    QString sURIRec       = QString( "%1RecordItem%2").arg( sURIBase   )
+                                                      .arg( sURIParamsRec );
+    Resource *pResRec     = pItem->AddResource( sProtocol, sURIRec );
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding duration and size attributes to Record." );
+
+    pResRec->AddAttribute( "duration"  , sDur      );
+    pResRec->AddAttribute( "size"      , QString::number( 0 ) );
+
+    VERBOSE( VB_UPNP, "UPnpCDSEpg::Adding allowedUse attribute to Record." );
+
+    QString sAllowedUseRec = QString("RECORD:-1");
+    pResRec->AddAttribute( "allowedUse"  , sAllowedUseRec      );
+}
+
Index: programs/mythbackend/transcoder.h
===================================================================
--- programs/mythbackend/transcoder.h	(revision 0)
+++ programs/mythbackend/transcoder.h	(revision 0)
@@ -0,0 +1,114 @@
+// -*- Mode: c++ -*-
+
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: transcoder.cpp
+// Created     : December 19, 2009
+//
+// Author      : Kunal Kandekar
+//
+// Purpose     : Live TV transcoding
+//
+// Copyright (c) 2010
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+/*
+ *  Adapted from code by Rene Buehlmann for ticket #6888
+ *  http://svn.mythtv.org/trac/ticket/6888
+ */
+
+#ifndef TRANSCODER_H
+#define TRANSCODER_H
+
+#include <stdlib.h>
+
+// Qt includes
+#include <QRunnable>
+#include <QThread>
+#include <QFile>
+
+#include "mythverbose.h"
+
+#define TRANSCODE_OFBR_NMAX_TRIES 15
+
+
+// AVLib/FFMPEG includes
+extern "C"
+{
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavformat/mpegts.h"
+#include "libswscale/swscale.h"
+#include "libavutil/fifo.h"
+}
+
+class LiveTranscoder: public QRunnable
+{
+public:
+    LiveTranscoder(QString &filename);
+    LiveTranscoder(QString &filename, QString &outfilename);
+    ~LiveTranscoder();
+    void setParam(const QString &name, const QString &value);
+    void setParam(const QString &name, int value);
+
+    virtual void run();
+
+    bool TestAVOutputSettings();
+
+    bool IsActive() const;
+    void Stop();
+    void SetDefaults();
+
+private:
+    void RegisterCustomProtocols();
+    void RegisterAVCodecs();
+    AVCodec *FindVideoEncoder();
+
+    bool m_bStopRequested;
+    int  m_nDeleteDelaySecs;
+    QString m_sFileName;
+    QString m_sOutputFileName;
+    QString name;
+    QString m_sVideoCodec;
+    QString m_sVideoFormat;
+    QString m_sAudioCodec;
+    QString m_sAudioFormat;
+    CodecID m_eVideoCodec;
+    CodecID m_eAudioCodec;
+    int video_bit_rate;
+    int audio_bit_rate;
+    int width;
+    int height;
+    bool b_transcode_audio;
+    bool b_transcode_video;
+    int audio_sample_rate;
+    int video_frame_rate_num;
+    int video_frame_rate_den;
+
+    bool b_drop_audio;
+    bool b_drop_video;
+    bool b_deinterlace;
+
+    bool b_have_mp3_enc;
+    bool b_flash_video;
+
+    unsigned int  m_nId;
+
+    static unsigned int idcount;
+    static QMutex av_mutex;
+};
+
+#endif
Index: programs/mythbackend/upnpsrs.cpp
===================================================================
--- programs/mythbackend/upnpsrs.cpp	(revision 0)
+++ programs/mythbackend/upnpsrs.cpp	(revision 0)
@@ -0,0 +1,3734 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: UPnpSRS.cpp
+// Created     : Jul 13 2009
+// Modified    : Mar 01 2010
+//
+// Authors     : Kunal Kandekar, Harold Sutherland
+//
+// Purpose     : UPnP Scheduled Recording Service 
+//                                                                            
+// Copyright (c) 
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#include "upnpsrs.h"
+#include "upnpcdsepg.h"
+#include "upnputil.h"
+#include "mythcontext.h"
+#include "mythdb.h"
+#include "channelutil.h"
+#include "cardutil.h"
+#include "programinfo.h"
+#include "recordingrule.h"
+
+#include <QTextStream>
+#include <QTextCodec>
+#include <QFileInfo>
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpSRS::UPnpSRS (       UPnpDevice *pDevice, 
+           const QString    &sSharePath )
+         : Eventing( "UPnpSRS", "SRS_Event", sSharePath )
+{
+    AddVariable( new StateVariable< QString >( "SortCapabilities"       , false ) );
+    AddVariable( new StateVariable< QString >( "SortLevelCapability"    , false ) );
+    AddVariable( new StateVariable< QString >( "StateUpdateID"          , false ) );
+    AddVariable( new StateVariable< QString >( "A_ARG_TYPE_PropertyList", false ) );
+    AddVariable( new StateVariable< QString >( "LastChange"             , true ) );
+
+    SetValue< QString >( "SortCapabilities"   , "srs:*" );
+    SetValue< QString >( "SortLevelCapability", QString::number(10) );
+
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    SetValue< QString >( "StateUpdateID"      , QString::number(UPnpSRS::nStateUpdateID) );
+
+    QString sUPnpDescPath = UPnp::g_pConfig->GetValue( "UPnP/DescXmlPath",
+                                                       sSharePath );
+    m_sSharePath           = sSharePath;
+    m_sServiceDescFileName = sUPnpDescPath + "SRS_scpd.xml";
+    m_sControlUrl          = "/SRS_Control";
+
+    // Add our Service Definition to the device.
+
+    RegisterService( pDevice );
+
+    // Spawn singleton UPnpSRMonitor
+    UPnpSRMonitor::spawn();
+
+    //Add service to UPnpSRMonitor
+    UPnpSRMonitor::RegisterSRS(this);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpSRS::~UPnpSRS()
+{
+    //Remove service to UPnpSRMonitor
+    UPnpSRMonitor::UnregisterSRS(this);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+//static member variable declarations
+QMutex        UPnpSRS::globalSRSLock;
+const QString UPnpSRS::sSRSStartTag = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+                                      "<srs xmlns=\"urn:schemas-upnp-org:av:srs\" "
+                                        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
+                                        "xsi:schemaLocation=\"urn:schemas-upnp-org:av:srs "
+                                        "http://www.upnp.org/schemas/av/srs.xsd\">";
+const QString UPnpSRS::sSRSEndTag = "</srs>";
+const QString UPnpSRS::sSRSSupportedProgramCodeType = "mythtv.org_upnpProgramCode";
+
+QMutex UPnpSRS::StateUpdateIDMutex;
+int    UPnpSRS::nStateUpdateID = 0;
+
+const QString UPnpSRS::sXMLStartTag = "<?xml version=\"1.0\" "
+                                    "encoding=\"UTF-8\"?>";
+const QString UPnpSRS::sStateEventStartTag = "<StateEvent xmlns=\"urn:schemas-upnp-org:av:srs-event\" "
+                                        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
+                                        "xsi:schemaLocation=\"urn:schemas-upnp-org:av:srs-event "
+                                        "http://www.upnp.org/schemas/av/srs-event.xsd\">";
+const QString UPnpSRS::sStateEventEndTag = "</StateEvent>";
+
+const char *UPnpSRS::sStateEventRecordScheduleCreated  = "<RecordScheduleCreated "
+                    "updateID=\"%1\" objectID=\"%2\"></RecordScheduleCreated>";
+const char *UPnpSRS::sStateEventRecordScheduleDeleted  = "<RecordScheduleDeleted "
+                    "updateID=\"%1\" objectID=\"%2\"></RecordScheduleDeleted>";
+const char *UPnpSRS::sStateEventRecordScheduleModified = "<RecordScheduleModified "
+                    "updateID=\"%1\" objectID=\"%2\"></RecordScheduleModified>";
+const char *UPnpSRS::sStateEventRecordTaskCreated = "<RecordTaskCreated "
+                    "updateID=\"%1\" objectID=\"%2-%3\"></RecordTaskCreated>";
+const char *UPnpSRS::sStateEventRecordTaskDeleted = "<RecordTaskDeleted "
+                    "updateID=\"%1\" objectID=\"%2-%3\"></RecordTaskDeleted>";
+const char *UPnpSRS::sStateEventRecordTaskModified = "<RecordScheduleModified "
+                    "updateID=\"%1\" objectID=\"%2-%3\"></RecordScheduleModified>";
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpSRSMethod UPnpSRS::GetMethod( const QString &sURI )
+{                        
+    if (sURI == "GetServDesc"                ) return SRSM_GetServiceDescription      ;
+    if (sURI == "GetSortCapabilities"        ) return SRSM_GetSortCapabilities        ;
+    if (sURI == "GetPropertyList"            ) return SRSM_GetPropertyList            ;
+    if (sURI == "GetAllowedValues"           ) return SRSM_GetAllowedValues           ;
+    if (sURI == "GetStateUpdateID"           ) return SRSM_GetStateUpdateID           ;
+    if (sURI == "BrowseRecordSchedules"      ) return SRSM_BrowseRecordSchedules      ;
+    if (sURI == "CreateRecordSchedule"       ) return SRSM_CreateRecordSchedule       ;
+    if (sURI == "DeleteRecordSchedule"       ) return SRSM_DeleteRecordSchedule       ;
+    if (sURI == "GetRecordSchedule"          ) return SRSM_GetRecordSchedule          ;
+    if (sURI == "EnableRecordSchedule"       ) return SRSM_EnableRecordSchedule       ;
+    if (sURI == "DisableRecordSchedule"      ) return SRSM_DisableRecordSchedule      ;
+    if (sURI == "BrowseRecordTasks"          ) return SRSM_BrowseRecordTasks          ;
+    if (sURI == "GetRecordScheduleConflicts" ) return SRSM_GetRecordScheduleConflicts ;
+    if (sURI == "GetRecordTask"              ) return SRSM_GetRecordTask              ;
+    if (sURI == "GetRecordTaskConflicts"     ) return SRSM_GetRecordTaskConflicts     ;
+
+    /*
+    if (sURI == "DeleteRecordTask"           ) return SRSM_DeleteRecordTask           ;
+    if (sURI == "EnableRecordTask"           ) return SRSM_EnableRecordTask           ;
+    if (sURI == "DisableRecordTask"          ) return SRSM_DisableRecordTask          ;
+    if (sURI == "ResetRecordTask"            ) return SRSM_ResetRecordTask            ;
+    */
+
+    return SRSM_Unknown;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+bool UPnpSRS::ProcessRequest( HttpWorkerThread *pThread, HTTPRequest *pRequest )
+{
+    if (pRequest)
+    {
+        if (Eventing::ProcessRequest( pThread, pRequest ))
+            return true;
+
+        if ( pRequest->m_sBaseUrl != m_sControlUrl )
+        {
+//            VERBOSE( VB_UPNP, QString("UPnpSRS::ProcessRequest - BaseUrl (%1) not ours...").arg(pRequest->m_sBaseUrl ));
+            return false;
+        }
+
+        VERBOSE( VB_UPNP, QString("UPnpSRS::ProcessRequest - Method (%1)").arg(pRequest->m_sMethod ));
+
+        switch( GetMethod( pRequest->m_sMethod ) )
+        {
+            case SRSM_GetServiceDescription      : pRequest->FormatFileResponse    ( m_sServiceDescFileName ); break;
+
+            case SRSM_GetSortCapabilities        : HandleGetSortCapabilities       ( pRequest ); break;
+            case SRSM_GetPropertyList            : HandleGetPropertyList           ( pRequest ); break;
+            case SRSM_GetAllowedValues           : HandleGetAllowedValues          ( pRequest ); break;
+            case SRSM_GetStateUpdateID           : HandleGetStateUpdateID          ( pRequest ); break;
+            case SRSM_BrowseRecordSchedules      : HandleBrowseRecordSchedules     ( pRequest ); break;
+            case SRSM_BrowseRecordTasks          : HandleBrowseRecordTasks         ( pRequest ); break;
+            case SRSM_CreateRecordSchedule       : HandleCreateRecordSchedule      ( pRequest ); break;
+            case SRSM_DeleteRecordSchedule       : HandleDeleteRecordSchedule      ( pRequest ); break;
+            case SRSM_GetRecordSchedule          : HandleGetRecordSchedule         ( pRequest ); break;
+            case SRSM_EnableRecordSchedule       : HandleEnableRecordSchedule      ( pRequest ); break;
+            case SRSM_DisableRecordSchedule      : HandleDisableRecordSchedule     ( pRequest ); break;
+            case SRSM_DeleteRecordTask           : HandleDeleteRecordTask          ( pRequest ); break;
+            case SRSM_GetRecordTask              : HandleGetRecordTask             ( pRequest ); break;
+            case SRSM_EnableRecordTask           : HandleEnableRecordTask          ( pRequest ); break;
+            case SRSM_DisableRecordTask          : HandleDisableRecordTask         ( pRequest ); break;
+            case SRSM_ResetRecordTask            : HandleResetRecordTask           ( pRequest ); break;
+            case SRSM_GetRecordScheduleConflicts : HandleGetRecordScheduleConflicts( pRequest ); break;
+            case SRSM_GetRecordTaskConflicts     : HandleGetRecordTaskConflicts    ( pRequest ); break;
+            default:
+                UPnp::FormatErrorResponse( pRequest, UPnPResult_InvalidAction,
+                        QString("Invalid Action."));
+                break;
+        }       
+        return true;
+    }
+
+    return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetSortCapabilities( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetSortCapabilities"));
+    NameValues list;
+    list.push_back( NameValue("SortCaps", GetValue<QString>("SortCapabilities")) );
+    list.push_back( NameValue("SortLevelCap", GetValue<QString>("SortLevelCapability")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetPropertyList( HTTPRequest *pRequest )
+{
+    QString sDataTypeID  = pRequest->m_mapParams[ "DataTypeID" ];
+    if (sDataTypeID.isEmpty()
+        || ((sDataTypeID != "A_ARG_TYPE_RecordSchedule")
+         && (sDataTypeID != "A_ARG_TYPE_RecordTask")
+         && (sDataTypeID != "A_ARG_TYPE_RecordScheduleParts")))
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidDataTypeID,
+                        QString("Invalid DataTypeID.") );
+        return;
+    }
+
+    SRSObject *srsObject = NULL;
+    if (sDataTypeID == "A_ARG_TYPE_RecordSchedule")
+        srsObject = SRSObject::CreateRecordScheduleDirectManual("", "", NULL);
+    else if (sDataTypeID == "A_ARG_TYPE_RecordTask")
+        srsObject = SRSObject::CreateRecordTask("", "", NULL);
+    else if (sDataTypeID == "A_ARG_TYPE_RecordScheduleParts")
+        srsObject = SRSObject::CreateRecordScheduleParts("", "", NULL);
+
+    QStringList propList = srsObject->GetPropertyList();
+    delete srsObject;
+    QString sPropertylist = propList.join(",");
+
+    NameValues list;
+    list.push_back( NameValue("PropertyList", sPropertylist) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetAllowedValues( HTTPRequest *pRequest )
+{
+    QString sDataTypeID  = pRequest->m_mapParams[ "DataTypeID" ];
+    QString sFilter      = pRequest->m_mapParams[ "Filter"     ];
+    if (sDataTypeID.isEmpty()
+        || ((sDataTypeID != "A_ARG_TYPE_RecordSchedule")
+         && (sDataTypeID != "A_ARG_TYPE_RecordTask")
+         && (sDataTypeID != "A_ARG_TYPE_RecordScheduleParts")))
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidDataTypeID,
+                        QString("Invalid DataTypeID.") );
+        return;
+    }
+    QString sPropertyInfo;
+    if (sDataTypeID == "A_ARG_TYPE_RecordSchedule")
+        sPropertyInfo  =  UPnpSRS::recordScheduleAllowedValuesXML;
+    else if (sDataTypeID == "A_ARG_TYPE_RecordTask")
+        sPropertyInfo  =  UPnpSRS::recordTaskAllowedValuesXML;
+    else if (sDataTypeID == "A_ARG_TYPE_RecordScheduleParts")
+        sPropertyInfo  =  UPnpSRS::recordSchedulePartsAllowedValuesXML;
+
+    //TODO - filter returned XML this based on the Filter argument
+
+    NameValues list;
+    list.push_back( NameValue("PropertyInfo", sPropertyInfo) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetStateUpdateID( HTTPRequest *pRequest )
+{
+    NameValues list;
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    list.push_back( NameValue("Id", GetValue<QString>("StateUpdateID")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+static bool compare(SRSObject *a, SRSObject *b)
+{
+    QStringList::const_iterator sortItr = a->m_lsSortCriteria->begin();
+    for(; sortItr != a->m_lsSortCriteria->end(); sortItr++)
+    {
+        QString sorter = *sortItr;
+        bool bSortAscending = true;
+        if (sorter.startsWith('+'))
+        {
+            sorter = sorter.section('+',0);
+        }
+        else if (sorter.startsWith('-'))
+        {
+            bSortAscending = false;
+            sorter = sorter.section('-',0);
+        }
+
+        QString sSortField = (sorter.indexOf(':') >= 0 ? sorter.section(':',1) : sorter);
+        if (sSortField == "title")
+        {
+            if (a->m_sTitle == b->m_sTitle)    //move on to the next sort criteria
+                continue;
+            if (bSortAscending)
+                return a->m_sTitle < b->m_sTitle;
+            return a->m_sTitle > b->m_sTitle;
+        }
+        if (sSortField == "class")
+        {
+            if (a->m_sClass == b->m_sClass)    //move on to the next sort criteria
+                continue;
+            if (bSortAscending)
+                return a->m_sClass < b->m_sClass;
+            return a->m_sClass > b->m_sClass;
+        }
+        if (sSortField == "id")
+        {
+            if (a->m_sId == b->m_sId)    //move on to the next sort criteria
+                continue;
+            if (bSortAscending)
+                return a->m_sId < b->m_sId;
+            return a->m_sId > b->m_sId;
+        }
+
+        SRSPropertyValueList aVals = a->GetPropValues(sSortField);
+        SRSPropertyValueList bVals = b->GetPropValues(sSortField);
+
+        if ((aVals.size() == bVals.size()) && (aVals.size() == 0))
+            continue;        //move on to the next sort criteria
+        if (bVals.size() == 0)
+            return true;
+        if ((aVals.size() == 0))
+            return false;
+
+        SRSPropertyValue *aprop = aVals.at(0);
+        SRSPropertyValue *bprop = bVals.at(0);
+
+        QString aval  = aprop->GetValue();
+        QString bval  = bprop->GetValue();
+        if ((sSortField == "scheduledStartDateTime")
+            || (sSortField == "taskStartDateTime")
+            || (sSortField == "actualScheduledStartDateTime")
+            || (sSortField == "actualStartDateTime")
+            || (sSortField == "actualScheduledEndDateTime")
+            || (sSortField == "actualEndDateTime"))
+        {
+            QDateTime atime = SRSObject::StringToDateTime( aval );
+            QDateTime btime = SRSObject::StringToDateTime( bval );
+            if (atime == btime)    //move on to the next sort criteria
+                continue;
+            if (bSortAscending)
+                return atime < btime;
+            return atime > btime;
+        }
+        if ((sSortField == "scheduledDuration")
+            || (sSortField == "taskDuration")
+            || (sSortField == "actualScheduledDuration"))
+        {
+            int asec = SRSObject::DurationToSecs( aval );
+            int bsec = SRSObject::DurationToSecs( bval );
+            if (asec == bsec)    //move on to the next sort criteria
+                continue;
+            if (bSortAscending)
+                return asec < bsec;
+            return asec > bsec;
+        }
+        if (aval == bval)        //move on to the next sort criteria
+            continue;
+        if (bSortAscending)
+            return aval < bval;
+        return aval > bval;
+    }
+    return false;    //default return
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+static bool compare_starttime(RecordingInfo *a, RecordingInfo *b)
+{
+    return a->startts < b->startts;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpSRS::GetPendingMatchingRecs(RecordingInfo *pginfo, RecList &sortList)
+{
+    RecList recList;
+    MainServer::GetScheduler()->getAllPending(&recList);
+    for(unsigned int i = 0; i < recList.size(); i++)
+    {
+        RecordingInfo *task = recList.at(i);
+        if ((task->recordid == pginfo->recordid)
+            || (task->IsSameTimeslot(*pginfo)))
+            sortList.push_back(task);
+        else
+            delete task;
+    }
+    //sort by start date time
+    qStableSort(sortList.begin(), sortList.end(), compare_starttime);
+    return sortList.size();
+}
+
+RecordingInfo *UPnpSRS::GetRecordingFromAllPending(int recordId)
+{
+    RecordingInfo *ret = NULL;
+    RecList recList;
+    MainServer::GetScheduler()->getAllPending(&recList);
+    for(unsigned int index = 0; index < recList.size(); index++)
+    {
+        RecordingInfo *pginfo = recList.at(index);
+
+        if (pginfo->recordid == recordId)
+            ret = pginfo;
+        else
+        delete pginfo;
+    }
+    return ret;
+}
+
+RecordingInfo *UPnpSRS::GetRecordingFromAllScheduled(int recordId)
+{
+    RecordingInfo *ret = NULL;
+    RecList recList;
+    GetAllScheduledPrograms(recList);
+    for(unsigned int index = 0; index < recList.size(); index++)
+    {
+        RecordingInfo *pginfo = recList.at(index);
+
+        if (pginfo->recordid == recordId)
+            ret = pginfo;
+        else
+        delete pginfo;
+    }
+    return ret;
+}
+
+int UPnpSRS::LoadRecordingInfo(RecordingInfo *pginfo)
+{
+    bool tryAgain = true;
+    QString infoSource = "RecordingRule::Load";
+    if (pginfo->recordid > 0)
+    {
+        RecordingRule *record = new RecordingRule();
+        record->m_recordID = pginfo->recordid;
+        if (record->Load())
+        {
+            pginfo->rectype   = record->m_type;
+            pginfo->startts   = QDateTime(record->m_startdate, record->m_starttime);
+            pginfo->endts     = QDateTime(record->m_enddate, record->m_endtime);
+            tryAgain = false;
+        }
+        delete record;
+    }
+    else
+        tryAgain = false;    //it's a new object, won't need to do this
+    if (tryAgain)
+    {
+        RecList sortList;
+        GetAllScheduledPrograms(sortList);
+
+        std::vector<ProgramInfo*> sortVec;
+        std::copy(sortList.begin(), sortList.end(), std::back_inserter(sortVec));
+
+        QString infoSource;
+        if ((pginfo->FillInRecordInfo(sortVec))
+            &&((pginfo->rectype == kSingleRecord)
+                || (pginfo->rectype == kDontRecord)
+                || (pginfo->rectype == kOverrideRecord)
+                || (pginfo->rectype == kTimeslotRecord)
+                || (pginfo->rectype == kWeekslotRecord)))
+        {
+            infoSource.append(",UPnPSRS::GetAllScheduledPrograms + ProgramInfo::FillInRecordInfo");
+            tryAgain = false;
+        }
+        else
+        {
+            //we did not get actual date/time info. Try again
+            for(unsigned int i = 0; i < sortList.size(); i++) {
+                RecordingInfo *task = sortList.at(i);
+                delete task;
+            }
+            sortList.clear();
+            if (GetPendingMatchingRecs(pginfo, sortList))
+            {
+                RecordingInfo *record = sortList.at(0);
+                pginfo->rectype   = record->rectype;
+                pginfo->recstatus = record->recstatus;
+                pginfo->startts   = record->startts;
+                pginfo->endts     = record->endts;
+                infoSource.append(",UPnPSRS::GetPendingMatchingRecs");
+                tryAgain = false;
+            }
+            else
+                infoSource.append(",not found!");
+            //we did not get actual date/time info. Try again
+        }
+        for(unsigned int i = 0; i < sortList.size(); i++) {
+            RecordingInfo *task = sortList.at(i);
+            delete task;
+        }
+        sortList.clear();
+    }
+    if (!tryAgain)
+        MainServer::GetScheduler()->UpdateRecStatus(pginfo);
+    VERBOSE(VB_UPNP, QString("UPnpSRS::LoadRecordingInfo : extra info "
+                        "for title='%1', id=%2 is rectype=%3 recstatus=%4 "
+                        "start=%5  end=%6 [%7]")
+                        .arg(pginfo->title).arg(pginfo->recordid)
+                        .arg(pginfo->rectype).arg(pginfo->recstatus)
+                        .arg(SRSObject::DateTimeToString(pginfo->startts))
+                        .arg(SRSObject::DateTimeToString(pginfo->endts))
+                        .arg(infoSource));
+    return (tryAgain ? 0 : 1);
+}
+
+QString UPnpSRS::GetTaskErrorValues(RecordingInfo *pginfo,
+        const QString& /*taskId*/, const QString &schedError)
+{
+    if (schedError == SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_DISABLED)
+        return SRSObject::SRS_TASKSTATE_ERROR_VAL_DISABLED;
+    else if (schedError == SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_EPG_MISSING)
+        return SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_NO_EPG;
+    else if (schedError == SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_OUTOFMEMORY)
+            return SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_INSUFF_MEM;
+    else if (schedError == SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_RESOURCE)
+            return SRSObject::SRS_TASKSTATE_ERROR_VAL_SYSTEM_GENERAL;
+    return SRSObject::SRS_TASKSTATE_ERROR_VAL_GENERAL;
+}
+
+QStringList UPnpSRS::GetTaskStateValues(RecordingInfo *pginfo,
+        const QString& taskId)
+{
+    if (pginfo->recordid <= 0)
+        LoadRecordingInfo(pginfo);
+
+    QStringList retList;
+    QStringList lsSchedState = GetScheduleStateValue(pginfo);
+    QDateTime now = QDateTime::currentDateTime();
+    //if it is already done, it won't be in pending
+
+    if ((lsSchedState.at(0) == SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED )
+            || (now >= pginfo->endts))
+    {
+        bool zerofile = false;
+        if (pginfo->GetFilesize() == 0)
+        {
+//            QFileInfo file(pginfo->GetPlaybackURL());
+//            if (!file.exists() && !file.size())
+            {
+                retList << SRSObject::SRS_TASKSTATE_VAL_DONE_EMPTY;
+                retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_DONE;
+                retList << "0" << "0" << "1" << "1" << "" << ""
+                        << "100" //<-- should list errors, but we don't know which
+                        << "" << "0" << "0" << "0";
+                zerofile = true;
+            }
+        }
+        if (!zerofile)
+        {
+            //can't tell if it's only a partial recording from this info
+            retList << SRSObject::SRS_TASKSTATE_VAL_DONE_FULL;
+            retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_DONE;
+            retList << "0" << "1" << "0" << "0" << "" << "" << ""
+                    << "1" << "1" << "1" << "1";
+        }
+    }
+    else if (lsSchedState.at(0) == SRSObject::SRS_SCHEDULESTATE_VAL_ERROR )
+    {
+        QString sErrors = GetTaskErrorValues(pginfo, taskId, lsSchedState.at(1));
+        if (now >= pginfo->startts)
+        {
+            retList << SRSObject::SRS_TASKSTATE_VAL_ACTIVE_NOTRECORDING;
+            retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_ACTIVE;
+            retList << "0" << "" << "1" << "0" << sErrors << ""
+                    << sErrors
+                    << "1" << "0" << "" << "0";
+        }
+        else
+        {
+            retList << SRSObject::SRS_TASKSTATE_VAL_IDLE_ATRISK;
+            retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_IDLE;
+            retList << "0" << "0" << "0" << "0" << "" << sErrors << ""
+                    << "0" << "0" << "0" << "0";
+        }
+    }
+    else
+    {
+        if (now >= pginfo->startts)
+        {
+            if ((pginfo->recstatus == rsRecording) || (pginfo->GetFilesize()))
+            {
+                retList << SRSObject::SRS_TASKSTATE_VAL_ACTIVE_REC_FROMSTART_OK;
+                retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_ACTIVE;
+                retList << "1" << "1" << "0" << "0" << "" << "" << ""
+                        << "1" << "0" << "1" << "0";
+            }
+            else
+            {
+                QString sErrors = GetTaskErrorValues(pginfo, taskId, lsSchedState.at(1));
+                retList << SRSObject::SRS_TASKSTATE_VAL_ACTIVE_NOTRECORDING;
+                retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_ACTIVE;
+                retList << "0" << "" << "1" << "0" << sErrors << ""
+                        << sErrors
+                        << "1" << "0" << "" << "0";
+            }
+        }
+        else
+        {
+            retList << SRSObject::SRS_TASKSTATE_VAL_IDLE_READY;
+            retList << SRSObject::SRS_TASKSTATE_PHASE_VAL_IDLE;
+            retList << "0" << "0" << "0" << "0" << "" << "" << ""
+                    << "0" << "0" << "0" << "0";
+            if (pginfo->GetRecordingRule()->m_isInactive)
+                retList.replace(7, "101");   //task is disabled
+        }
+    }
+
+    while (retList.size() < 14)
+        retList << "";    //to avoid index out-of-bounds errors due to unhandled cases
+    return retList;
+}
+
+QStringList UPnpSRS::GetScheduleStateValue(RecordingInfo *pginfo)
+{
+    QStringList retList;
+    //if it is already done, it won't be in pending
+    if (pginfo->recordid > 0)
+    {
+        RecordingInfo *record = GetRecordingFromAllPending(pginfo->recordid);
+        if (!record)
+        {
+            retList << SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED
+                    << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_NONE;
+            return retList;
+        }
+        delete record;
+    }
+    switch(pginfo->recstatus)
+    {
+    case rsWillRecord:
+    case rsRecording:
+    case rsUnknown:
+    case rsEarlierShowing:
+    case rsOtherShowing:
+    case rsLaterShowing:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_OPERATIONAL
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_NONE;
+        break;
+    case rsPreviousRecording:
+    case rsTooManyRecordings:
+    case rsRecorded:
+    case rsRepeat:
+    case rsCurrentRecording:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_NONE;
+        break;
+    case rsNotListed:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_ERROR
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_EPG_MISSING;
+        break;
+    case rsCancelled:
+    case rsDontRecord:
+    case rsNeverRecord:
+    case rsInactive:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_ERROR
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_DISABLED;
+        break;
+    case rsTunerBusy:
+    case rsLowDiskSpace:
+    case rsOffLine:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_ERROR
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_RESOURCE;
+        break;
+    case rsMissed:
+    case rsAborted:
+    case rsConflict:
+    case rsFailed:
+    default:
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_ERROR
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_GENERAL;
+        break;
+    }
+    if (pginfo->GetRecordingRule()->m_isInactive)    //recstatus == rsInactive doesn't work
+    {
+        retList.clear();
+        retList << SRSObject::SRS_SCHEDULESTATE_VAL_ERROR
+                << SRSObject::SRS_SCHEDULESTATE_CURRENTERROR_VAL_DISABLED;
+    }
+    return retList;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+SRSObject *UPnpSRS::ToRecordScheduleSRSObject( RecordingInfo *pginfo, SRSObject *input )
+{
+    SRSObject *result = NULL;
+
+    QString sClass = (input ? input->m_sClass : "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL");
+
+    if (sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG")
+    {
+        result = SRSObject::CreateRecordScheduleDirectCdsEPG(
+                        QString::number(pginfo->recordid), pginfo->title, NULL);
+        QString cdsId = QString("epg/%1-%2-%3").arg(pginfo->chanid)
+                            .arg(pginfo->startts.toTime_t())
+                            .arg(pginfo->endts.toTime_t());
+        SRSPropertyValue *pProp = result->SetPropValue( "scheduledCDSObjectID",
+                                                        "srs", cdsId);
+    }
+    else if (sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEEPG")
+    {
+        result = SRSObject::CreateRecordScheduleDirectCdsNonEPG(
+                        QString::number(pginfo->recordid), pginfo->title, NULL);
+        QString cdsId = QString("epg/%1-%2-%3-%4").arg(pginfo->chanid)
+                            .arg(pginfo->startts.toTime_t())
+                            .arg(pginfo->endts.toTime_t())
+                            .arg(pginfo->sourceid);
+        SRSPropertyValue *pProp = result->SetPropValue( "scheduledCDSObjectID",
+                                                        "srs", cdsId);
+    }
+    else if (sClass == "OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE")
+    {
+        result = SRSObject::CreateRecordScheduleDirectProgramCode(
+                        QString::number(pginfo->recordid), pginfo->title, NULL);
+        QString sCode;
+
+        if (input)
+            sCode = input->GetPropFirstValue("scheduledProgramCode")->GetValue();
+        else    //else build URI programcode ourselves
+            sCode =  QString( "epg/%1-%2-%3" ).arg( pginfo->chanid )
+                    .arg( pginfo->startts.toTime_t() )
+                    .arg( pginfo->endts.toTime_t() );
+
+        SRSPropertyValue *pProp = result->SetPropValue( "scheduledProgramCode",
+                                                        "srs", sCode);
+        pProp->SetDependentProperty("type", UPnpSRS::sSRSSupportedProgramCodeType);
+    }
+    else //if (sClass == "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL") or anything else
+    {
+        result = SRSObject::CreateRecordScheduleDirectManual(
+                        QString::number(pginfo->recordid), pginfo->title, NULL);
+        SRSPropertyValue *pProp = result->SetPropValue( "scheduledChannelID",
+                                                        "srs", pginfo->chanid);
+        pProp->SetDependentProperty("type", "ANALOG");
+        pProp->SetDependentProperty("distriNetworkName", pginfo->channame);
+        pProp->SetDependentProperty("distriNetworkID"  , pginfo->chansign);
+    }
+
+    //set all the common properties
+    int priority = pginfo->recpriority;
+    if (priority < 1) priority = 1; //because UPNP priority starts at 1, and Myth starts at 0
+    SRSPropertyValue *pPropPR = result->SetPropValue("priority", "srs",
+                                        QString("L%1").arg(priority));
+    pPropPR->SetDependentProperty("orderedValue", QString("%1").arg(priority));
+
+    result->SetPropValue( "desiredPriority", "srs", "DEFAULT" );
+
+    SRSPropertyValue *pPropRD = result->SetPropValue("recordDestination", "srs",
+                                                     "Hard Disk", true, true);
+    pPropRD->SetDependentProperty( "mediaType"  , "HDD" );
+    pPropRD->SetDependentProperty( "targetURL"  , pginfo->GetPlaybackURL() );
+    pPropRD->SetDependentProperty( "preference" , "1" );
+
+    SRSPropertyValue *pPropDRQ = result->SetPropValue("desiredRecordQuality",
+                                                      "srs", "AUTO", false);
+    pPropDRQ->SetDependentProperty ( "type", "DEFAULT" );
+
+    SRSPropertyValue *pPropSS = result->SetPropValue("scheduleState", "srs",
+                                                     "", true);
+    pPropSS->SetDependentProperty( "currentErrors", "", true );
+    QStringList lsScheduleState = GetScheduleStateValue(pginfo);
+    pPropSS->SetValue(lsScheduleState.at(0));
+    pPropSS->SetDependentProperty( "currentErrors", lsScheduleState.at(1), true );
+
+    result->SetPropValue( "currentRecordTaskCount", "srs", "1", true);
+
+    //optional
+    result->AddProperty( new SRSProperty( "totalCreatedRecordTasks", "srs", "1"));
+    //result->AddProperty( new SRSProperty( "totalCompletedRecordTasks", "srs", "0"));
+    //SRSPropertyValue *pPropCDS = result->SetPropValue( "cdsReference", "srs", "" );
+    //pPropCDS->SetDependentProperty("link", QString::number(pginfo->recordid) );
+
+    LoadRecordingInfo(pginfo);
+
+    if ((sClass == "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL")
+        || (sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG"))
+    {
+        bool found = false;
+        if ((pginfo->rectype == kSingleRecord)
+            || (pginfo->rectype == kDontRecord)
+            || (pginfo->rectype == kOverrideRecord)
+            || (pginfo->rectype == kTimeslotRecord)
+            || (pginfo->rectype == kWeekslotRecord)
+            || (pginfo->rectype == kNotRecording)
+            || (pginfo->startts != pginfo->endts))
+        {
+            result->SetPropValue("scheduledStartDateTime", "srs",
+                                 SRSObject::DateTimeToString(pginfo->startts));
+            int secs = pginfo->startts.secsTo(pginfo->endts);
+            result->SetPropValue("scheduledDuration", "srs",
+                                 SRSObject::SecsToDuration(secs));
+            found = true;
+        }
+        else
+        {
+            //handle other date logic here... get "recordTask" equivalent?
+            //spec says limit multiple scheduledStartDateTime to 2...
+            //so find earliest and last dates for this recordid
+            RecList sortList;
+            GetAllScheduledPrograms(sortList);
+
+            if (sortList.size() == 1)
+            {
+                RecordingInfo *task = sortList.at(0);
+                result->SetPropValue( "scheduledStartDateTime", "srs",
+                            SRSObject::DateTimeToString(task->startts));
+                int secs = task->startts.secsTo(task->endts);
+                result->SetPropValue( "scheduledDuration", "srs",
+                            SRSObject::SecsToDuration(secs));
+                found = true;
+            }
+            else if (sortList.size() > 1)
+            {
+                RecordingInfo *first = sortList.front();
+                RecordingInfo *last  = sortList.back();
+                result->SetPropValue( "scheduledStartDateTime", "srs",
+                            SRSObject::DateTimeToString(first->startts));
+                result->SetPropValue( "scheduledStartDateTime", "srs",
+                            SRSObject::DateTimeToString(last->startts));
+                int secs = first->startts.secsTo(first->endts);
+                result->SetPropValue( "scheduledDuration", "srs",
+                            SRSObject::SecsToDuration(secs));
+                found = true;
+            }
+            for(unsigned int i = 0; i < sortList.size(); i++) {
+                RecordingInfo *task = sortList.at(i);
+                delete task;
+            }
+        }
+        if(!found)
+        {
+            VERBOSE(VB_UPNP, QString("UPnpSRS::ToRecordScheduleSRSObject : found"
+                                " no scheduledStartDateTime for '%1', rectype=%2")
+                                .arg(pginfo->title).arg(pginfo->rectype));
+            //input whatever we have
+            result->SetPropValue( "scheduledStartDateTime", "srs",
+                        SRSObject::DateTimeToString(pginfo->startts));
+            int secs = pginfo->startts.secsTo(pginfo->endts);
+            result->SetPropValue( "scheduledDuration", "srs",
+                        SRSObject::SecsToDuration(secs));
+        }
+    }
+    return result;
+}
+
+RecordingInfo *UPnpSRS::FromRecordScheduleSRSObject(SRSObject *srsObject)
+{
+    if ((srsObject->m_sClass != "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL")
+        && (srsObject->m_sClass != "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG"))
+    {
+        //currently we only support this class
+        VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                            "unsupported class '%1'").arg(srsObject->m_sClass));
+        return NULL;
+    }
+
+    RecordingInfo *progInfo = new RecordingInfo;
+    //STR_FROM_LIST(title)
+    progInfo->title = srsObject->m_sTitle;
+
+    VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "title=%1").arg(progInfo->title));
+
+    //    INT_FROM_LIST(recpriority)
+    int priority = 1;
+    QString desiredPriority = srsObject->GetPropFirstValue( "desiredPriority" )->GetValue();
+    if ((desiredPriority.length() > 1) && (desiredPriority != "DEFAULT"))
+    {
+        //try to assign higher priority
+        priority = desiredPriority.mid(1).toInt() - 1;
+        if (priority <= 0)
+            priority = 1;
+    }
+    progInfo->recpriority  = priority;    //because UPNP priority starts at 1, and Myth starts at 0
+    VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "priority=%1").arg(progInfo->recpriority));
+
+    bool found = false;
+    SRSProperty *pProp = srsObject->GetProperty("recordDestination");
+    VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                        "recordDestination multival=%1").arg(pProp->m_bMultiValued));
+    if (pProp)    // && pProp->m_bMultiValued)
+    {
+        SRSProperty  *mProp    = pProp;
+        SRSPropertyValueList  mPropVals = mProp->GetValues();
+        SRSPropertyValueList::const_iterator itr = mPropVals.begin();
+        for (; itr != mPropVals.end(); ++itr)
+        {
+            SRSPropertyValue *vProp = *itr;
+            if (vProp->GetValue() == "Hard Disk")
+            {
+                SRSDependentProperty *dProp = vProp->GetDependentProperty("mediaType");
+                if (!dProp)
+                    VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "dprop mediaType not found in [%1]").arg(
+                                            QStringList(vProp->m_dependentProperties.keys()).join(",")
+                                            ));
+                if (dProp && (dProp->GetValue() == "HDD"))
+                {
+                    found = true;
+                    break;
+                }
+                //    STR_FROM_LIST(pathname)
+                dProp = vProp->GetDependentProperty( "targetURL");
+                //if (dProp) progInfo->pathname = dProp->GetValue();    //myth gives no control over pathname
+            }
+        }
+        //anything else not supported
+    }
+    else    //assume we have it
+        found = true;
+
+    if (!found)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                            "recordDestination not found, assuming 'Hard Disk/HDD'"));
+    }
+
+
+    pProp = srsObject->GetProperty("desiredRecordQuality");
+    if (pProp)
+    {
+        SRSDependentProperty *dProp = pProp->GetDependentProperty("type");
+        //do nothing with this for now
+    }
+
+    if (srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL")
+    {
+        //    STR_FROM_LIST(chanid)
+        pProp = srsObject->GetProperty("scheduledChannelID");
+        if (pProp)
+        {
+            progInfo->chanid =  pProp->GetFirstValue()->GetValue();
+
+            //get source id for this chanid from DB
+            bool ok = true;
+            uint chanid = progInfo->chanid.toUInt(&ok);
+            progInfo->sourceid = ChannelUtil::GetSourceIDForChannel(chanid);
+
+            if (!ok || (progInfo->sourceid <= 0))
+            {
+                //error!!
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Valid ChannelId/SourceId not found "
+                                    "for chanid %1!").arg(progInfo->chanid));
+                delete progInfo;
+                return NULL;
+            }
+            progInfo->chanstr  = ChannelUtil::GetChanNum(chanid);
+            progInfo->chansign = ChannelUtil::GetCallsign(chanid);
+            progInfo->channame = ChannelUtil::GetServiceName(chanid);
+
+            SRSDependentProperty *dProp = pProp->GetDependentProperty("type");    //do nothing with it
+            progInfo->rectype  = kSingleRecord;    //one-time
+        }
+        else
+        {
+            //error!!
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "Valid scheduledChannelID not found!"));
+            delete progInfo;
+            return NULL;
+        }
+    }
+    else if (srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE")
+    {
+
+        pProp = srsObject->GetProperty("scheduledProgramCode");
+        if (pProp)
+        {
+            SRSDependentProperty *dProp = pProp->GetDependentProperty("type");
+            if (dProp->GetValue() != UPnpSRS::sSRSSupportedProgramCodeType)
+            {
+                //error!!
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Unsupported scheduledProgramCode@type %1,"
+                                    " expected is %2.")
+                                    .arg(dProp->GetValue())
+                                    .arg(UPnpSRS::sSRSSupportedProgramCodeType));
+                delete progInfo;
+                return NULL;
+            }
+            //ProgramCode is in the form of a URI
+            QString sProgramCode = pProp->GetFirstValue()->GetValue();
+            QString sChanId;
+            QString sStartTime;
+            QString sEndTime;
+
+            if(!ParseCdsEpgId(sProgramCode, sChanId, sStartTime, sEndTime))
+            {
+                //error!!
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid programCode %1.").arg(sProgramCode));
+                delete progInfo;
+                return NULL;
+            }
+
+            progInfo->chanid = sChanId;
+            progInfo->startts.setTime_t(sStartTime.toUInt());
+            progInfo->endts.setTime_t(sEndTime.toUInt());
+            progInfo->rectype = kSingleRecord;    //one-time
+
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "chanid=%1")
+                                .arg(progInfo->chanid));
+        }
+    }
+    else if (srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG")
+    {
+        //not really supported, test code only
+        pProp = srsObject->GetProperty("scheduledCDSObjectID");
+        QString cdsId;
+        QString sChanId;
+        if (pProp)
+        {
+            cdsId = pProp->GetFirstValue()->GetValue();
+
+            QString sStartTime;
+            QString sEndTime;
+            QString sSourceId;
+
+            if(ParseCdsEpgId(cdsId, sChanId, sStartTime, sEndTime))
+            {
+                progInfo->chanid   =  sChanId;
+            }
+            else if (cdsId.startsWith("http://")) //maybe it's a URL
+            {
+                QString sCurrentURI = cdsId;
+                //XML un-escape the URI
+                if (sCurrentURI.contains("&amp;") || sCurrentURI.contains("&gt;") || sCurrentURI.contains("&lt;"))
+                {
+                    sCurrentURI.replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">")
+                               .replace("&quot;","\"").replace("&apos;","'");
+                    VERBOSE(VB_UPNP, QString("UPnpAVT::FromRecordScheduleSRSObject "
+                                        ": escaped programCode='%1'")
+                                        .arg(sCurrentURI));
+                }
+
+                QUrl    url(sCurrentURI);
+                sChanId   = url.queryItemValue("ChanId");
+                progInfo->chanid  =  sChanId;
+                sSourceId = url.queryItemValue("SourceId");
+            }
+            else
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid scheduledCDSObjectID ID %1!")
+                                    .arg(cdsId));
+                delete progInfo;
+                return NULL;
+            }
+            unsigned int nSourceId = 0;
+            bool ok = true;
+            unsigned int nChanId = sChanId.toUInt(&ok);
+            if (ok)
+                nSourceId = ChannelUtil::GetSourceIDForChannel(nChanId);
+            if ((!ok || !nSourceId) && !sSourceId.isEmpty())
+            {
+                ok = true;
+                nSourceId = sSourceId.toUInt(&ok);
+            }
+            if (!ok || !nSourceId)
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid sourceid %1 in scheduledCDSObjectID %2.")
+                                    .arg(nSourceId).arg(cdsId));
+            }
+            progInfo->sourceid = nSourceId;
+        }
+        else
+        {
+            //error!!
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "Valid scheduledCDSObjectID not found!"));
+            delete progInfo;
+            return NULL;
+        }
+        progInfo->rectype = kSingleRecord;    //one-time
+        VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                            "chanid=%1 sourceid=%2 in scheduledCDSObjectID=%3.")
+                            .arg(progInfo->chanid).arg(progInfo->sourceid)
+                            .arg(cdsId));
+    }
+    else if (srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG")
+    {
+        //not really supported, test code only
+        pProp = srsObject->GetProperty("scheduledCDSObjectID");
+        if (pProp)
+        {
+            QString cdsId = pProp->GetFirstValue()->GetValue();
+
+            QString sChanId;
+            QString sStartTime;
+            QString sEndTime;
+
+            if(!ParseCdsEpgId(cdsId, sChanId, sStartTime, sEndTime))
+            {
+                //error!!
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject :"
+                                    " Invalid scheduledCDSObjectID ID %1!")
+                                    .arg(cdsId));
+                delete progInfo;
+                return NULL;
+            }
+            QDateTime startTime;
+            startTime.setTime_t(sStartTime.toUInt());
+            QDateTime endTime;
+            endTime.setTime_t(sEndTime.toUInt());
+            QDateTime midTime = startTime.addSecs(startTime.secsTo(endTime) / 2);
+
+            ProgramInfo dbProgInfo;    //GetProgramAtDateTime(sChanId.toUInt(), midTime);
+            if (dbProgInfo.LoadProgramAtDateTime(sChanId.toUInt(), midTime)
+                    != ProgramInfo::kFoundProgram)
+            {
+                //error!!
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid scheduledCDSObjectID ID %1, no "
+                                    "program at chanid=%2 and start=%3 ")
+                                    .arg(cdsId).arg(progInfo->chanid)
+                                    .arg(progInfo->startts.toString(
+                                            "yyyy-MM-ddThh:mm:ss")));
+                delete progInfo;
+                return NULL;
+            }
+            //clone it to get info
+            progInfo->clone(dbProgInfo);
+            progInfo->rectype = kSingleRecord;    //one-time
+        }
+        else
+        {
+            //error!!
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "Valid scheduledCDSObjectID not found!"));
+            delete progInfo;
+            return NULL;
+        }
+    }
+
+    //try to get start and end time information where expected based on class
+    if ((srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.MANUAL")
+        || (srsObject->m_sClass == "OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG"))
+    {
+
+        //    DATETIME_FROM_LIST(startts)
+        QStringList days;
+        pProp = srsObject->GetProperty("scheduledStartDateTime");
+        if (pProp)
+        {
+            progInfo->startts = SRSObject::StringToDateTime(
+                                    pProp->GetFirstValue()->GetValue(), &days);
+            if (progInfo->startts.isNull() || !progInfo->startts.isValid())
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid scheduledStartDateTime %1!")
+                                    .arg(pProp->GetFirstValue()->GetValue()));
+                delete progInfo;
+                return NULL;
+            }
+        }
+        else
+        {
+            //error!!
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "Valid scheduledStartDateTime not found!"));
+            delete progInfo;
+            return NULL;
+        }
+
+        //    DATETIME_FROM_LIST(endts)
+        pProp = srsObject->GetProperty("scheduledDuration");
+        if (pProp)
+        {
+            int secs = SRSObject::DurationToSecs(pProp->GetFirstValue()->GetValue());
+            progInfo->endts = progInfo->startts.addSecs(secs);
+            if (progInfo->endts.isNull() || !progInfo->endts.isValid())
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                    "Invalid scheduledDuration %1!")
+                                    .arg(pProp->GetFirstValue()->GetValue()));
+                delete progInfo;
+                return NULL;
+            }
+        }
+        else
+        {
+            //error!!
+            VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                                "Valid scheduledDuration not found!"));
+            delete progInfo;
+            return NULL;
+        }
+        VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                            "startts=%1 endts=%2 on days=[%3]")
+                            .arg(progInfo->startts.toString())
+                            .arg(progInfo->endts.toString())
+                            .arg(days.join(",")));
+
+        if (days.size())
+        {
+            //assign rectype
+            if (days.size() == 1)
+                progInfo->rectype = kWeekslotRecord;//same timeslot each week
+            else if ((days.size() == 7) || (days.indexOf("Everyday") >= 0))
+                progInfo->rectype = kTimeslotRecord;//same timeslot everyday
+            else
+            {
+                //TODO: create multiple kWeekslotRecord rules, one for each day
+                //default to single record
+                progInfo->rectype = kSingleRecord;
+            }
+        }
+        else
+            progInfo->rectype = kSingleRecord;    //one-time
+    }
+
+    //    ENUM_FROM_LIST(rectype, RecordingType)
+    //pginfo->rectype = kSingleRecord;    //set explicity?
+
+    progInfo->hostname = gContext->GetHostName();
+
+    //fill in the blanks
+    if (progInfo->sourceid == 0)
+    {
+        progInfo->sourceid = ChannelUtil::GetSourceIDForChannel(
+                                            progInfo->chanid.toUInt());
+        VERBOSE(VB_UPNP, QString("UPnpSRS::FromRecordScheduleSRSObject : "
+                            "for chanid=%1, sourceid=%2")
+                            .arg(progInfo->chanid).arg(progInfo->sourceid));
+    }
+    return progInfo;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QList<SRSObject*> UPnpSRS::ToRecordTaskSRSObjects( RecordingInfo *pginfo )
+{
+    SRSObject *result = NULL;
+    QList<SRSObject*> retList;
+
+    //only one task per schedule
+    QString sRecordTaskId = QString::number(pginfo->recordid) + "-0";
+    result = SRSObject::CreateRecordTask(sRecordTaskId, pginfo->title, NULL);
+
+    result->SetPropValue( "recordScheduleID", "srs",
+                          QString::number(pginfo->recordid));
+
+    //set all the common properties
+    int priority = pginfo->recpriority;
+    if (priority < 1) priority = 1; //because UPNP priority starts at 1, and Myth starts at 0
+    SRSPropertyValue *pPropPR = result->SetPropValue("priority", "srs",
+                                        QString("L%1").arg(priority));
+    pPropPR->SetDependentProperty("orderedValue", QString("%1").arg(priority));
+
+    result->SetPropValue( "desiredPriority", "srs", "DEFAULT" );
+
+    SRSPropertyValue *pPropRD = result->SetPropValue("recordDestination", "srs",
+                                                     "Hard Disk", true, true);
+    pPropRD->SetDependentProperty( "mediaType"  , "HDD" );
+    pPropRD->SetDependentProperty( "targetURL"  , pginfo->GetPlaybackURL() );
+    pPropRD->SetDependentProperty( "preference" , "1" );
+
+    SRSPropertyValue *pPropDRQ = result->SetPropValue("desiredRecordQuality",
+                                                      "srs", "AUTO", false);
+    pPropDRQ->SetDependentProperty ( "type", "DEFAULT" );
+
+    //optional
+    //SRSPropertyValue *pPropCDS = result->SetPropValue( "cdsReference", "srs", "" );
+    //pPropCDS->SetDependentProperty("link", QString::number(pginfo->recordid) );
+
+    LoadRecordingInfo(pginfo);
+
+    SRSPropertyValue *pPropTCI = result->SetPropValue("taskChannelID", "srs", pginfo->chanid);
+    pPropTCI->SetDependentProperty("type", "ANALOG");
+    pPropTCI->SetDependentProperty("distriNetworkName", pginfo->channame);
+    pPropTCI->SetDependentProperty("distriNetworkID"  , pginfo->chansign);
+
+    result->SetPropValue("taskStartDateTime", "srs",
+                         SRSObject::DateTimeToString(pginfo->startts));
+    int secs = pginfo->startts.secsTo(pginfo->endts);
+    result->SetPropValue("taskDuration", "srs", SRSObject::SecsToDuration(secs));
+
+
+    QString sCode =  QString( "epg/%1-%2-%3" ).arg( pginfo->chanid )
+            .arg( pginfo->startts.toTime_t() )
+            .arg( pginfo->endts.toTime_t() );
+    SRSProperty *pPropPC = result->AddProperty(new SRSProperty(
+                                                "taskProgramCode", "srs"));
+    pPropPC->SetValue(sCode);
+
+
+    SRSPropertyValue *pProp = result->SetPropValue( "taskState", "srs",
+                                                    "", true);
+    QStringList lsTaskState = GetTaskStateValues(pginfo, "");
+    pProp->SetValue(lsTaskState.at(0));
+    pProp->SetDependentProperty("phase"            , lsTaskState.at( 1));
+    pProp->SetDependentProperty("recording"        , lsTaskState.at( 2));
+    pProp->SetDependentProperty("someBitsRecorded" , lsTaskState.at( 3));
+    pProp->SetDependentProperty("someBitsMissing"  , lsTaskState.at( 4));
+    pProp->SetDependentProperty("fatalError"       , lsTaskState.at( 5));
+    pProp->SetDependentProperty("currentErrors"    , lsTaskState.at( 6));
+    pProp->SetDependentProperty("pendingErrors"    , lsTaskState.at( 7));
+    pProp->SetDependentProperty("errorHistory"     , lsTaskState.at( 8));
+    pProp->SetDependentProperty("startDateTimeMet" , lsTaskState.at( 9));
+    pProp->SetDependentProperty("endDateTimeMet"   , lsTaskState.at(10));
+    pProp->SetDependentProperty("firstBitsRecorded", lsTaskState.at(11));
+    pProp->SetDependentProperty("lastBitsRecorded" , lsTaskState.at(12));
+    pProp->SetDependentProperty("infoList"         , lsTaskState.at(13));
+
+    retList << result;
+    return retList;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpSRS::AddScheduledRecording(RecordingInfo *progInfo)
+{
+    if (!MainServer::GetScheduler())
+        return -1;
+    // Notify scheduler of the recording.
+    // + set up recording so it can be resumed
+
+    bool ok = true;
+    int chanid = progInfo->chanid.toUInt(&ok);
+    if (!ok)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                            "Invalid chanid=%1.")
+                            .arg(progInfo->chanid));
+        return -1;
+    }
+    progInfo->description = progInfo->title;
+
+    std::vector<uint> cardids = CardUtil::GetCardIDs(progInfo->sourceid);
+    if (cardids.size() < 1)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                            "No valid cardid for sourceid=%1.")
+                            .arg(progInfo->sourceid));
+        return -1;
+    }
+
+    //save if it doesn't exist in the DB
+    ProgramInfo dbProgInfo; //= ProgramInfo::GetProgramAtDateTime(chanid, progInfo->startts);
+
+    if (dbProgInfo.LoadProgramAtDateTime(chanid, progInfo->startts.addSecs(60))
+            != ProgramInfo::kFoundProgram)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                            "Saving proginfo title=%1 chanid=%2 time=%3-%4.")
+                            .arg(progInfo->title).arg(progInfo->chanid)
+                            .arg(progInfo->startts.toString("yyyy-MM-ddThh:mm:ss"))
+                            .arg(progInfo->endts.toString("yyyy-MM-ddThh:mm:ss")));
+        /* ProgramInfo::Save(void) is removed in 0.23, so implement here instead
+         *  \brief Saves this ProgramInfo to the database, replacing any existing
+         *  program in the same timeslot on the same channel.
+         */
+        MSqlQuery query(MSqlQuery::InitCon());
+
+        // This used to be REPLACE INTO...
+        // primary key of table program is chanid,starttime
+        query.prepare("DELETE FROM program"
+                      " WHERE chanid = :CHANID"
+                      " AND starttime = :STARTTIME ;");
+        query.bindValue(":CHANID", progInfo->chanid.toInt());
+        query.bindValue(":STARTTIME", progInfo->startts);
+        if (!query.exec())
+            MythDB::DBError("Saving program", query);
+
+        query.prepare("INSERT INTO program (chanid,starttime,endtime,"
+                      " title,subtitle,description,category,airdate,"
+                      " stars) VALUES (:CHANID,:STARTTIME,:ENDTIME,:TITLE,"
+                      " :SUBTITLE,:DESCRIPTION,:CATEGORY,:AIRDATE,:STARS);");
+        query.bindValue(":CHANID",      progInfo->chanid.toInt());
+        query.bindValue(":STARTTIME",   progInfo->startts);
+        query.bindValue(":ENDTIME",     progInfo->endts);
+        query.bindValue(":TITLE",       progInfo->title);
+        query.bindValue(":SUBTITLE",    progInfo->subtitle);
+        query.bindValue(":DESCRIPTION", progInfo->description);
+        query.bindValue(":CATEGORY",    progInfo->category);
+        query.bindValue(":AIRDATE", "0");
+        query.bindValue(":STARS", "0");
+
+        if (!query.exec())
+            MythDB::DBError("Saving program", query);
+    }
+    else
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                            "Found proginfo in DB with chanid=%1 start=%2 title=%3.")
+                            .arg(dbProgInfo.chanid)
+                            .arg(dbProgInfo.startts.toString("yyyy-MM-ddThh:mm:ss"))
+                            .arg(dbProgInfo.title));
+    }
+
+    RecordingRule *record = progInfo->GetRecordingRule();
+    //record->m_searchType = kManualSearch;
+    record->m_type       = progInfo->rectype;
+    if (record->m_type ==  kNotRecording)
+        record->m_type =  kSingleRecord;
+    VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                            "After load %1, recording on %2/%3.")
+                            .arg(progInfo->toString())
+                            .arg(record->m_channelid)
+                            .arg(record->m_station));
+
+    record->Save(true);
+
+    progInfo->ApplyRecordRecID();
+
+    VERBOSE(VB_UPNP, QString("UPnpSRS::AddScheduledRecording : "
+                        "Adding recording with id=%1 (%2).")
+                        .arg(progInfo->recordid)
+                        .arg(record->m_recordID));
+
+    MainServer::GetScheduler()->AddRecording(*progInfo);
+
+    return progInfo->recordid;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpSRS::GetAllScheduledPrograms(RecList &recList)
+{
+    Scheduler *sched = MainServer::GetScheduler();
+    QStringList slist;
+    sched->getAllScheduled(slist);
+
+    bool result = true;
+    unsigned int count = 0;
+    if (slist.size() > 0)
+        slist.at(0).toUInt();
+
+    QStringList::const_iterator sit = slist.begin()+1;
+
+    while (result && sit != slist.end())
+    {
+        RecordingInfo *p = new RecordingInfo();
+        result = p->FromStringList(sit, slist.end());
+        if (result)
+            recList.push_back(p);
+        else
+            delete p;
+    }
+
+    if (recList.size() == count)
+        return count;
+
+    return -1;    //error, unmatched list
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleBrowseRecordSchedules( HTTPRequest *pRequest )
+{
+    //UPnpSRSExtensionResults *pResult  = NULL;
+    UPnpSRSRequest           request;
+
+    request.m_sFilter           = pRequest->m_mapParams[ "Filter"        ];
+    request.m_nStartingIndex    = pRequest->m_mapParams[ "StartingIndex" ].toLong();
+    request.m_nRequestedCount   = pRequest->m_mapParams[ "RequestedCount"].toLong();
+    request.m_sSortCriteria     = pRequest->m_mapParams[ "SortCriteria"  ];
+
+    int nReturned = 0;
+    int nTotalMatches = 0;
+    QString sResult;
+
+    QTextStream os( &sResult, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    os << UPnpSRS::sSRSStartTag;
+
+    RecList recList;
+    GetAllScheduledPrograms(recList);
+
+    if (request.m_nStartingIndex > recList.size())
+        request.m_nStartingIndex = recList.size() - 1;
+    if (request.m_nRequestedCount > (recList.size() - request.m_nStartingIndex))
+        request.m_nRequestedCount = (recList.size() - request.m_nStartingIndex);
+
+    long limit = (request.m_nStartingIndex + request.m_nRequestedCount);
+    QList<SRSObject *> srsList;
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseSchedules : getting start=%1 count=%2 total=%3)")
+                        .arg(request.m_nStartingIndex).arg(request.m_nRequestedCount).arg(recList.size()));
+    for(long index = request.m_nStartingIndex; index < limit; index++)
+    {
+        RecordingInfo *pginfo = recList.at(index);
+        SRSObject *result = ToRecordScheduleSRSObject(pginfo);
+        srsList.append(result);
+        delete pginfo;
+    }
+
+    //sort according to list of criteria
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseSchedules : sorting by [%1]")
+                        .arg(request.m_sSortCriteria));
+    QStringList sorters = request.m_sSortCriteria.split(',', QString::SkipEmptyParts);
+    if (sorters.size())
+    {
+        //there should be no threading issues using these class members, but need to confirm
+        for(long index = 0; index < srsList.size(); index++)
+        {
+            SRSObject *result = srsList.at(index);
+            result->SetSortCriteria(&sorters);
+        }
+        qStableSort(srsList.begin(), srsList.end(), compare);
+    }
+
+    //convert to XML
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseSchedules : converting to XML with filter = [%1].")
+                                        .arg(request.m_sFilter));
+    FilterMap filter = request.m_sFilter.split(',', QString::SkipEmptyParts);
+
+    for(long index = 0; index < srsList.size(); index++)
+    {
+        SRSObject *result = srsList.at(index);
+        result->toXml(os, filter);
+        os << flush;
+        //VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseSchedules : appending [%1].").arg(item));
+        delete result;
+        nReturned++;
+    }
+    nTotalMatches = recList.size();
+
+    os << UPnpSRS::sSRSEndTag;
+
+    NameValues list;
+    list.push_back( NameValue("Result", (sResult)) );
+    list.push_back( NameValue("NumberReturned", QString::number(nReturned)) );
+    list.push_back( NameValue("TotalMatches", QString::number(nTotalMatches)) );
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    list.push_back( NameValue("UpdateId", GetValue<QString>("StateUpdateID")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleBrowseRecordTasks( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+    request.m_sFilter           = pRequest->m_mapParams[ "Filter"        ];
+    request.m_nStartingIndex    = pRequest->m_mapParams[ "StartingIndex" ].toLong();
+    request.m_nRequestedCount   = pRequest->m_mapParams[ "RequestedCount"].toLong();
+    request.m_sSortCriteria     = pRequest->m_mapParams[ "SortCriteria"  ];
+
+    int nReturned = 0;
+    int nTotalMatches = 0;
+    QString sResult;
+
+    QTextStream os( &sResult, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    os << UPnpSRS::sSRSStartTag;
+
+    QList<SRSObject*> srsList;
+
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    if (request.m_sRecordScheduleID.isEmpty())
+    {
+        //get all of them
+        RecList recList;
+        GetAllScheduledPrograms(recList);
+        nReturned     = recList.size();
+        nTotalMatches = recList.size();
+
+        for(unsigned int index = 0; index < recList.size(); index++)
+        {
+            RecordingInfo *pginfo = recList.at(index);
+            QList<SRSObject*> tmpList = ToRecordTaskSRSObjects(pginfo);
+            srsList << tmpList ;
+            delete pginfo;
+        }
+        QStringList sorters = request.m_sSortCriteria.split(',', QString::SkipEmptyParts);
+        if ((srsList.size() > 1) && sorters.size())
+        {
+            //sort according to list of criteria
+            VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseTasks : sorting by [%1]")
+                                .arg(request.m_sSortCriteria));
+            for(long index = 0; index < srsList.size(); index++)
+            {
+                SRSObject *result = srsList.at(index);
+                result->SetSortCriteria(&sorters);
+            }
+            qStableSort(srsList.begin(), srsList.end(), compare);
+        }
+    }
+    else
+    {
+        //get a specific one
+        nReturned     = 1;
+        nTotalMatches = 1;
+        int recordId = request.m_sRecordScheduleID.toInt();
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseRecordTasks : looking for record id=%1.")
+                            .arg(recordId));
+        RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+        UPnPResultCode error = UPnPResult_Success;
+        if (pginfo)
+        {
+            srsList = ToRecordTaskSRSObjects(pginfo);
+
+            delete pginfo;
+        }
+        else
+        {
+            error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+            sError = "The specified recordSchedule does not exist.";
+        }
+    }
+
+    //convert all to xml
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleBrowseRecordTasks : converting to XML with filter = [%1].")
+                                        .arg(request.m_sFilter));
+    FilterMap filter = request.m_sFilter.split(',', QString::SkipEmptyParts);
+    for (int index = 0; index < srsList.size(); ++index)
+    {
+        SRSObject *result = srsList.at(index);
+        //convert to XML
+
+        result->toXml(os, filter);
+        delete result;
+    }
+
+
+    os << UPnpSRS::sSRSEndTag;
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        list.push_back( NameValue("Result", (sResult)) );
+        list.push_back( NameValue("NumberReturned", QString::number(nReturned)) );
+        list.push_back( NameValue("TotalMatches", QString::number(nTotalMatches)) );
+        QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+        list.push_back( NameValue("UpdateId", GetValue<QString>("StateUpdateID")) );
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+bool UPnpSRS::ParseCdsEpgId(const QString &cdsId     , QString &sChanId,
+                                  QString &sStartTime, QString &sEndTime)
+{
+    //cdsId must match format "epg/%1-%2-%3"
+    if (cdsId.count(QRegExp("epg/[a-zA-Z0-9_]+-[0-9]+-[0-9]+")) == 1)
+    {
+        //parse it
+        int dashIndex1      = cdsId.indexOf("-");
+        int dashIndex2      = cdsId.indexOf("-", dashIndex1 + 1);
+        //int dashIndex3      = cdsId.indexOf("-", dashIndex2 + 1);
+        sChanId     = cdsId.mid(4, dashIndex1 - 4);
+
+        sStartTime  = cdsId.mid(dashIndex1 + 1, dashIndex2 - dashIndex1);
+        sEndTime    = cdsId.mid(dashIndex2 + 1);    //, dashIndex3 - dashIndex2);
+        //QString sSourceId   = cdsId.mid(dashIndex3 + 1);
+        return true;
+    }
+    return false;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleCreateRecordSchedule( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest      request;
+    QString             sResult;
+
+    request.m_sElements = pRequest->m_mapParams[ "Elements" ];
+
+    QList<SRSObject*> srsObjects = SRSObject::fromXML( request.m_sElements );
+    int recordId = -1;
+
+    QTextStream os( &sResult, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    os << UPnpSRS::sSRSStartTag;
+
+    if (srsObjects.size() > 0)
+    {
+        //only one at a time
+        SRSObject   *input = srsObjects.at(0);
+        RecordingInfo *progInfo = FromRecordScheduleSRSObject(input);
+
+        if (progInfo)
+        {
+            //generate unique recordId and create recording
+            recordId = AddScheduledRecording(progInfo);
+            if (recordId >= 0)
+            {
+                delete progInfo;
+
+                RecList recList;
+                GetAllScheduledPrograms(recList);
+
+                for(unsigned int index = 0; index < recList.size(); index++)
+                {
+                    RecordingInfo *pginfo = recList.at(index);
+                    if (pginfo->recordid == recordId)
+                    {
+                        SRSObject *result = ToRecordScheduleSRSObject(pginfo, input);
+
+                        //fill in missing fields
+                        SRSObject::SyncSRSObjects(input, result);
+
+                        //convert to XML
+                        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleCreateRecordSchedule :"
+                                            " converting to XML with filter = [%1].")
+                                            .arg(request.m_sFilter));
+                        FilterMap filter("*:*");    // = request.m_sFilter.split(',', QString::SkipEmptyParts);
+
+                        result->toXml(os, filter);
+                        delete result;
+
+                        //increment if successful
+                        QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+                        UPnpSRS::nStateUpdateID++;
+                        SetValue< QString >( "StateUpdateID",
+                                QString::number(UPnpSRS::nStateUpdateID) );
+
+                        //event the change
+                        QString sStateEvent = UPnpSRS::sXMLStartTag
+                                + UPnpSRS::sStateEventStartTag
+                                + QString(UPnpSRS::sStateEventRecordScheduleCreated)
+                                            .arg(UPnpSRS::nStateUpdateID)
+                                            .arg(recordId)
+                                + UPnpSRS::sStateEventEndTag;
+                        UPnpSRMonitor::NotifyEvented(QString(UPnpSRS::sStateEventRecordScheduleCreated)
+                                .arg("*").arg(recordId));
+                        SetValue< QString >( "LastChange", Qt::escape(sStateEvent) );
+                    }
+                    delete pginfo;
+                }
+            }
+        }
+    }
+    os << UPnpSRS::sSRSEndTag;
+    //cleanup
+    for (int i = 0; i < srsObjects.size(); ++i)
+    {
+        delete srsObjects.at(i);
+    }
+
+    NameValues list;
+    list.push_back( NameValue("RecordScheduleID", QString::number(recordId)) );
+    list.push_back( NameValue("Result",           (sResult)) );
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    list.push_back( NameValue("UpdateId",         GetValue<QString>("StateUpdateID")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleDeleteRecordSchedule( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+
+    int recordId = request.m_sRecordScheduleID.toInt();
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleDeleteRecordSchedule : looking for record id=%1.")
+                        .arg(recordId));
+    RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+    if (pginfo)
+    {
+        if (pginfo->recstatus == rsRecording)
+        {
+            VERBOSE(VB_UPNP, QString("UPnpSRS::HandleDeleteRecordSchedule : "
+                                "record id=%1 in progress.").arg(recordId));
+            error  = UPnPResult_SRS_ActiveRecordTask;
+            sError = "One or more recordTask instances are actively recording.";
+        }
+        else
+        {
+            pginfo->GetRecordingRule()->Delete(true);    //that simple?
+            //increment if successful
+            QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+            UPnpSRS::nStateUpdateID++;
+            SetValue< QString >( "StateUpdateID", QString::number(
+                    UPnpSRS::nStateUpdateID) );
+
+            //event the change
+            //event the change
+            QString sStateEvent = UPnpSRS::sStateEventStartTag
+                    + QString(UPnpSRS::sStateEventRecordScheduleDeleted)
+                                .arg(UPnpSRS::nStateUpdateID)
+                                .arg(recordId)
+                    + UPnpSRS::sStateEventEndTag;
+            UPnpSRMonitor::NotifyEvented(QString(UPnpSRS::sStateEventRecordScheduleDeleted)
+                    .arg("*").arg(recordId));
+            SetValue< QString >( "LastChange", Qt::escape(sStateEvent) );
+        }
+        delete pginfo;
+    }
+    else
+    {
+        error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetRecordSchedule( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+    request.m_sFilter           = pRequest->m_mapParams[ "Filter"        ];
+
+
+    QString sResult;
+    QTextStream os( &sResult, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    os << UPnpSRS::sSRSStartTag;
+
+
+    int recordId = request.m_sRecordScheduleID.toInt();
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordSchedule : looking for record id=%1.")
+                        .arg(recordId));
+    RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    if (pginfo)
+    {
+        SRSObject *result = ToRecordScheduleSRSObject(pginfo);
+
+        //convert to XML
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordSchedule : converting to XML with filter = [%1].")
+                                            .arg(request.m_sFilter));
+        FilterMap filter = request.m_sFilter.split(',', QString::SkipEmptyParts);
+
+        result->toXml(os, filter);
+
+        delete result;
+        delete pginfo;
+    }
+    else
+    {
+        error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+
+    os << UPnpSRS::sSRSEndTag;
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        list.push_back( NameValue("Result", (sResult)) );
+        QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+        list.push_back( NameValue("UpdateId", GetValue<QString>("StateUpdateID")) );
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleEnableRecordSchedule( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+
+
+    int recordId = request.m_sRecordScheduleID.toInt();
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleEnableRecordSchedule : "
+                        "looking for record id=%1.").arg(recordId));
+    RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    if (pginfo)
+    {
+        if (GetScheduleStateValue(pginfo).at(0)
+                == SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED)
+        {
+            error  = UPnPResult_SRS_RecordScheduleCompleted;
+            sError = "The recordSchedule has already completed and cannot be enabled or disabled.";
+        }
+        else
+        {
+            RecordingRule *recRule = pginfo->GetRecordingRule();
+            pginfo->rectype = kDontRecord;
+            if (recRule->m_isInactive)
+            {
+                recRule->m_isInactive = false;
+                recRule->Save(true);
+
+                //increment if successful
+                QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+                UPnpSRS::nStateUpdateID++;
+                SetValue< QString >( "StateUpdateID",
+                        QString::number(UPnpSRS::nStateUpdateID) );
+
+                //event the change
+                QString sStateEvent = UPnpSRS::sStateEventStartTag
+                        + QString(UPnpSRS::sStateEventRecordScheduleModified)
+                                    .arg(UPnpSRS::nStateUpdateID)
+                                    .arg(recordId)
+                        + UPnpSRS::sStateEventEndTag;
+                UPnpSRMonitor::NotifyEvented(QString(UPnpSRS::sStateEventRecordScheduleModified)
+                        .arg("*").arg(recordId));
+                SetValue< QString >( "LastChange", Qt::escape(sStateEvent) );
+            }
+            else
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::HandleEnableRecordSchedule :"
+                                    " record id=%1 already enabled.")
+                                    .arg(recordId));
+                error  = UPnPResult_SRS_CannotProcessRequest;
+                sError = "Cannot process the request in a reasonable amount of time.";
+            }
+
+        }
+        delete pginfo;
+    }
+    else
+    {
+        error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleDisableRecordSchedule( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+
+    int recordId = request.m_sRecordScheduleID.toInt();
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleDisableRecordSchedule : "
+                        "looking for record id=%1.").arg(recordId));
+    RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    if (pginfo)
+    {
+        if (GetScheduleStateValue(pginfo).at(0)
+                == SRSObject::SRS_SCHEDULESTATE_VAL_COMPLETED)
+        {
+            error  = UPnPResult_SRS_RecordScheduleCompleted;
+            sError = "The recordSchedule has already completed and cannot be enabled or disabled.";
+        }
+        else
+        {
+            RecordingRule *recRule = pginfo->GetRecordingRule();
+            pginfo->rectype = kDontRecord;
+            if (!recRule->m_isInactive)
+            {
+                recRule->m_isInactive = true;
+                recRule->Save(true);
+
+                //increment if successful
+                QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+                UPnpSRS::nStateUpdateID++;
+                SetValue< QString >( "StateUpdateID",
+                        QString::number(UPnpSRS::nStateUpdateID) );
+
+                //event the change
+                QString sStateEvent = UPnpSRS::sStateEventStartTag
+                        + QString(UPnpSRS::sStateEventRecordScheduleModified)
+                                    .arg(UPnpSRS::nStateUpdateID)
+                                    .arg(recordId)
+                        + UPnpSRS::sStateEventEndTag;
+                UPnpSRMonitor::NotifyEvented(QString(UPnpSRS::sStateEventRecordScheduleModified)
+                                        .arg("*").arg(recordId));
+                SetValue< QString >( "LastChange", Qt::escape(sStateEvent) );
+            }
+            else
+            {
+                VERBOSE(VB_UPNP, QString("UPnpSRS::HandleDisableRecordSchedule : "
+                                    "record id=%1 already disabled.").arg(recordId));
+                error  = UPnPResult_SRS_CannotProcessRequest;
+                sError = "Cannot process the request in a reasonable amount of time.";
+            }
+            //else already disabled
+        }
+        delete pginfo;
+    }
+    else
+    {
+        error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetRecordTask( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    QString sRecordTaskId = pRequest->m_mapParams[ "RecordTaskID" ];
+    request.m_sFilter     = pRequest->m_mapParams[ "Filter"       ];
+
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    QString sResult;
+    QTextStream os( &sResult, QIODevice::WriteOnly );
+    os.setCodec(QTextCodec::codecForName("UTF-8"));
+    os << UPnpSRS::sSRSStartTag;
+
+    QList<SRSObject*> srsList;
+
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTask : "
+                        "looking for record task id=%1.").arg(sRecordTaskId));
+
+    if (!sRecordTaskId.endsWith("-0"))    //only support one task per schedule right now
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTask : "
+                            "Invalid RecordTask id=%1.").arg(sRecordTaskId));
+        error  = UPnPResult_SRS_NoSuchRecordTaskID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+    else
+    {
+        request.m_sRecordScheduleID = sRecordTaskId.left(sRecordTaskId.length() - QString("-0").length());
+
+        int recordId = request.m_sRecordScheduleID.toInt();
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTaskConflicts : "
+                            "looking for record id=%1.").arg(recordId));
+
+        RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+
+        if (pginfo)
+        {
+            srsList = UPnpSRS::ToRecordTaskSRSObjects(pginfo);
+            delete pginfo;
+        }
+        else
+        {
+            error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+            sError = "The specified recordSchedule does not exist.";
+        }
+    }
+
+    //convert all to xml
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTask : converting to XML with filter = [%1].")
+                                        .arg(request.m_sFilter));
+    FilterMap filter = request.m_sFilter.split(',', QString::SkipEmptyParts);
+    for (int index = 0; index < srsList.size(); ++index)
+    {
+        SRSObject *result = srsList.at(index);
+
+        //convert to XML
+        result->toXml(os, filter);
+        delete result;
+    }
+    os << UPnpSRS::sSRSEndTag;
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        list.push_back( NameValue("Result", sResult) );
+        QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+        list.push_back( NameValue("UpdateId", GetValue<QString>("StateUpdateID")) );
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleEnableRecordTask( HTTPRequest *pRequest )
+{
+    //not implemented
+}
+
+void UPnpSRS::HandleDisableRecordTask( HTTPRequest *pRequest )
+{
+    //not implemented
+}
+
+void UPnpSRS::HandleResetRecordTask( HTTPRequest *pRequest )
+{
+    //not implemented
+}
+
+void UPnpSRS::HandleDeleteRecordTask( HTTPRequest *pRequest )
+{
+    //not implemented
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetRecordScheduleConflicts( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    request.m_sRecordScheduleID = pRequest->m_mapParams[ "RecordScheduleID" ];
+
+    int recordId = request.m_sRecordScheduleID.toInt();
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordScheduleConflicts : "
+                        "looking for record id=%1.").arg(recordId));
+    RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    QStringList lsResults;
+
+    //spec requires getting the updateId before performing this action
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    QString sUpdateID = GetValue<QString>("StateUpdateID");
+
+    if (pginfo)
+    {
+        RecList conflicts;
+        MainServer::GetScheduler()->getConflicting(pginfo, &conflicts);
+        while (conflicts.size())
+        {
+            RecordingInfo *rec = conflicts.front();
+            lsResults << QString::number(rec->recordid);
+            delete rec;
+            conflicts.pop_front();
+        }
+        delete pginfo;
+    }
+    else
+    {
+        error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        list.push_back( NameValue("RecordScheduleConflictIDList", lsResults.join(",")) );
+        list.push_back( NameValue("UpdateId", sUpdateID) );
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpSRS::HandleGetRecordTaskConflicts( HTTPRequest *pRequest )
+{
+    UPnpSRSRequest           request;
+
+    QString sRecordTaskId = pRequest->m_mapParams[ "RecordTaskID" ];
+
+    UPnPResultCode error = UPnPResult_Success;
+    QString sError = "";
+
+    QStringList lsResults;
+
+    VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTaskConflicts : "
+                        "looking for record task id=%1.").arg(sRecordTaskId));
+    //spec requires getting the updateId before performing this action
+    QMutexLocker locker(&UPnpSRS::StateUpdateIDMutex);
+    QString sUpdateID = GetValue<QString>("StateUpdateID");
+
+    if (!sRecordTaskId.endsWith("-0"))    //only support one task per schedule right now
+    {
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTaskConflicts : "
+                            "Invalid RecordTask id=%1.").arg(sRecordTaskId));
+        error  = UPnPResult_SRS_NoSuchRecordTaskID;
+        sError = "The specified recordSchedule does not exist.";
+    }
+    else
+    {
+        request.m_sRecordScheduleID = sRecordTaskId.left(sRecordTaskId.length() - QString("-0").length());
+
+        int recordId = request.m_sRecordScheduleID.toInt();
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleGetRecordTaskConflicts : "
+                            "looking for record id=%1.").arg(recordId));
+
+        RecordingInfo *pginfo = GetRecordingFromAllScheduled(recordId);
+
+        if (pginfo)
+        {
+            RecList conflicts;
+            MainServer::GetScheduler()->getConflicting(pginfo, &conflicts);
+            while (conflicts.size())
+            {
+                RecordingInfo *rec = conflicts.front();
+                lsResults << (QString::number(rec->recordid)+"-0");    //only one task per schedule
+                delete rec;
+                conflicts.pop_front();
+            }
+            delete pginfo;
+        }
+        else
+        {
+            error  = UPnPResult_SRS_NoSuchRecordScheduleID;
+            sError = "The specified recordSchedule does not exist.";
+        }
+    }
+
+    if (error != UPnPResult_Success)
+    {
+        UPnp::FormatErrorResponse( pRequest, error, sError );
+    }
+    else
+    {
+        NameValues list;
+        list.push_back( NameValue("RecordTaskConflictIDList", lsResults.join(",")) );
+        list.push_back( NameValue("UpdateId", sUpdateID) );
+        pRequest->FormatActionResponse(list);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+//static declarations for monitor class
+QMutex         UPnpSRMonitor::instanceLock;
+UPnpSRMonitor *UPnpSRMonitor::instance = NULL;
+QSet<UPnpSRS*> UPnpSRMonitor::srsInstances;
+QSet<QString>  UPnpSRMonitor::alreadyEvented;
+
+void UPnpSRMonitor::RegisterSRS( UPnpSRS* srs )
+{
+    QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+    UPnpSRMonitor::srsInstances.insert(srs);
+}
+
+void UPnpSRMonitor::UnregisterSRS( UPnpSRS* srs )
+{
+    QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+    UPnpSRMonitor::srsInstances.remove(srs);
+}
+
+void UPnpSRMonitor::NotifyEvented( const QString &sEventSummary )
+{
+    QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+    UPnpSRMonitor::alreadyEvented.insert(sEventSummary);
+}
+
+//Rather than hook (or hack) into the Scheduler class and potentially mess
+//things up for all of Myth, we simply use Scheduler API to monitor its
+//internal changes from outside.
+void UPnpSRMonitor::run()
+{
+    VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : starting up, waiting for scheduler."));
+
+    //wait for scheduler to start up
+    while(MainServer::GetScheduler() == NULL)
+        sleep (3);
+
+    VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : started up, got scheduler."));
+
+    RecList prevList;
+    //populate initially
+    UPnpSRS::GetAllScheduledPrograms(prevList);
+
+    QStringList lsEventQueue;
+
+    while(1)
+    {
+        RecList currList;
+
+        UPnpSRS::GetAllScheduledPrograms(currList);
+
+        //compare both lists to check if anything has changed
+        for (unsigned int i = 0; i < currList.size(); i++)
+        {
+            RecordingInfo *recCurr = currList.at(i);
+            QStringList sSchedStateCurr = UPnpSRS::GetScheduleStateValue(recCurr);
+            QStringList sTaskCurr       = UPnpSRS::GetTaskStateValues(recCurr, "");
+            RecordingRule *recRuleCurr  = recCurr->GetRecordingRule();
+            bool isNew = true;
+            bool isChanged = false;
+
+            for (unsigned int j = 0; j < prevList.size(); j++)
+            {
+                RecordingInfo *recPrev = prevList.at(j);
+                if (recCurr->recordid == recPrev->recordid)
+                {
+                    isNew = false;
+                    //compare and event any changes
+                    QStringList sSchedStatePrev = UPnpSRS::GetScheduleStateValue(recPrev);
+
+                    if (sSchedStateCurr.at(0) != sSchedStatePrev.at(0))
+                        isChanged = true;
+
+                    if (!isChanged)
+                    {
+                        QStringList sTaskPrev = UPnpSRS::GetTaskStateValues(recPrev, "");
+                        if (sTaskCurr.at(0) != sTaskPrev.at(0))
+                            isChanged = true;
+                    }
+
+                    if ((recCurr->startts != recPrev->startts)
+                        || (recCurr->endts != recPrev->endts)
+                        || (recCurr->title != recPrev->title))
+                        isChanged = true;
+                    if (!isChanged)
+                    {
+                        RecordingRule *recRulePrev = recPrev->GetRecordingRule();
+
+                        if ((recRuleCurr && recRulePrev)
+                            && (recRuleCurr->m_isInactive
+                                    != recRulePrev->m_isInactive))
+                            isChanged = true;
+                    }
+                    break;
+                }
+            }
+
+            if (isNew)
+            {
+                QString eventSummary = QString(UPnpSRS::sStateEventRecordScheduleCreated)
+                        .arg("*").arg(recCurr->recordid);
+                QMutexLocker locker1(&UPnpSRMonitor::instanceLock);
+                if (UPnpSRMonitor::alreadyEvented.contains(eventSummary))
+                {
+                    //we already evented this, so skip it for now
+                    UPnpSRMonitor::alreadyEvented.remove(eventSummary);
+                }
+                else
+                {
+                    //queue for eventing
+                    QMutexLocker locker2(&UPnpSRS::StateUpdateIDMutex);
+                    UPnpSRS::nStateUpdateID++;
+                    QString sStateEvent = UPnpSRS::sStateEventStartTag
+                            + QString(UPnpSRS::sStateEventRecordScheduleCreated)
+                                        .arg(UPnpSRS::nStateUpdateID)
+                                        .arg(recCurr->recordid)
+                            + UPnpSRS::sStateEventEndTag;
+                    lsEventQueue << sStateEvent;
+                }
+            }
+
+            if (isChanged)
+            {
+                QString eventSummary = QString(UPnpSRS::sStateEventRecordScheduleModified)
+                        .arg("*").arg(recCurr->recordid);
+                QMutexLocker locker1(&UPnpSRMonitor::instanceLock);
+                if (UPnpSRMonitor::alreadyEvented.contains(eventSummary))
+                {
+                    //we already evented this, so skip it for now
+                    UPnpSRMonitor::alreadyEvented.remove(eventSummary);
+                }
+                else
+                {
+                    //queue for eventing
+                    QMutexLocker locker2(&UPnpSRS::StateUpdateIDMutex);
+                    UPnpSRS::nStateUpdateID++;
+                    QString sStateEvent = UPnpSRS::sStateEventStartTag
+                            + QString(UPnpSRS::sStateEventRecordScheduleModified)
+                                        .arg(UPnpSRS::nStateUpdateID)
+                                        .arg(recCurr->recordid)
+                            + UPnpSRS::sStateEventEndTag;
+                    lsEventQueue << sStateEvent;
+                }
+            }
+        }
+
+        //check for records no longer found
+        for (unsigned int j = 0; j < prevList.size(); j++)
+        {
+            RecordingInfo *recPrev = prevList.at(j);
+            bool found = false;
+            for (unsigned int i = 0; i < currList.size(); i++)
+            {
+                RecordingInfo *recCurr = currList.at(i);
+                if (recCurr->recordid == recPrev->recordid)
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+            {
+                QString eventSummary = QString(UPnpSRS::sStateEventRecordScheduleDeleted)
+                        .arg("*").arg(recPrev->recordid);
+                QMutexLocker locker1(&UPnpSRMonitor::instanceLock);
+                if (UPnpSRMonitor::alreadyEvented.contains(eventSummary))
+                {
+                    //we already evented this, so skip it for now
+                    UPnpSRMonitor::alreadyEvented.remove(eventSummary);
+                }
+                else
+                {
+                    //queue for eventing
+                    QMutexLocker locker2(&UPnpSRS::StateUpdateIDMutex);
+                    UPnpSRS::nStateUpdateID++;
+                    QString sStateEvent = UPnpSRS::sStateEventStartTag
+                            + QString(UPnpSRS::sStateEventRecordScheduleDeleted)
+                                        .arg(UPnpSRS::nStateUpdateID)
+                                        .arg(recPrev->recordid)
+                            + UPnpSRS::sStateEventEndTag;
+                    lsEventQueue << sStateEvent;
+                }
+            }
+        }
+        /*{ QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+            VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : already evented [%1]")
+                                .arg(QStringList(UPnpSRMonitor::alreadyEvented.toList()).join(",")));
+            VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : checked [%1] vs [%2] eventing [%3]")
+                                .arg(prevList.size()).arg(currList.size()).arg(lsEventQueue.join("\n"))); }*/
+
+        //event the change
+        if (lsEventQueue.size()) //also for scoping locker
+        {
+            QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+            if (UPnpSRMonitor::srsInstances.size())
+            {
+                //get the first srs service we can find
+                QSet<UPnpSRS *>::const_iterator itr = UPnpSRMonitor::srsInstances.begin();
+                if (itr != UPnpSRMonitor::srsInstances.end())
+                {
+                    UPnpSRS *srs = *itr;
+                    QString sStateEvents = UPnpSRS::sXMLStartTag + lsEventQueue.join("\n");
+                    VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : eventing [%1]")
+                                        .arg(sStateEvents));
+                    srs->SetValue< QString >( "StateUpdateID", QString::number(UPnpSRS::nStateUpdateID) );
+                    srs->SetValue< QString >( "LastChange", Qt::escape(sStateEvents) );
+                    lsEventQueue.clear();
+                }
+            }
+            else
+                VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : "
+                                    "Not eventing due to lack of UPnpSRS instances"));
+        }//end scoping locker
+
+        //clean up old list
+        while (prevList.size())
+        {
+            delete prevList.front();
+            prevList.pop_front();
+        }
+
+        //transfer current list to old list
+        prevList = currList;
+
+        sleep (3);
+    }
+
+    //shut down if we ever get here
+    while (prevList.size())
+    {
+        delete prevList.front();
+        prevList.pop_front();
+    }
+    VERBOSE(VB_UPNP, QString("UPnpSRMonitor::run : shutting down."));
+}
+
+//static allowed values XML declarations
+//commented out parts reflect fields or actions not currently implemented
+const QString UPnpSRS::recordScheduleAllowedValuesXML =
+    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
+    "<AVDT xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:srs=\"urn:schemas-upnp-org:av:srs\" "
+    "xmlns=\"urn:schemas-upnp-org:av:avdt\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
+    "xsi:schemaLocation=\"urn:schemas-upnp-org:av:srs http://www.upnp.org/schemas/av/srs.xsd "
+    "urn:schemas-upnp-org:av:avdt http://www.upnp.org/schemas/av/avdt.xsd\">"
+    "<contextID>"
+    "    uuid:device-UUID::urn:schemas-upnp-org:service:ScheduledRecording:1"
+    "</contextID>"
+    "<dataStructType>A_ARG_TYPE_RecordSchedule</dataStructType>"
+    "<fieldTable>"
+    "<field>"
+    "<name>srs:@id</name>"
+    "<dataType maxSize=\"256\">xsd:string</dataType>"
+    "<minCountTotal>1</minCountTotal>"
+    "<allowedValueDescriptor>"
+    "<allowAny></allowAny>"
+    "</allowedValueDescriptor>"
+    "</field>"
+    "<field>"
+    "<name>srs:title</name>"
+    "<dataType maxSize=\"128\">xsd:string</dataType>"
+    "<minCountTotal>1</minCountTotal>"
+    "<allowedValueDescriptor>"
+    "<allowAny></allowAny>"
+    "</allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:class</name> <dataTy    >xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> "
+    "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</allowedValue>"
+    "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</allowedValue>"
+    "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</allowedValue>"
+    "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE</allowedValue>"
+    "<allowedValue>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</allowedValue>"
+    "<allowedValue>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:additionalInfo</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:cdsReference</name> <dataType maxSize=\"8192\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value> "
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:cdsReference@link</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:cdsReference</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:Priority</name> <dataType maxSize=\"8\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>L1</allowedValue> <allowedValue>L2</allowedValue> <allowedValue>L3</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:priority@orderedValue</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:priority</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueRange>"
+    "<minimum>1</minimum> <maximum>64</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredPriority</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority@type</name> <valueList>"
+    "<value>PREDEF</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>DEFAULT</allowedValue> <allowedValue>L1</allowedValue> <allowedValue>L2</allowedValue> "
+    "<allowedValue>L3</allowedValue> <allowedValue>HIGHEST</allowedValue> <allowedValue>LOWEST</allowedValue> "
+    "<allowedValue>L1_HI</allowedValue> <allowedValue>L1_LO</allowedValue> <allowedValue>L2_HI</allowedValue>"
+    "<allowedValue>L2_LO</allowedValue> <allowedValue>L3_HI</allowedValue> <allowedValue>L3_LO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority@type</name> <valueList>"
+    "<value>OBJECTID</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:desiredPriority@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>PREDEF</allowedValue>"
+    "<allowedValue>OBJECTID</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:recordDestination</name> <dataType maxSize=\"1024\">xsd:string</dataType> <minCountTotal>1</minCountTotal>"
+    "<maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>Hard Disk 1</allowedValue> <allowedValue>Hard Disk 2</allowedValue>"
+    "<allowedValue>DVD Drive</allowedValue> <allowedValue>Remote Media Jukebox</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordDestination@mediaType</name> <dataType csv=\"xsd:string\" maxSize=\"16\">xsd:string</dataType>"
+    "<maxCountTotal>3</maxCountTotal> <minListSizeTotal>1</minListSizeTotal> <maxListSizeTotal>4</maxListSizeTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <valueList>"
+    "<value>HardDisk 1</value> <value>HardDisk 2</value>"
+    "</valueList> </dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <allowedValueList>"
+    "<allowedValue>HDD</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <valueList>"
+    "<value>DVD Drive</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+    "<allowedValue>DVD+RW</allowedValue> <allowedValue>DVD-RW</allowedValue> <allowedValue>DVD-R</allowedValue>"
+    "<allowedValue>DVD+R</allowedValue> <allowedValue>CD-R</allowedValue> <allowedValue>CD-RW</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> "
+    /*"<allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <valueList>"
+    "<value>Remote Media Jukebox</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>2</maxListSize> <allowedValueList>"
+    "<allowedValue>CD-R</allowedValue>"
+    "<allowedValue>CD-RW</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor>"*/
+    "</field><field> <name>srs:recordDestination@targetURL</name> <dataType>xsd:anyURI</dataType> <maxCountTotal>3</maxCountTotal>"
+    "<allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordDestination@preference</name> <dataType>xsd:unsignedInt</dataType>"
+    "<maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueRange>"
+    "<minimum>1</minimum> <maximum>3</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredRecordQuality</name> <dataType csv=\"xsd:string\" maxSize=\"1024\">xsd:string</dataType>"
+    "<maxListSizeTotal>UNBOUNDED</maxListSizeTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>DEFAULT</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+    "<allowedValue>HD</allowedValue> <allowedValue>ED</allowedValue> <allowedValue>SD</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>ATSC</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>11</maxListSize> <allowedValueList>"
+    "<allowedValue>1080p30</allowedValue> <allowedValue>1080p24</allowedValue> <allowedValue>1080i60</allowedValue> <allowedValue>720p60</allowedValue> <allowedValue>720p30</allowedValue> <allowedValue>720p24</allowedValue> <allowedValue>480p60</allowedValue> <allowedValue>480p30</allowedValue> <allowedValue>480p24</allowedValue> <allowedValue>480i60</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>QLEVEL</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+    "<allowedValue>Q1</allowedValue> <allowedValue>Q2</allowedValue> <allowedValue>Q3</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredRecordQuality@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>DEFAULT</allowedValue> <allowedValue>ATSC</allowedValue> <allowedValue>QLEVEL</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledCDSObjectID</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:scheduledCDSObjectID@link</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduledCDSObjectID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledChannelID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:scheduledChannelID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>ANALOG</allowedValue> <allowedValue>DIGITAL</allowedValue> <allowedValue>FREQUENCY</allowedValue> <allowedValue>SI</allowedValue> <allowedValue>LINE</allowedValue> <allowedValue>NETWORK</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledChannelID@distriNetworkName</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledChannelID@distriNetworkID</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledStartDateTime</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledDuration</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:scheduledProgramCode</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE"
+    "</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:scheduledProgramCode@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduledProgramCode</name>"
+    "<anyValue></anyValue> </dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    /*"<field><name>srs:matchingName</name> <dataType maxSize=\"128\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:matchingName@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingName</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>PROGRAM</allowedValue>"
+    "<allowedValue>SERIES</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:matchingName@subStringMatch</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingName</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField>"
+    "<minCount>1</minCount>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>SI_PROGRAMID</allowedValue>"
+    "<allowedValue>SI_SERIESID</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:matchingChannelID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> </valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingChannelID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingChannelID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>ANALOG</allowedValue> <allowedValue>DIGITAL</allowedValue> <allowedValue>FREQUENCY</allowedValue> <allowedValue>SI</allowedValue> <allowedValue>LINE</allowedValue> <allowedValue>NETWORK</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingChannelID@distriNetworkName</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField>"
+    "<name>srs:matchingChannelID</name>"
+    "<anyValue></anyValue> </dependentField> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:matchingChannelID@distriNetworkID</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingChannelID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingStartDateTimeRange</name> <dataType maxSize=\"64\">xsd:string</dataType> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingDurationRange</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingRatingLimit</name> <dataType maxSize=\"16\">xsd:string</dataType> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"
+    "</valueList> </dependentField> <dependentField>"
+    "<name>srs:matchingRatingLimit@type</name> <valueList>"
+    "<value>MPAA.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>G</allowedValue> <allowedValue>PG</allowedValue> <allowedValue>PG-13</allowedValue> <allowedValue>R</allowedValue> <allowedValue>NC-17</allowedValue> <allowedValue>NR</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:matchingRatingLimit@type</name> <valueList>"
+    "<value>RIAA.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue></allowedValue>"
+    "<allowedValue>PA-EC</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:matchingRatingLimit@type</name> <valueList>"
+    "<value>ESRB.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>EC</allowedValue> <allowedValue>E</allowedValue> <allowedValue>E10+</allowedValue> <allowedValue>T</allowedValue> <allowedValue>M</allowedValue> <allowedValue>AO</allowedValue>"
+    "<allowedValue>RP</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:matchingRatingLimit@type</name> <valueList>"
+    "<value>TVGUIDELINES.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>TV-Y</allowedValue> <allowedValue>TV-Y7</allowedValue> <allowedValue>TV-Y7FV</allowedValue> <allowedValue>TV-G</allowedValue> <allowedValue>TV-PG</allowedValue> <allowedValue>TV-14</allowedValue> <allowedValue>TV-MA</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingRatingLimit@type</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchingRatingLimit</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>MPAA.ORG</allowedValue> <allowedValue>RIAA.ORG</allowedValue> <allowedValue>ESRB.ORG</allowedValue> <allowedValue>TVGUIDLINES.ORG</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchingEpisodeType</name> <dataType maxSize=\"9\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+    "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+    "</dependentField> <allowedValueList>"
+    "<allowedValue>ALL</allowedValue> <allowedValue>FIRST_RUN</allowedValue> <allowedValue>REPEAT</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"*/
+    "<field> <name>srs:totalDesiredRecordTasks</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledStartDateTimeAdjust</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledDurationAdjust</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:activePeriod</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value> <value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value> <value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"
+    "</valueList> </dependentField> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:durationLimit</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+    /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+    "</valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:durationLimit@effect</name> <dataType maxSize=\"8\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:durationLimit</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>FIRST</allowedValue> <allowedValue>LAST</allowedValue> <allowedValue>SKIP</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:channelMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+    /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+    "</valueList> </dependentField> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:timeMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name> <valueList>"
+    "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+    /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+    "</valueList> </dependentField> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    /*"<field> <name>srs:allowDuplicates</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:class</name>"
+    "<valueList><value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"
+    "</valueList> </dependentField> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"*/
+    "<field> <name>srs:persistedRecordings</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:persistedRecordings@latest</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:persistedRecordings@preAllocation</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:persistedRecordings@storedLifetime</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduleState</name> <dataType maxSize=\"16\">xsd:string</dataType> <minCountTotal>1</minCountTotal>"
+    "<allowedValueDescriptor<allowedValueList> <allowedValue>OPERATIONAL</allowedValue>"
+    "<allowedValue>COMPLETED</allowedValue>"
+    "<allowedValue>ERROR</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:scheduleState@currentErrors</name> <dataType csv=\"xsd:int\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduleState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <maxListSize>UNBOUNDED</maxListSize> <allowedValueRange>"
+    "<minimum>100</minimum> <maximum>105</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduleState@abnormalTasksExist</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:scheduleState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:currentRecordTaskCount</name> <dataType>xsd:unsignedInt</dataType> <minCountTotal>1</minCountTotal>"
+    "<allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:totalCreatedRecordTasks</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:totalCompletedRecordTasks</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "</fieldTable> </AVDT>";
+
+const QString UPnpSRS::recordTaskAllowedValuesXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "
+    "<AVDT"
+    "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:srs=\"urn:schemas-upnp-org:av:srs\" xmlns=\"urn:schemas-upnp-org:av:avdt\" "
+    "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"urn:schemas-upnp-org:av:srs "
+    "http://www.upnp.org/schemas/av/srs.xsd urn:schemas-upnp-org:av:avdt http://www.upnp.org/schemas/av/avdt.xsd\">"
+    "<contextID>uuid:device-UUID::urn:schemas-upnp-org:service:ScheduledRecording:1 </contextID>"
+    "<dataStructType>A_ARG_TYPE_RecordTask</dataStructType>"
+    "<fieldTable> <field>"
+    "<name>srs:@id</name> <dataType maxSize=\"256\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:title</name> <dataType maxSize=\"128\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:class</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>OBJECT.RECORDTASK</allowedValue>"
+    "</allowedValueList></allowedValueDescriptor> </field>"
+    "<field> <name>srs:additionalInfo</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:cdsReference</name> <dataType maxSize=\"8192\">xsd:string</dataType> <maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskCDSObjectID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordedCDSObjectID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:cdsReference@link</name> <dataType maxSize=\"1024\">xsd:string</dataType> <maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:cdsReference</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:Priority</name> <dataType maxSize=\"8\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>L1</allowedValue> <allowedValue>L2</allowedValue> <allowedValue>L3</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field> <field><name>srs:priority@orderedValue</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+    "<allowedValueRange> <minimum>1</minimum> <maximum>64</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredPriority</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority@type</name> <valueList>"
+    "<value>PREDEF</value> </valueList>"
+    "</dependentField> <allowedValueList>"
+    "<allowedValue>DEFAULT</allowedValue> <allowedValue>L1</allowedValue> <allowedValue>L2</allowedValue> <allowedValue>L3</allowedValue> <allowedValue>HIGHEST</allowedValue> <allowedValue>LOWEST</allowedValue> <allowedValue>L1_HI</allowedValue> <allowedValue>L1_LO</allowedValue> <allowedValue>L2_HI</allowedValue> <allowedValue>L2_LO</allowedValue> <allowedValue>L3_HI</allowedValue> <allowedValue>L3_LO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority@type</name> <valueList>"
+    "<value>OBJECTID</value> </valueList>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredPriority@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredPriority</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>PREDEF</allowedValue>"
+    "<allowedValue>OBJECTID</allowedValue> </allowedValueList></allowedValueDescriptor> </field>"
+    "<field> <name>srs:recordDestination</name> <dataType maxSize=\"1024\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>Hard Disk 1</allowedValue> <allowedValue>Hard Disk 2</allowedValue> <allowedValue>DVD Drive</allowedValue> <allowedValue>Remote Media Jukebox</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordDestination@mediaType</name> <dataType csv=\"xsd:string\" maxSize=\"16\">xsd:string</dataType> <maxCountTotal>3</maxCountTotal> <minListSizeTotal>1</minListSizeTotal> <maxListSizeTotal>4</maxListSizeTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> "
+    "<valueList><value>HardDisk 1</value><value>HardDisk 2</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <allowedValueList>"
+    "<allowedValue>HDD</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <valueList>"
+    "<value>DVD Drive</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+    "<allowedValue>DVD+RW</allowedValue> <allowedValue>DVD-RW</allowedValue> <allowedValue>DVD-R</allowedValue> <allowedValue>DVD+R</allowedValue> <allowedValue>CD-R</allowedValue> <allowedValue>CD-RW</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> "
+    /*"<allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name><valueList> <value>Remote Media Jukebox</value>"
+    "</valueList> </dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>2</maxListSize> <allowedValueList>"
+    "<allowedValue>CD-R</allowedValue>"
+    "<allowedValue>CD-RW</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor>"*/
+    "</field>"
+    "<field> <name>srs:recordDestination@targetURL</name> <dataType>xsd:anyURI</dataType> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordDestination@preference</name> <dataType>xsd:unsignedInt</dataType> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordDestination</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueRange>"
+    "<minimum>1</minimum> <maximum>3</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredRecordQuality</name> <dataType csv=\"xsd:string\" maxSize=\"1024\">xsd:string</dataType> <maxListSizeTotal>UNBOUNDED</maxListSizeTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>DEFAULT</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList><allowedValue>HD</allowedValue> <allowedValue>ED</allowedValue> <allowedValue>SD</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>ATSC</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>11</maxListSize> <allowedValueList>"
+    "<allowedValue>1080p30</allowedValue> <allowedValue>1080p24</allowedValue> <allowedValue>1080i60</allowedValue> <allowedValue>720p60</allowedValue> <allowedValue>720p30</allowedValue> <allowedValue>720p24</allowedValue> <allowedValue>480p60</allowedValue> <allowedValue>480p30</allowedValue> <allowedValue>480p24</allowedValue> <allowedValue>480i60</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+    "<value>QLEVEL</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+    "<allowedValue>Q1</allowedValue> <allowedValue>Q2</allowedValue> <allowedValue>Q3</allowedValue> <allowedValue>AUTO</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:desiredRecordQuality@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:desiredRecordQuality</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList><allowedValue>DEFAULT</allowedValue> <allowedValue>ATSC</allowedValue> <allowedValue>QLEVEL</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordScheduleID</name> <dataType maxSize=\"256\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordedCDSObjectID</name> <dataType maxSize=\"8192\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordedCDSObjectID@link</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordedCDSObjectID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskCDSObjectID</name> <dataType maxSize=\"8192\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskCDSObjectID@link</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskCDSObjectID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskChannelID</name> <dataType maxSize=\"256\">xsd:string</dataType><minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskChannelID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskChannelID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>ANALOG</allowedValue> <allowedValue>DIGITAL</allowedValue> <allowedValue>FREQUENCY</allowedValue> <allowedValue>SI</allowedValue> <allowedValue>LINE</allowedValue> <allowedValue>NETWORK</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskChannelID@distriNetworkName</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskChannelID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskChannelID@distriNetworkID</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskChannelID</name> <anyValue></anyValue>"
+    "</dependentField>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskStartDateTime</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field> <field><name>srs:taskDuration</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskProgramCode</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskProgramCode@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskProgramCode</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:recordQuality</name> <dataType maxSize=\"16\">xsd:string</dataType> <minCountTotal>3</minCountTotal> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>DEFAULT</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>IDLE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>HD</allowedValue> <allowedValue>ED</allowedValue> <allowedValue>SD</allowedValue> <allowedValue>UNKNOWN</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>DEFAULT</value></valueList> </dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>ACTIVE</value>"
+    "<value>DONE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>HD</allowedValue> <allowedValue>ED</allowedValue> <allowedValue>SD</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>ATSC</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>IDLE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>1080p30</allowedValue> <allowedValue>1080p24</allowedValue> <allowedValue>1080i60</allowedValue> <allowedValue>720p60</allowedValue> <allowedValue>720p30</allowedValue> <allowedValue>720p24</allowedValue> <allowedValue>480p60</allowedValue> <allowedValue>480p30</allowedValue> <allowedValue>480p24</allowedValue> <allowedValue>480i60</allowedValue> <allowedValue>UNKNOWN</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>ATSC</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>ACTIVE</value>"
+    "<value>DONE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList><allowedValue>1080p30</allowedValue> <allowedValue>1080p24</allowedValue> <allowedValue>1080i60</allowedValue> <allowedValue>720p60</allowedValue> <allowedValue>720p30</allowedValue> <allowedValue>720p24</allowedValue> <allowedValue>480p60</allowedValue> <allowedValue>480p30</allowedValue> <allowedValue>480p24</allowedValue> <allowedValue>480i60</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>QLEVEL</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>IDLE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>Q1</allowedValue> <allowedValue>Q2</allowedValue> <allowedValue>Q3</allowedValue> <allowedValue>UNKNOWN</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:recordQuality@type</name> <valueList>"
+    "<value>QLEVEL</value> </valueList>"
+    "</dependentField> <dependentField>"
+    "<name>srs:taskState@phase</name> <valueList>"
+    "<value>ACTIVE</value>"
+    "<value>DONE</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>Q1</allowedValue> <allowedValue>Q2</allowedValue> <allowedValue>Q3</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:recordQuality@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor><dependentField> <name>srs:recordQuality</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>3</minCount> <maxCount>3</maxCount> <allowedValueList>"
+    "<allowedValue>DEFAULT</allowedValue> <allowedValue>ATSC</allowedValue> <allowedValue>QLEVEL</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    /*"<field> <name>srs:matchedName</name> <dataType maxSize=\"128\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchedName@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedName</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>PROGRAM</allowedValue>"
+    "<allowedValue>SERIES</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:matchedID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchedID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedID</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>SI_PROGRAMID</allowedValue>"
+    "<allowedValue>SI_SERIESID</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor></field>"
+    "<field> <name>srs:matchedRating</name> <dataType maxSize=\"16\">xsd:string</dataType> <maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedRating@type</name> <valueList>"
+    "<value>MPAA.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>G</allowedValue> <allowedValue>PG</allowedValue> <allowedValue>PG-13</allowedValue> <allowedValue>R</allowedValue> <allowedValue>NC-17</allowedValue> <allowedValue>NR</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedRating@type</name> <valueList>"
+    "<value>RIAA.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue></allowedValue>"
+    "<allowedValue>PA-EC</allowedValue> </allowedValueList>"
+    "</allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedRating@type</name> <valueList>"
+    "<value>ESRB.ORG</value> </valueList>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>EC</allowedValue> <allowedValue>E</allowedValue> <allowedValue>E10+</allowedValue> <allowedValue>T</allowedValue> <allowedValue>M</allowedValue> <allowedValue>AO</allowedValue> <allowedValue>RP</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedRating@type</name> <valueList>"
+    "<value>TVGUIDELINES.ORG</value> </valueList></dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>TV-Y</allowedValue> <allowedValue>TV-Y7</allowedValue> <allowedValue>TV-Y7FV</allowedValue> <allowedValue>TV-G</allowedValue> <allowedValue>TV-PG</allowedValue> <allowedValue>TV-14</allowedValue> <allowedValue>TV-MA</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchedRating@type</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:matchedRating</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>MPAA.ORG</allowedValue> <allowedValue>RIAA.ORG</allowedValue> <allowedValue>ESRB.ORG</allowedValue> <allowedValue>TVGUIDLINES.ORG</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:matchedEpisodeType</name> <dataType maxSize=\"8\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>ALL</allowedValue> <allowedValue>FIRST_RUN</allowedValue> <allowedValue>REPEAT</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"*/
+    "<field> <name>srs:taskStartDateTimeAdjust</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskDurationAdjust</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field> <name>srs:taskDurationLimit</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskDurationLimit@effect</name> <dataType maxSize=\"8\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskDurationLimit</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>FIRST</allowedValue> <allowedValue>LAST</allowedValue> <allowedValue>SKIP</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskChannelMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskTimeMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+    "<allowedValueList> <allowedValue>IDLE.READY</allowedValue> <allowedValue>IDLE.ATRISK</allowedValue> "
+    "<allowedValue>ACTIVE.TRANSITION.FROMSTART</allowedValue> <allowedValue>ACTIVE.TRANSITION.RESTART</allowedValue> "
+    "<allowedValue>ACTIVE.RECORDING.FROMSTART.OK</allowedValue> <allowedValue>ACTIVE.RECORDING.FROMSTART.ATRISK</allowedValue> "
+    "<allowedValue>ACTIVE.RECORDING.RESTART.OK</allowedValue><allowedValue>ACTIVE.RECORDING.RESTART.ATRISK</allowedValue> "
+    "<allowedValue>ACTIVE.NOTRECORDING</allowedValue> <allowedValue>DONE.FULL</allowedValue> <allowedValue>DONE.PARTIAL</allowedValue> <allowedValue>DONE.EMPTY</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState@phase</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue>IDLE</allowedValue> <allowedValue>ACTIVE</allowedValue> <allowedValue>DONE</allowedValue>"
+    "</allowedValueList> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState@startDateTimeMet</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@endDateTimeMet</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@recording</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name><anyValue></anyValue> </dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@someBitRecorded</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@someBitsMissing</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@firstBitsRecorded</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@lastBitsRecorded</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field><name>srs:taskState@fatalError</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+    "</allowedValueDescriptor> </field>"
+    "<field> <name>srs:taskState@currentErrors</name> <dataType csv=\"xsd:int\" maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue></allowedValue> <allowedValue>100</allowedValue> <allowedValue>101</allowedValue> <allowedValue>102</allowedValue> <!-- Additional vendor defined values go hear -->"
+    "</allowedValueList> <allowedValueRange>"
+    "<minimum>200</minimum> <maximum>204</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>300</minimum> <maximum>307</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>400</minimum> <maximum>404</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState@errorHistory</name> <dataType csv=\"xsd:int\" maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue></allowedValue> <allowedValue>100</allowedValue> <allowedValue>101</allowedValue> <allowedValue>102</allowedValue>"
+    "<!-- Additional vendor defined values go here --> </allowedValueList> <allowedValueRange>"
+    "<minimum>200</minimum> <maximum>204</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>300</minimum> <maximum>307</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>400</minimum> <maximum>404</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState@pendingErrors</name> <dataType csv=\"xsd:int\" maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name> <anyValue></anyValue>"
+    "</dependentField> <minCount>1</minCount> <allowedValueList>"
+    "<allowedValue></allowedValue> <allowedValue>100</allowedValue> <allowedValue>101</allowedValue> <allowedValue>102</allowedValue> <!-- Additional vendor defined values go here -->"
+    "</allowedValueList> <allowedValueRange>"
+    "<minimum>200</minimum> <maximum>204</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>300</minimum> <maximum>307</maximum> <step>1</step>"
+    "</allowedValueRange> <allowedValueRange>"
+    "<minimum>400</minimum> <maximum>404</maximum> <step>1</step>"
+    "</allowedValueRange> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:taskState@infoList</name> <dataType csv=\"xsd:int\" maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<dependentField> <name>srs:taskState</name><anyValue></anyValue>"
+    "</dependentField>"
+    "<minCount>1</minCount>"
+    "<allowedValueList>"
+    "<allowedValue></allowedValue>"
+    "<allowedValue>100</allowedValue>"
+    "<allowedValue>101</allowedValue>"
+    "<allowedValue>102</allowedValue>"
+    "<!-- Additional vendor defined values go here -->"
+    "</allowedValueList>"
+    "<allowedValueRange>"
+    "<minimum>200</minimum>"
+    "<maximum>204</maximum>"
+    "<step>1</step>"
+    "</allowedValueRange>"
+    "<allowedValueRange>"
+    "<minimum>300</minimum>"
+    "<maximum>307</maximum>"
+    "<step>1</step>"
+    "</allowedValueRange>"
+    "<allowedValueRange>"
+    "<minimum>400</minimum>"
+    "<maximum>404</maximum>"
+    "<step>1</step>"
+    "</allowedValueRange>"
+    "</allowedValueDescriptor>"
+    "</field>"
+    "</fieldTable></AVDT>";
+
+const QString UPnpSRS::recordSchedulePartsAllowedValuesXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "
+    "<AVDT xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:srs=\"urn:schemas-upnp-org:av:srs\" "
+    "xmlns=\"urn:schemas-upnp-org:av:avdt\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" "
+    "urn:schemas-upnp-org:av:srs http://www.upnp.org/schemas/av/srs.xsd "
+    "urn:schemas-upnp-org:av:avdt http://www.upnp.org/schemas/av/avdt.xsd\">"
+    "<contextID>uuid:device-UUID::urn:schemas-upnp-org:service:ScheduledRecording:1 </contextID>"
+    "<dataStructType>A_ARG_TYPE_RecordScheduleParts</dataStructType> "
+    "<fieldTable><field> "
+        "<name>srs:@id</name> <dataType maxSize=\"256\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+        "<allowedValueList> <allowedValue></allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field> "
+        "<name>srs:title</name> <dataType maxSize=\"128\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field> "
+        "<name>srs:class</name> <dataType maxSize=\"64\">xsd:string</dataType> <minCountTotal>1</minCountTotal> <allowedValueDescriptor>"
+        "<allowedValueList> <allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</allowedValue> "
+        "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</allowedValue> "
+        "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</allowedValue> "
+        "<allowedValue>OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE</allowedValue> "
+        /*
+        //not implemented
+        "<allowedValue>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</allowedValue> "
+        "<allowedValue>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</allowedValue> "
+        */
+        "</allowedValueList>"
+        "</allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:desiredPriority</name> <dataType maxSize=\"1024\">xsd:string</dataType> "
+        "<allowedValueDescriptor>"
+            "<dependentField defaultDependency=\"1\"> <name>srs:desiredPriority@type</name> <valueList>"
+            "<value>PREDEF</value> </valueList>"
+            "</dependentField> <minCount>1</minCount> <defaultValue>DEFAULT</defaultValue>"
+            "<allowedValueList> <allowedValue>DEFAULT</allowedValue> <allowedValue>L1</allowedValue> <allowedValue>L2</allowedValue> "
+            "<allowedValue>L3</allowedValue> <allowedValue>HIGHEST</allowedValue> <allowedValue>LOWEST</allowedValue> "
+            "<allowedValue>L1_HI</allowedValue> <allowedValue>L1_LO</allowedValue> <allowedValue>L2_HI</allowedValue> "
+            "<allowedValue>L2_LO</allowedValue> <allowedValue>L3_HI</allowedValue> <allowedValue>L3_LO</allowedValue>"
+            "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+            "<dependentField> <name>srs:desiredPriority@type</name> <valueList>"
+            "<value>OBJECTID</value> </valueList>"
+            "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:desiredPriority@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:desiredPriority</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <defaultValue>PREDEF</defaultValue> <allowedValueList>"
+        "<allowedValue>PREDEF</allowedValue>"
+        "<allowedValue>OBJECTID</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:recordDestination</name> <dataType maxSize=\"1024\">xsd:string</dataType> <maxCountTotal>3</maxCountTotal> "
+        "<allowedValueDescriptor><defaultValue>Hard Disk</defaultValue> <allowedValueList>"
+        "<allowedValue>Hard Disk 1</allowedValue><allowedValue>Hard Disk 2</allowedValue> "
+        /*"<allowedValue>DVD Drive</allowedValue> <allowedValue>Remote Media Jukebox</allowedValue>"*/
+        "</allowedValueList> "
+        "</allowedValueDescriptor>"
+    "</field><field> "
+        "<name>srs:recordDestination@mediaType</name> <dataType csv=\"xsd:string\" maxSize=\"16\">xsd:string</dataType> "
+        "<maxCountTotal>3</maxCountTotal> <maxListSizeTotal>4</maxListSizeTotal> "
+        "<allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:recordDestination</name> "
+        "<valueList>"
+        "<value>HardDisk 1</value>"
+        "<value>HardDisk 2</value> "
+        "</valueList>"
+        "</dependentField> <maxListSize>1</maxListSize> <defaultValue>HDD</defaultValue> "
+        "<allowedValueList><allowedValue>HDD</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor> "
+        "<allowedValueDescriptor>"
+        "<dependentField> <name>srs:recordDestination</name> <valueList>"
+        "<value>DVD Drive</value> </valueList>"
+        "</dependentField> <maxListSize>4</maxListSize> <allowedValueList>"
+        "<allowedValue>DVD+RW</allowedValue> <allowedValue>DVD-RW</allowedValue> <allowedValue>DVD-R</allowedValue> "
+        "<allowedValue>DVD+R</allowedValue> <allowedValue>CD-R</allowedValue> <allowedValue>CD-RW</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor> "
+        /*"<allowedValueDescriptor><dependentField> <name>srs:recordDestination</name> <valueList>"
+        "<value>Network Jukebox Recorder</value> </valueList>"
+        "</dependentField> "
+        "<maxListSize>2</maxListSize> <defaultValue>CD-R</defaultValue> <allowedValueList>"
+        "<allowedValue>CD-R</allowedValue>"
+        "<allowedValue>CD-RW</allowedValue> </allowedValueList></allowedValueDescriptor> "*/
+    "</field><field>"
+        "<name>srs:recordDestination@targetURL</name> <dataType>xsd:anyURI</dataType> <maxCountTotal>3</maxCountTotal>"
+        "<allowedValueDescriptor><dependentField> <name>srs:recordDestination</name> <anyValue></anyValue></dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:recordDestination@preference</name> <dataType>xsd:unsignedInt</dataType> <maxCountTotal>3</maxCountTotal>"
+        "<allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:recordDestination</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>2</defaultValue> <allowedValueRange>"
+        "<minimum>1</minimum> <maximum>3</maximum> <step>1</step>"
+        "</allowedValueRange> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:desiredRecordQuality</name> <dataType csv=\"xsd:string\" maxSize=\"1024\">xsd:string</dataType>"
+        "<maxListSizeTotal>UNBOUNDED</maxListSizeTotal> "
+        "<allowedValueDescriptor><dependentField defaultDependency=\"1\">"
+            " <name>srs:desiredRecordQuality@type</name>  <valueList> <value>DEFAULT</value> </valueList>"
+            "</dependentField> "
+            "<minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <defaultValue>AUTO</defaultValue>"
+            "<allowedValueList><allowedValue>HD</allowedValue> <allowedValue>ED</allowedValue> <allowedValue>SD</allowedValue>"
+            "<allowedValue>AUTO</allowedValue>"
+            "</allowedValueList> </allowedValueDescriptor>"
+        "<allowedValueDescriptor>"
+        "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+        "<value>ATSC</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>11</maxListSize> "
+        "<allowedValueList>"
+        "<allowedValue>1080p30</allowedValue> <allowedValue>1080p24</allowedValue> <allowedValue>1080i60</allowedValue>"
+        "<allowedValue>720p60</allowedValue> <allowedValue>720p30</allowedValue> <allowedValue>720p24</allowedValue> "
+        "<allowedValue>480p60</allowedValue> <allowedValue>480p30</allowedValue> <allowedValue>480p24</allowedValue> "
+        "<allowedValue>480i60</allowedValue> <allowedValue>AUTO</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:desiredRecordQuality@type</name> <valueList>"
+        "<value>QLEVEL</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <minListSize>1</minListSize> <maxListSize>4</maxListSize> <allowedValueList>"
+        "<allowedValue>Q1</allowedValue> <allowedValue>Q2</allowedValue> <allowedValue>Q3</allowedValue> <allowedValue>AUTO</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:desiredRecordQuality@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:desiredRecordQuality</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <defaultValue>DEFAULT</defaultValue> <allowedValueList>"
+        "<allowedValue>DEFAULT</allowedValue> <allowedValue>ATSC</allowedValue> <allowedValue>QLEVEL</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:scheduledCDSObjectID</name> <dataType maxSize=\"1024\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+        "</dependentField> <minCount>1</minCount><allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:scheduledChannelID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:scheduledChannelID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <allowedValueList>"
+        "<allowedValue>ANALOG</allowedValue> <allowedValue>DIGITAL</allowedValue> <allowedValue>FREQUENCY</allowedValue> <allowedValue>SI</allowedValue> <allowedValue>LINE</allowedValue> <allowedValue>NETWORK</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:scheduledChannelID@distriNetworkName</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+        "</dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:scheduledChannelID@distriNetworkID</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:scheduledChannelID</name> <anyValue></anyValue>"
+        "</dependentField> <allowAny></allowAny></allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:scheduledStartDateTime</name> <dataType maxSize=\"64\">xsd:string</dataType> <maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:scheduledDuration</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:scheduledProgramCode</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.PROGRAMCODE</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor> "
+    "</field><field>"
+        "<name>srs:scheduledProgramCode@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:scheduledProgramCode</name> <anyValue></anyValue></dependentField> <minCount>1</minCount>"
+        " <allowAny></allowAny></allowedValueDescriptor> "
+    "</field>"
+    /*"<field>"
+        "<name>srs:matchingName</name> <dataType maxSize=\"128\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> </valueList>"
+        "</dependentField> <minCount>1</minCount> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field> <name>srs:matchingName@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingName</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <allowedValueList>"
+        "<allowedValue>PROGRAM</allowedValue>"
+        "<allowedValue>SERIES</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingName@subStringMatch</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingName</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>1</defaultValue> <allowAny></allowAny></allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField><minCount>1</minCount>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field> <field>"
+        "<name>srs:matchingID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingID</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <allowedValueList>"
+        "<allowedValue>SI_PROGRAMID</allowedValue>"
+        "<allowedValue>SI_SERIESID</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingChannelID</name> <dataType maxSize=\"256\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> </valueList>"
+        "</dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingChannelID@type</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingChannelID</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <allowedValueList>"
+        "<allowedValue>ANALOG</allowedValue> <allowedValue>DIGITAL</allowedValue> <allowedValue>FREQUENCY</allowedValue> <allowedValue>SI</allowedValue> <allowedValue>LINE</allowedValue> <allowedValue>NETWORK</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingChannelID@distriNetworkName</name> <dataType maxSize=\"32\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField><name>srs:matchingChannelID</name>"
+        "<anyValue></anyValue> </dependentField> <allowAny></allowAny>"
+        "</allowedValueDescriptor>
+    "</field><field>"
+        <name>srs:matchingChannelID@distriNetworkID</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingChannelID</name> <anyValue></anyValue>"
+        "</dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingStartDateTimeRange</name> <dataType maxSize=\"64\">xsd:string</dataType> <maxCountTotal>3</maxCountTotal> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingDurationRange</name> <dataType maxSize=\"16\">xsd:string</dataType> <maxCountTotal>4</maxCountTotal>
+        "<allowedValueDescriptor><dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingRatingLimit</name> <dataType maxSize=\"16\">xsd:string</dataType> <maxCountTotal>2</maxCountTotal>"
+        "<allowedValueDescriptor> <dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value><value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value></valueList>"
+        "</dependentField> <dependentField>"
+        "<name>srs:matchingRatingLimit@type</name> <valueList>"
+        "<value>MPAA.ORG</value> </valueList>"
+        "</dependentField> <allowedValueList>"
+        "<allowedValue>G</allowedValue> <allowedValue>PG</allowedValue> <allowedValue>PG-13</allowedValue>
+        "<allowedValue>R</allowedValue> <allowedValue>NC-17</allowedValue> <allowedValue>NR</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField> <dependentField>"
+        "<name>srs:matchingRatingLimit@type</name> <valueList>"
+        "<value>RIAA.ORG</value> </valueList>"
+        "</dependentField> <allowedValueList>"
+        "<allowedValue></allowedValue>"
+        "<allowedValue>PA-EC</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField> <dependentField>"
+        "<name>srs:matchingRatingLimit@type</name> <valueList>"
+        "<value>ESRB.ORG</value> </valueList>"
+        "</dependentField> <allowedValueList>"
+        "<allowedValue>EC</allowedValue> <allowedValue>E</allowedValue> <allowedValue>E10+</allowedValue>
+        "<allowedValue>T</allowedValue> <allowedValue>M</allowedValue> <allowedValue>AO</allowedValue>
+        "<allowedValue>RP</allowedValue>"
+        "</allowedValueList></allowedValueDescriptor> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField> <dependentField>"
+        "<name>srs:matchingRatingLimit@type</name> <valueList>"
+        "<value>TVGUIDELINES.ORG</value> </valueList>"
+        "</dependentField> <allowedValueList>"
+        "<allowedValue>TV-Y</allowedValue> <allowedValue>TV-Y7</allowedValue> <allowedValue>TV-Y7FV</allowedValue>
+        "<allowedValue>TV-G</allowedValue> <allowedValue>TV-PG</allowedValue> <allowedValue>TV-14</allowedValue>
+        "<allowedValue>TV-MA</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingRatingLimit@type</name> <dataType maxSize=\"32\">xsd:string</dataType>
+        "<maxCountTotal>2</maxCountTotal> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:matchingRatingLimit</name> <anyValue></anyValue>"
+        "</dependentField> <minCount>1</minCount> <allowedValueList>"
+        "<allowedValue>MPAA.ORG</allowedValue> <allowedValue>RIAA.ORG</allowedValue>
+        "<allowedValue>ESRB.ORG</allowedValue> <allowedValue>TVGUIDLINES.ORG</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:matchingEpisodeType</name> <dataType maxSize=\"8\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField> <allowedValueList>"
+        "<allowedValue>ALL</allowedValue> <allowedValue>FIRST_RUN</allowedValue><allowedValue>REPEAT</allowedValue> </allowedValueList>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:totalDesiredRecordTasks</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+        "<defaultValue>1</defaultValue>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"
+    "<field> <name>srs:scheduledStartDateTimeAdjust</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+    "<defaultValue>+P00:00:00</defaultValue>"
+    "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field>"*/
+    "<field>"
+        "<name>srs:scheduledDurationAdjust</name> <dataType maxSize=\"16\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<defaultValue>+P00:00:00</defaultValue>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:activePeriod</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.MANUAL</value> <value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value> <value>OBJECT.RECORDSCHEDULE.DIRECT.CDSNONEPG</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"
+        "</valueList> </dependentField> <defaultValue>NOW/INFINITY</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:durationLimit</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+        /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value><value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+        "</valueList>"
+        "</dependentField> <defaultValue>INFINITY</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:durationLimit@effect</name> <dataType maxSize=\"8\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:durationLimit</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>FIRST</defaultValue> <allowedValueList>"
+        "<allowedValue>FIRST</allowedValue> <allowedValue>LAST</allowedValue> <allowedValue>SKIP</allowedValue>"
+        "</allowedValueList> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:channelMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value> "
+        /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+        "</valueList> </dependentField> <defaultValue>1</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:timeMigration</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.DIRECT.CDSEPG</value>"
+        /*"<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value> <value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value>"*/
+        "</valueList> </dependentField> <defaultValue>1</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field>"
+    /*"<field>"
+        "<name>srs:allowDuplicates</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField> <name>srs:class</name> <valueList>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTNAME</value>"
+        "<value>OBJECT.RECORDSCHEDULE.QUERY.CONTENTID</value> </valueList>"
+        "</dependentField> <defaultValue>1</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field>"*/
+    "<field>"
+        "<name>srs:persistedRecordings</name> <dataType>xsd:unsignedInt</dataType> <allowedValueDescriptor>"
+        "<defaultValue>0</defaultValue>"
+        "<allowAny></allowAny> </allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:persistedRecordings@latest</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>1</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:persistedRecordings@preAllocation</name> <dataType>xsd:boolean</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>0</defaultValue> <allowAny></allowAny>"
+        "</allowedValueDescriptor>"
+    "</field><field>"
+        "<name>srs:persistedRecordings@storedLifetime</name> <dataType maxSize=\"64\">xsd:string</dataType> <allowedValueDescriptor>"
+        "<dependentField defaultDependency=\"1\"> <name>srs:persistedRecordings</name> <anyValue></anyValue>"
+        "</dependentField> <defaultValue>ANY</defaultValue> <allowAny></allowAny></allowedValueDescriptor>"
+    "</field></fieldTable> </AVDT>";
Index: programs/mythbackend/mainserver.h
===================================================================
--- programs/mythbackend/mainserver.h	(revision 4503)
+++ programs/mythbackend/mainserver.h	(working copy)
@@ -254,6 +254,18 @@
     RequestedBy                m_previewRequestedBy;
 
     static const uint kMasterServerReconnectTimeout;
+    
+    //for access to encoderList and scheduler
+    friend class UPnpAVT;
+
+    //global instance pointer for easier access to UPnP classes
+  private:
+    static MainServer* mainServer;
+
+  public:
+    static void         SetInstance ( MainServer *pMainServer ) { MainServer::mainServer = pMainServer; }
+    static MainServer  *GetInstance () { return MainServer::mainServer; }
+    static Scheduler   *GetScheduler() { return (MainServer::mainServer ? MainServer::mainServer->m_sched : NULL); }
 };
 
 #endif
Index: programs/mythbackend/AVT_scpd.xml
===================================================================
--- programs/mythbackend/AVT_scpd.xml	(revision 0)
+++ programs/mythbackend/AVT_scpd.xml	(revision 0)
@@ -0,0 +1,671 @@
+<?xml version="1.0" encoding="utf-8"?>
+<scpd xmlns="urn:schemas-upnp-org:service-1-0">
+<specVersion>
+  <major>1</major>
+  <minor>0</minor>
+</specVersion>
+	<actionList>
+		<action>
+			<name>SetAVTransportURI</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>in</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetNextAVTransportURI</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURI</name>
+					<direction>in</direction>
+					<relatedStateVariable>NextAVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURIMetaData</name>
+					<direction>in</direction>
+					<relatedStateVariable>NextAVTransportURIMetaData</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMediaInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NrTracks</name>
+					<direction>out</direction>
+					<relatedStateVariable>NumberOfTracks</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>MediaDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentMediaDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>PlaybackStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecordMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>WriteStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordMediumWriteStatus</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetMediaInfo_Ext</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentType</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentMediaCategory</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NrTracks</name>
+					<direction>out</direction>
+					<relatedStateVariable>NumberOfTracks</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>MediaDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentMediaDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>AVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NextURIMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>NextAVTransportURIMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>PlaybackStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecordMedium</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordStorageMedium</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>WriteStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>RecordMediumWriteStatus</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportState</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportState</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentTransportStatus</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportStatus</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentSpeed</name>
+					<direction>out</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetPositionInfo</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Track</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrack</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackDuration</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackDuration</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackMetaData</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackMetaData</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>TrackURI</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTrackURI</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsTime</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteTimePosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RelCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>RelativeCounterPosition</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AbsCount</name>
+					<direction>out</direction>
+					<relatedStateVariable>AbsoluteCounterPosition</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetDeviceCapabilities</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossiblePlaybackStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecMedia</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordStorageMedia</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityModes</name>
+					<direction>out</direction>
+					<relatedStateVariable>PossibleRecordQualityModes</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetTransportSettings</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>PlayMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentPlayMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>RecQualityMode</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentRecordQualityMode</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Stop</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Play</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Speed</name>
+					<direction>in</direction>
+					<relatedStateVariable>TransportPlaySpeed</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Pause</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Record</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Seek</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Unit</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekMode</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Target</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_SeekTarget</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Next</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>Previous</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetPlayMode</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NewPlayMode</name>
+					<direction>in</direction>
+					<relatedStateVariable>CurrentPlayMode</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetRecordQualityMode</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>NewRecordQualityMode</name>
+					<direction>in</direction>
+					<relatedStateVariable>CurrentRecordQualityMode</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetCurrentTransportActions</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>Actions</name>
+					<direction>out</direction>
+					<relatedStateVariable>CurrentTransportActions</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetDRMState</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>CurrentDRMState</name>
+					<direction>out</direction>
+					<relatedStateVariable>DRMState</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>GetStateVariables</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>StateVariableList</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_StateVariableList</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>StateVariableValuePairs</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_StateVariableValuePairs</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+		<action>
+			<name>SetStateVariables</name>
+			<argumentList>
+				<argument>
+					<name>InstanceID</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_InstanceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>AVTransportUDN</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_DeviceUDN</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>ServiceType</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_ServiceType</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>ServiceId</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_ServiceID</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>StateVariableValuePairs</name>
+					<direction>in</direction>
+					<relatedStateVariable>A_ARG_TYPE_StateVariableValuePairs</relatedStateVariable>
+				</argument>
+				<argument>
+					<name>StateVariableList</name>
+					<direction>out</direction>
+					<relatedStateVariable>A_ARG_TYPE_StateVariableList</relatedStateVariable>
+				</argument>
+			</argumentList>
+		</action>
+	</actionList>
+	<serviceStateTable>
+	        <stateVariable sendEvents="no">
+			<name>TransportState</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>STOPPED</allowedValue>
+				<allowedValue>PLAYING</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>TransportStatus</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>OK</allowedValue>
+				<allowedValue>ERROR_OCCURRED</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentMediaCategory</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>NO_MEDIA</allowedValue>
+				<allowedValue>TRACK_AWARE</allowedValue>
+				<allowedValue>TRACK_UNAWARE</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>PlaybackStorageMedium</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>RecordStorageMedium</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>PossiblePlaybackStorageMedia</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>PossibleRecordStorageMedia</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentPlayMode</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>NORMAL</allowedValue>
+			</allowedValueList>
+			<defaultValue>NORMAL</defaultValue>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>TransportPlaySpeed</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>1</allowedValue>
+			</allowedValueList>
+			<defaultValue>1</defaultValue>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>RecordMediumWriteStatus</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentRecordQualityMode</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>PossibleRecordQualityModes</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>NumberOfTracks</name>
+			<dataType>ui4</dataType>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1000000</maximum>
+			</allowedValueRange>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentTrack</name>
+			<dataType>ui4</dataType>
+			<allowedValueRange>
+				<minimum>0</minimum>
+				<maximum>1000000</maximum>
+				<step>1</step>
+			</allowedValueRange>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentTrackDuration</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentMediaDuration</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentTrackMetaData</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentTrackURI</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>AVTransportURI</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>AVTransportURIMetaData</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>NextAVTransportURI</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>NextAVTransportURIMetaData</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>RelativeTimePosition</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>AbsoluteTimePosition</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>RelativeCounterPosition</name>
+			<dataType>i4</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>AbsoluteCounterPosition</name>
+			<dataType>i4</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>CurrentTransportActions</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="yes">
+			<name>LastChange</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="yes">
+			<name>DRMState</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>OK</allowedValue>
+			</allowedValueList>
+			<defaultValue>UNKNOWN</defaultValue>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekMode</name>
+			<dataType>string</dataType>
+			<allowedValueList>
+				<allowedValue>TRACK_NR</allowedValue>
+			</allowedValueList>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_SeekTarget</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_InstanceID</name>
+			<dataType>ui4</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_DeviceUDN</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ServiceType</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_ServiceID</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_StateVariableValuePairs</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	        <stateVariable sendEvents="no">
+			<name>A_ARG_TYPE_StateVariableList</name>
+			<dataType>string</dataType>
+		</stateVariable>
+	</serviceStateTable>
+</scpd>
Index: programs/mythbackend/upnpcdstv.cpp
===================================================================
--- programs/mythbackend/upnpcdstv.cpp	(revision 4503)
+++ programs/mythbackend/upnpcdstv.cpp	(working copy)
@@ -4,6 +4,7 @@
 // Purpose - uPnp Content Directory Extension for Recorded TV
 //
 // Created By  : David Blain                    Created On : Jan. 24, 2005
+// Modified By : Harold Sutherland              Modified On: Dec. 09, 2009
 // Modified By :                                Modified On:
 //
 //////////////////////////////////////////////////////////////////////////////
@@ -390,7 +391,7 @@
     }
 
     // DLNA string below is temp fix for ps3 seeking.
-    QString sProtocol = QString( "http-get:*:%1:DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01500000000000000000000000000000" ).arg( sMimeType  );
+    QString sProtocol = QString( "http-get:*:%1:DLNA.ORG_PN=MP3;DLNA.ORG_OP=01;DLNA.ORG_CI=0;DLNA.ORG_FLAGS=01500000000000000000000000000000" ).arg( sMimeType  );
     QString sURI      = QString( "%1GetRecording%2").arg( sURIBase   )
                                                     .arg( sURIParams );
 
Index: programs/mythbackend/upnpavt.h
===================================================================
--- programs/mythbackend/upnpavt.h	(revision 0)
+++ programs/mythbackend/upnpavt.h	(revision 0)
@@ -0,0 +1,283 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: UPnpAVT.cpp
+// Created     : June 29, 2009
+// Modified    : Jan 13, 2010
+//
+// Authors     : Kunal Kandekar, Harold Sutherland
+//
+// Purpose     : UPnP AVTransport Service
+//                                                                            
+// Copyright (c) 2010
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef UPnpAVT_H_
+#define UPnpAVT_H_
+
+#include "httpserver.h"
+#include "eventing.h"
+#include "mainserver.h"
+
+typedef enum 
+{
+    AVTM_Unknown                    =  0,
+    AVTM_SetAVTransportURI          =  1,
+    AVTM_SetNextAVTransportURI      =  2,
+    AVTM_GetMediaInfo               =  3,
+    AVTM_GetMediaInfo_Ext           =  4,
+    AVTM_GetTransportInfo           =  5,
+    AVTM_GetPositionInfo            =  6,
+    AVTM_GetDeviceCapabilities      =  7,
+    AVTM_GetTransportSettings       =  8,
+    AVTM_Stop                       =  9,
+    AVTM_Play                       = 10,
+    AVTM_Pause                      = 11,
+    AVTM_Record                     = 12,
+    AVTM_Seek                       = 13,
+    AVTM_Next                       = 14,
+    AVTM_Previous                   = 15,
+    AVTM_SetPlayMode                = 16,
+    AVTM_SetRecordQualityMode       = 17,
+    AVTM_GetCurrentTransportActions = 18,
+    AVTM_GetDRMState                = 19,
+    AVTM_GetStateVariables          = 20,
+    AVTM_SetStateVariables          = 21,
+    AVTM_GetServiceDescription      = 22
+} UPnpAVTMethod;
+
+//////////////////////////////////////////////////////////////////////////////
+
+typedef enum
+{
+    AVTSTATUS_Unknown               = 0,
+    AVTSTATUS_OK                    = 1,
+
+} UPnpAVTRecordingStatus;
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// UPnpAVTState Class Definition
+//
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpAVTState : public StateVariables
+{
+private:
+    const static QStringList NonLastChangeEvented;
+    QSet<QString> lastChangeSet;
+
+public:
+    UPnpAVTState (QString &sInstanceID);
+    virtual ~UPnpAVTState();
+
+    QString       GetLastChangeValues      ();
+    virtual void  Notify                   () { /* empty implementation */ }
+    SVMap         &GetSVMap                () { return m_map; }
+    void          AddAVTStateVariables     ();
+    void          SetAVTDefaultStateValues ();
+    //override parent class method and call it inside
+    template < class T >
+    bool          SetValue                ( const QString &sName, T value )
+    {
+        if (UPnpAVTState::IsEventedByLastChange(sName))
+            lastChangeSet.insert(sName);
+        return StateVariables::SetValue(sName, value);
+    }
+    QString       InstanceID;
+    QString       chainseed;
+    QString       hostname;
+    EncoderLink   *encoder;
+    LiveTVChain   *chain;
+    float         framerate;
+
+    static bool   IsEvented            ( const QString &sName ) { return ((sName != "LastChange") && !sName.startsWith("A_ARG_TYPE_")); }
+    static bool   IsEventedByLastChange( const QString &sName )
+    {
+        return (!NonLastChangeEvented.contains(sName) && !sName.startsWith("A_ARG_TYPE_"));
+    }
+
+    static void   MilliSecToDuration   ( int msec, QString &retVal )
+    {
+        int secs = (int) (msec / 1000);        //we don't support fractions of seconds
+        int hh   = (int) (secs / (60 * 60));
+        retVal   = QString("%1:%2:%3").arg(hh).arg((secs - (hh * 3600))/60).arg(secs % 60);
+    }
+
+    static int    DurationToMilliSec   ( QString &retVal )
+    {
+        if (retVal.contains('.'))    //we don't support fractions of seconds
+            retVal = retVal.section('.', 0);
+        QStringList list = retVal.split(':');
+        if (list.size() >= 3)
+            return ((list[0].toInt() * 3600) + (list[1].toInt() * 60) + list[2].toInt());
+        return 0;
+    }
+
+public:
+    static const QString AVTState_TransportState_STOPPED               ;
+    static const QString AVTState_TransportState_PLAYING               ;
+    static const QString AVTState_TransportState_TRANSITIONING         ;
+    static const QString AVTState_TransportState_PAUSED_PLAYBACK       ;
+    static const QString AVTState_TransportState_PAUSED_RECORDING      ;
+    static const QString AVTState_TransportState_RECORDING             ;
+    static const QString AVTState_TransportState_NO_MEDIA_PRESENT      ;
+    static const QString AVTState_TransportStatus_OK                   ;
+    static const QString AVTState_TransportStatus_ERROR_OCCURRED       ;
+    static const QString AVTState_CurrentMediaCategory_NO_MEDIA        ;
+    static const QString AVTState_CurrentMediaCategory_TRACK_AWARE     ;
+    static const QString AVTState_CurrentMediaCategory_TRACK_UNAWARE   ;
+    static const QString AVTState_PlaybackStorageMedium_HDD            ;
+    static const QString AVTState_PlaybackStorageMedium_NETWORK        ;
+    static const QString AVTState_RecordStorageMedium_HDD              ;
+    static const QString AVTState_CurrentPlayMode_DIRECT_1             ;
+    static const QString AVTState_RecordMediumWriteStatus_WRITABLE     ;
+    static const QString AVTState_PossiblePlaybackStorageMedia_LIVE_TV ;
+    static const QString AVTState_PossibleRecordStorageMedia_LIVE_TV   ;
+    static const QString AVTState_TransportPlaySpeed_1                 ;
+    static const QString AVTState_CurrentRecordQualityMode_0_EP        ;
+    static const QString AVTState_CurrentRecordQualityMode_1_LP        ;
+    static const QString AVTState_CurrentRecordQualityMode_2_SP        ;
+    static const QString AVTState_CurrentRecordQualityMode_0_BASIC     ;
+    static const QString AVTState_CurrentRecordQualityMode_1_MEDIUM    ;
+    static const QString AVTState_CurrentRecordQualityMode_2_HIGH      ;
+    static const QString AVTState_PossibleRecordQualityModes_LIVE_TV   ;
+    static const QString AVTState_CurrentTransportActions_PLAY         ;
+    static const QString AVTState_CurrentTransportActions_STOP         ;
+    static const QString AVTState_CurrentTransportActions_PAUSE        ;
+    static const QString AVTState_CurrentTransportActions_SEEK         ;
+    static const QString AVTState_CurrentTransportActions_NEXT         ;
+    static const QString AVTState_CurrentTransportActions_PREVIOUS     ;
+    static const QString AVTState_CurrentTransportActions_RECORD       ;
+    static const QString AVTState_CurrentTransportActions_LIVE_TV      ;
+    static const QString AVTState_DRMState_OK                          ;
+    static const QString AVTState_DRMState_UNKNOWN                     ;
+    static const QString AVTState_DRMState_PROCESSING_CONTENT_KEY      ;
+    static const QString AVTState_DRMState_CONTENT_KEY_FAILURE         ;
+    static const QString AVTState_DRMState_ATTEMPTING_AUTHENTICATION   ;
+    static const QString AVTState_DRMState_FAILED_AUTHENTICATION       ;
+    static const QString AVTState_DRMState_NOT_AUTHENTICATED           ;
+    static const QString AVTState_DRMState_DEVICE_REVOCATION           ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_TRACK_NR         ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_ABS_TIME         ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_REL_TIME         ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_ABS_COUNT        ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_REL_COUNT        ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_CHANNEL_FREQ     ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_TAPE_INDEX       ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_REL_TAPE_INDEX   ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_FRAME            ;
+    static const QString AVTState_A_ARG_TYPE_SeekMode_REL_FRAME        ;
+    static const QString AVTState_A_ARG_TYPE_STRING                    ;
+    static const QString AVTState_A_ARG_TYPE_UI4                       ;
+    static const QString AVTState_A_ARG_TYPE_I4                        ;
+    static const QString AVTState_A_ARG_TYPE_FLOAT                     ;
+    static const QString AVTState_A_ARG_TYPE_DURATION                  ;
+    static const QString AVTState_A_ARG_TYPE_ServiceType_AVTRANSPORT_2 ;
+    static const QString AVTState_A_ARG_TYPE_StateVariableList_ALL     ;
+    static const QString AVTState_Duration_00_00_00                    ;
+    static const QString AVTState_NOT_IMPLEMENTED                      ;
+};
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//
+// UPnpAVT Class Definition
+//
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpAVT : public Eventing
+{
+    private:
+
+        QString         m_sServiceDescFileName;
+        QString         m_sControlUrl;
+
+        //the following two are needed for running multiple virtual instances
+        static QMutex                        instanceStateMapLock;
+        static QHash<QString, UPnpAVTState*> m_mapInstanceIDState;
+
+        UPnpAVTMethod   GetMethod                        ( const QString &sURI   );
+
+        void            HandleSetAVTransportURI          ( HTTPRequest *pRequest );
+        void            HandleSetNextAVTransportURI      ( HTTPRequest *pRequest );
+        void            HandleGetMediaInfo               ( HTTPRequest *pRequest );
+        void            HandleGetMediaInfo_Ext           ( HTTPRequest *pRequest );
+        void            HandleGetTransportInfo           ( HTTPRequest *pRequest );
+        void            HandleGetPositionInfo            ( HTTPRequest *pRequest );
+        void            HandleGetDeviceCapabilities      ( HTTPRequest *pRequest );
+        void            HandleGetTransportSettings       ( HTTPRequest *pRequest );
+        void            HandleStop                       ( HTTPRequest *pRequest );
+        void            HandlePlay                       ( HTTPRequest *pRequest );
+        void            HandlePause                      ( HTTPRequest *pRequest );
+        void            HandleRecord                     ( HTTPRequest *pRequest );
+        void            HandleSeek                       ( HTTPRequest *pRequest );
+        void            HandleNext                       ( HTTPRequest *pRequest );
+        void            HandlePrevious                   ( HTTPRequest *pRequest );
+        void            HandleSetPlayMode                ( HTTPRequest *pRequest );
+        void            HandleSetRecordQualityMode       ( HTTPRequest *pRequest );
+        void            HandleGetCurrentTransportActions ( HTTPRequest *pRequest );
+        void            HandleGetDRMState                ( HTTPRequest *pRequest );
+        void            HandleGetStateVariables          ( HTTPRequest *pRequest );
+        void            HandleSetStateVariables          ( HTTPRequest *pRequest );
+
+
+        // MythTV internals-related functions
+
+        UPnpAVTState    *GetAVTState            ( QString       &sInstanceID );
+        UPnpAVTState    *CreateAVTState         ( QString       &sInstanceID );
+        int             DeleteAVTState          ( QString       &sInstanceID );
+
+        QString         GetChainSeedForClient   ( HTTPRequest   *pRequest,
+                                                  QString       &sInstanceID,
+                                                  QString       &sHostname   );
+
+        int             ProcessLiveTVRequest    ( const QString &sChanId,
+                                                  unsigned int  nSourceId,
+                                                  UPnpAVTState  *state       );
+
+        void            PopulateMediaInfoList   ( NameValues    &list,
+                                                  UPnpAVTState  *state       );
+
+        EncoderLink     *GetFreeRecorder        ( QString       &pbshost,
+                                                  const QString &sChanId,
+                                                  unsigned int  nSourceId,
+                                                  QString       &sChanNum    );
+
+        EncoderLink     *GetRecorderForChain    ( QString       &sChainId    );
+
+        void            StopLiveTV              ( UPnpAVTState  *state       );
+
+        void            DispatchBackendMessages ( QString       &sChainId    );
+
+    protected:
+
+        // Implement UPnpServiceImpl methods that we can
+
+        virtual QString GetServiceType      () { return "urn:schemas-upnp-org:service:AVTransport:2"; }
+        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:AVT_2-0"; }
+        virtual QString GetServiceControlURL() { return m_sControlUrl.mid( 1 ); }
+        virtual QString GetServiceDescURL   () { return m_sControlUrl.mid( 1 ) + "/GetServDesc"; }
+
+    public:
+        UPnpAVT( UPnpDevice *pDevice, const QString    &sSharePath );
+
+        virtual ~UPnpAVT();
+
+        virtual bool ProcessRequest( HttpWorkerThread *pThread, HTTPRequest *pRequest );
+};
+
+#endif
Index: programs/mythbackend/transcoder.cpp
===================================================================
--- programs/mythbackend/transcoder.cpp	(revision 0)
+++ programs/mythbackend/transcoder.cpp	(revision 0)
@@ -0,0 +1,1690 @@
+// -*- Mode: c++ -*-
+
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: transcoder.cpp
+// Created     : December 19, 2009
+//
+// Author      : Kunal Kandekar
+//
+// Purpose     : Live TV transcoding using libavcodec
+//
+// Copyright (c) 2010
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+/*
+ *  Adapted from code by Rene Buehlmann for ticket #6888
+ *  http://svn.mythtv.org/trac/ticket/6888
+ */
+
+
+#include "transcoder.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include <sys/time.h>
+#include <fcntl.h>
+#include <errno.h>
+
+
+#define LOC     QString("LiveTranscoder %1: ").arg(m_nId)
+#define LOC_ERR QString("LiveTranscoder %1 - Error: ").arg(m_nId)
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <vector>
+#include <algorithm>
+
+#define dbug if(0) VERBOSE
+
+static int ofbr_open(URLContext *h, const char *filename, int flags)
+{
+    int access = 0;
+    if (flags & URL_RDWR)
+        access = O_CREAT | O_TRUNC | O_RDWR;
+    else if (flags & URL_WRONLY)
+        access = O_CREAT | O_TRUNC | O_WRONLY;
+    else
+        access = O_RDONLY;
+
+    int fd = open(filename + 5, access, 0666);
+
+    if (fd < 0)
+    {
+        VERBOSE(VB_RECORD, QString("Error opening file %1 [%2] flags=%3 -> %4 fd=%5 errno=%6...")
+                .arg(filename).arg(filename + 5).arg(flags).arg(access).arg(fd).arg(errno));
+        perror("ofbr_open:");
+        return -1;
+    }
+    h->priv_data = (void *)(size_t)fd;
+    VERBOSE(VB_RECORD, QString("Opening file %1 [%2] flags=%3 [%4] fd=%5...")
+                .arg(filename).arg(filename + 5).arg(flags).arg(access).arg(fd));
+    h->is_streamed = true;
+    return 0;
+}
+
+static int ofbr_read(URLContext *h, unsigned char *buf, int size)
+{
+    int fd = (size_t)h->priv_data;
+    int len = read(fd, buf, size);
+    int n_tries = TRANSCODE_OFBR_NMAX_TRIES;
+    while(len == 0)
+    {
+        --n_tries;
+        //maybe file has not been written to yet... try again n_tries times after a second each.
+        sleep(1);
+        len = read(fd, buf, size);
+        if (n_tries <= 0)
+        {
+            VERBOSE(VB_RECORD, QString("Read fd=%1 len=%2, try #%3 giving up after %4 secs...")
+                    .arg(fd).arg(len).arg(n_tries).arg(TRANSCODE_OFBR_NMAX_TRIES));
+            break;
+        }
+    }
+    return len;
+}
+
+static int ofbr_write(URLContext *h, unsigned char *buf, int size)
+{
+    int fd = (size_t)h->priv_data;
+    return write(fd, buf, size);
+}
+
+static int ofbr_close(URLContext *h)
+{
+    int fd = (size_t)h->priv_data;
+    VERBOSE(VB_RECORD, QString("Closing file %1.").arg(fd));
+    return close(fd);
+}
+
+static int64_t ofbr_seek(URLContext *h, int64_t os, int pos)
+{
+    int fd = (size_t)h->priv_data;
+    return lseek(fd, os, pos);
+}
+
+URLProtocol ofbr_protocol =
+{ "ofbr", ofbr_open, ofbr_read, ofbr_write, ofbr_seek, ofbr_close, };
+
+LiveTranscoder::LiveTranscoder(QString &filename)
+    : name(filename), width(0), height(0)
+{
+    m_nId                = ++LiveTranscoder::idcount;    //non-critical shared variable, assume atomic inc
+    m_sFileName          = filename;
+    m_sOutputFileName    = "";
+    SetDefaults();
+}
+
+LiveTranscoder::LiveTranscoder(QString &filename, QString &outfile)
+    : name(filename), width(0), height(0)
+{
+    m_nId                = ++LiveTranscoder::idcount;    //non-critical shared variable, assume atomic inc
+    m_sFileName          = filename;
+    m_sOutputFileName    = outfile;
+    SetDefaults();
+}
+
+LiveTranscoder::~LiveTranscoder()
+{
+    m_bStopRequested = true;
+    VERBOSE(VB_RECORD, LOC + QString("for file %1 thread deleted...").arg(m_sFileName));
+}
+
+//static member definitions
+unsigned int LiveTranscoder::idcount = 0;
+QMutex       LiveTranscoder::av_mutex;
+
+void LiveTranscoder::SetDefaults()
+{
+    m_eVideoCodec        = CODEC_ID_FLV1;
+    m_eAudioCodec        = CODEC_ID_MP3;
+    video_bit_rate       = 500;
+    audio_bit_rate       = 128;
+    audio_sample_rate    = 0;
+    m_sVideoCodec        = "flv1";
+    m_sVideoFormat       = "flv";
+    m_sAudioCodec        = "mp3";
+    m_sAudioFormat       = "mp3";
+    b_transcode_video    = true;
+    b_transcode_audio    = true;
+    b_drop_audio         = false;
+    b_drop_video         = false;
+    b_deinterlace        = false;
+
+    b_have_mp3_enc       = false;
+    b_flash_video        = false;
+
+    m_bStopRequested     = false;
+    m_nDeleteDelaySecs   = 0;
+    video_frame_rate_num = 0;
+    video_frame_rate_den = 0;
+
+    height               = 0;
+    width                = 0;
+}
+
+void LiveTranscoder::setParam(const QString &name, int value)
+{
+    if (name == "videobitrate")
+    {
+        video_bit_rate = value;
+    }
+    else if ((name == "height") || (name == "videoheight"))
+    {
+        height = value;
+    }
+    else if ((name == "width") || (name == "videowidth"))
+    {
+        width = value;
+    }
+    else if (name == "audiobitrate")
+    {
+        audio_bit_rate = value;
+    }
+    else if (name == "audiosamplerate")
+    {
+        audio_sample_rate = value;
+    }
+    else if (name == "videoframeratenum")
+    {
+        video_frame_rate_num = value;
+    }
+    else if (name == "videoframerateden")
+    {
+        video_frame_rate_den = value;
+    }
+    else if (name == "deinterlace")
+    {
+        b_deinterlace = (value != 0);
+    }
+    else if (name == "deleteafter")
+    {
+        m_nDeleteDelaySecs = value;
+    }
+}
+
+void LiveTranscoder::setParam(const QString &name, const QString &value)
+{
+    if (name == "videocodec")
+    {
+        m_sVideoCodec = value;
+        if (value == "mpeg4")
+        {
+            m_eVideoCodec = CODEC_ID_MPEG4;
+        }
+        else if (value == "wmv2")
+        {
+            m_eVideoCodec = CODEC_ID_WMV2;
+        }
+        else if (value == "mpeg2")
+        {
+            m_eVideoCodec = CODEC_ID_MPEG2VIDEO;
+        }
+        else if (value == "h264")
+        {
+            m_eVideoCodec = CODEC_ID_H264;
+        }
+        else if (value == "h263i")
+        {
+            m_eVideoCodec = CODEC_ID_H263I;
+        }
+        else if (value == "h263p")
+        {
+            m_eVideoCodec = CODEC_ID_H263P;
+        }
+        else if ((value == "flv1") || (value == "flv"))
+        {
+            m_eVideoCodec = CODEC_ID_FLV1;
+        }
+        else if (value == "vp6")
+        {
+            m_eVideoCodec = CODEC_ID_VP6;
+        }
+        else if (value == "vp6f")
+        {
+            m_eVideoCodec = CODEC_ID_VP6F;
+        }
+        else if (value == "xvid")
+        {
+            m_eVideoCodec = CODEC_ID_XVID;
+        }
+        else if (value == "copy")
+        {
+            b_transcode_video = false;
+        }
+    }
+    else if (name == "videoformat")
+    {
+        m_sVideoFormat = value;
+    }
+    else if (name == "audiocodec")
+    {
+        m_sAudioCodec = value;
+        if (value == "mp2")
+        {
+            m_eAudioCodec = CODEC_ID_MP2;
+        }
+        else if (value == "mp3")
+        {
+            m_eAudioCodec = CODEC_ID_MP3;
+        }
+        else if (value == "wmav2")
+        {
+            m_eAudioCodec = CODEC_ID_WMAV2;
+        }
+        else if (value == "aac")
+        {
+            m_eAudioCodec = CODEC_ID_AAC;
+        }
+        else if (value == "ac3")
+        {
+            m_eAudioCodec = CODEC_ID_AC3;
+        }
+        else if (value == "flac")
+        {
+            m_eAudioCodec = CODEC_ID_FLAC;
+        }
+        else if (value == "s16le")
+        {
+            m_eAudioCodec = CODEC_ID_PCM_S16LE;
+        }
+        else if (value == "adpcmswf")
+        {
+            m_eAudioCodec = CODEC_ID_ADPCM_SWF;
+        }
+        else if (value == "flv")
+        {
+            m_eAudioCodec = CODEC_ID_MP3;
+        }
+        else if (value == "NONE")
+        {
+            b_drop_audio = true;
+        }
+        else if (value == "copy")
+        {
+            b_transcode_audio = false;
+        }
+    }
+    else  if (name == "audioformat")
+    {
+        m_sAudioFormat = value;
+    }
+}
+
+bool LiveTranscoder::IsActive() const
+{
+    return QThread::currentThread()->isRunning();
+}
+
+void LiveTranscoder::Stop()
+{
+    m_bStopRequested = true;
+}
+
+static int cleanup_av(AVFormatContext *pFormatCtxEncode, AVFormatContext *pFormatCtxDecode,
+		SwsContext *scaleContext, std::vector<AVCodecContext*> &opencodecs)
+{
+    av_log_set_level(AV_LOG_QUIET);
+    if (pFormatCtxEncode)
+    {
+        av_free(pFormatCtxEncode);
+    }
+    if (pFormatCtxEncode)
+    {
+        av_close_input_file(pFormatCtxDecode);
+    }
+    if (scaleContext)
+    {
+        sws_freeContext(scaleContext);
+    }
+    for_each(opencodecs.begin(), opencodecs.end(), avcodec_close );
+    opencodecs.clear();
+    return 0;
+}
+
+/*
+Taken from: http://lists.mplayerhq.hu/pipermail/ffmpeg-devel/2008-January/039874.html
+ XXX: make this better.  channels will always be >= 2.
+- Left = front_left + rear_gain * rear_left + center_gain * center
+- Right = front_right + rear_gain * rear_right + center_gain * center
+
+where rear_gain is usually around 0.5-1.0 and center_gain is almost
+always 0.7 (-3 dB) if I recall correctly.
+*/
+#define clip_short(v) (v < -32768 ? -32768 : (v > 32767 ? 32767 : (short)v))
+
+static int multi_to_stereo(short *output, int output_size, short *input, int n, int channels)
+{
+    int i;
+    short l,r;
+    int noutput = 0;
+
+    for(i = 0; i < n; i++)
+    {
+        if (channels == 2)
+        {
+            /* simple stereo to stereo. Input is: l, r */
+            l = input[0];
+            r = input[1];
+        }
+        else if (channels == 6)
+        {
+            /* 5.1 to stereo. l, c, r, ls, rs, sw */
+            int fl,fr,c,rl,rr,lfe;
+            fl = input[0];
+            c = input[1];
+            fr = input[2];
+            rl = input[3];
+            rr = input[4];
+            lfe = input[5];
+
+            l = clip_short(fl + (0.5 * rl) + (0.7 * c));
+            r = clip_short(fr + (0.5 * rr) + (0.7 * c));
+        }
+        else
+        {
+            /* l, c, r, ? */
+            l = input[0];
+            r = input[2];
+        }
+
+        /* interleaved output l & r. */
+        ++noutput;
+        if ((noutput * 2) >= output_size)
+        {
+            //ran out of buffer!
+            return noutput;
+        }
+        *output++ = l;
+        *output++ = r;
+
+        /* increment input. */
+        input += channels;
+    }
+    return noutput;
+}
+
+void LiveTranscoder::RegisterCustomProtocols()
+{
+    URLProtocol *prot = NULL;
+    URLProtocol *prot1 = NULL;
+
+    int register_ofbr = 1;
+
+    prot1 = prot = av_protocol_next(prot);
+    while (prot)
+    {
+        prot = av_protocol_next(prot);
+        if (&ofbr_protocol == prot) register_ofbr = 0;
+        if (prot1 == prot)
+            break;
+    }
+    if (register_ofbr) register_protocol(&ofbr_protocol);
+}
+
+void LiveTranscoder::RegisterAVCodecs()
+{
+	QMutexLocker locker(&av_mutex);
+    av_register_all();
+#if CONFIG_LIBMP3LAME
+    if (avcodec_find_encoder(CODEC_ID_MP3) == NULL)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Registering MP3 codec."));
+        extern AVCodec libmp3lame_encoder;
+        register_avcodec(&libmp3lame_encoder);
+        b_have_mp3_enc = true;
+    }
+#endif
+#if CONFIG_LIBX264_ENCODER
+    if (avcodec_find_encoder(CODEC_ID_H264) == NULL)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Registering H.264 codec."));
+        extern AVCodec libx264_encoder;
+        register_avcodec(&libx264_encoder);
+    }
+#endif
+    RegisterCustomProtocols();
+}
+
+AVCodec *LiveTranscoder::FindVideoEncoder()
+{
+    AVCodec *pVideoCodecEncode = avcodec_find_encoder(m_eVideoCodec);
+    if (pVideoCodecEncode == NULL)
+    {
+        VERBOSE(VB_RECORD,
+                    LOC + QString("Could not find video codec %1, trying for %2")
+                            .arg(m_eVideoCodec).arg(m_sVideoCodec));
+        pVideoCodecEncode = avcodec_find_encoder_by_name(
+                                m_sVideoCodec.toLatin1().constData());
+    }
+    if (pVideoCodecEncode == NULL)
+    {
+        VERBOSE(VB_RECORD,
+                    LOC + QString("Could not find video codec %1 and %2, trying for %3")
+                            .arg(m_eVideoCodec).arg(m_sVideoCodec).arg(m_sVideoFormat));
+        pVideoCodecEncode = avcodec_find_encoder_by_name(
+                                m_sVideoFormat.toLatin1().constData());
+    }
+    return pVideoCodecEncode;
+}
+
+bool LiveTranscoder::TestAVOutputSettings()
+{
+    RegisterAVCodecs();
+
+    //Test for Output Video Format
+    if (guess_format(m_sVideoFormat.toLatin1().constData(), NULL, NULL) == NULL)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not guess video format %1").arg(m_sVideoFormat));
+        return false;
+    }
+
+    //Test for Output Video Codec
+    if (FindVideoEncoder() == NULL)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not open video encoder for %1 / %2!")
+                            .arg(m_sVideoCodec).arg(m_sVideoFormat));
+        return false;
+    }
+
+    b_flash_video = ((m_sVideoFormat == "flv")
+                        || (m_eVideoCodec == CODEC_ID_FLV1)
+                        || (m_eVideoCodec == CODEC_ID_VP6)
+                        || (m_eVideoCodec == CODEC_ID_VP6F));
+
+    if (b_flash_video && (m_eAudioCodec == CODEC_ID_MP3) && !b_have_mp3_enc)
+    {
+        //use adpcm-swf for flash if mp3 encoder is not available
+        m_eAudioCodec = CODEC_ID_ADPCM_SWF;
+        VERBOSE(VB_RECORD, LOC + QString("Using ADPCM_SWF as "
+                            "LIBMP3LAME is not configured."));
+    }
+
+    //Test for Output Audio Codec
+    if ((avcodec_find_encoder(m_eAudioCodec) == NULL) && !b_drop_audio)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not open audio encoder %1!")
+                                    .arg(m_sAudioCodec));
+        return false;
+    }
+
+    return true;
+}
+
+void LiveTranscoder::run()
+{
+    if (!TestAVOutputSettings())
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Output video settings not supported. Aborting..."));
+        return;
+    }
+
+    unsigned int i = 0;
+    AVPacket packet;
+    AVFormatContext *pFormatCtxDecode  = NULL;
+    bool b_multi_to_stereo = false;
+
+    int audio_sample_size_bytes = 2;
+
+    int64_t v_decode_pts        = 0;    //pts of the input video stream
+    int64_t v_decode_start_time = 0;    //start time offset of input video stream
+    int64_t v_decode_pts_offset = 0;    //start pts offset of input video stream
+    int64_t a_decode_pts_offset = 0;    //ditto for audio
+    int64_t a_decode_start_time = 0;    //ditto for audio
+    int64_t a_decode_pts        = 0;    //ditto for audio
+    double  av_sync_offset_sec  = 0.3f;
+
+    if (m_sOutputFileName.isEmpty())
+    {
+        m_sOutputFileName = m_sFileName;
+        m_sOutputFileName.append(".").append(m_sVideoFormat);
+    }
+
+    VERBOSE(VB_RECORD, LOC + QString("LiveTranscoder %1 -> %2 started!").arg(m_sFileName).arg(m_sOutputFileName));
+    if (m_sVideoFormat == "mpx")
+        m_sVideoFormat = "mp4";
+
+    if (m_sVideoFormat == "f4v")
+        m_sVideoFormat = "flv";
+
+    av_log_set_level(AV_LOG_DEBUG);
+
+    // Open video
+    char buf[256];
+    sprintf((char *) &buf, "ofbr:%s", m_sFileName.toLatin1().constData());
+
+    if (av_open_input_file(&pFormatCtxDecode, (char *) &buf, NULL, 4000*1000, NULL) != 0)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not open file %1!").arg(buf));
+        av_log_set_level(AV_LOG_QUIET);
+        return; // Couldn't open file
+    }
+
+    // Retrieve stream information
+    if (av_find_stream_info(pFormatCtxDecode) < 0)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not find stream information!"));
+        av_log_set_level(AV_LOG_QUIET);
+        av_close_input_file(pFormatCtxDecode);
+        return; // Couldn't find stream information
+    }
+
+    // Dump information about file onto standard error
+    dump_format(pFormatCtxDecode, 0, (char *) &buf, false);
+
+
+    //Prepare Output
+    AVFormatContext *pFormatCtxEncode  = NULL;
+    SwsContext      *scaleContext      = NULL;    //obsolete in latest version of libavcodec
+    ReSampleContext *pAudioResampleCtx = NULL;
+
+    pFormatCtxEncode          = avformat_alloc_context();
+    pFormatCtxEncode->oformat = guess_format(m_sVideoFormat.toLatin1().constData(), NULL, NULL);
+
+    sprintf((char *) &buf, "%s", m_sOutputFileName.toLatin1().constData());
+    memcpy(pFormatCtxEncode->filename, (char*) &buf,
+            sizeof(pFormatCtxEncode->filename));
+
+    //Prepare Video Codec
+    AVCodec *pVideoCodecEncode = FindVideoEncoder();//TestAVOutputSettings ensures !null
+    m_eVideoCodec = pVideoCodecEncode->id;          //the actual codec id
+    m_sVideoCodec = QString(pVideoCodecEncode->name);
+    VERBOSE(VB_RECORD, LOC + QString("Video codec id=%1 name=%2")
+                                .arg(m_eVideoCodec).arg(m_sVideoCodec));
+
+    //Prepare Audio Codec
+    AVCodec *pAudioCodecEncode = avcodec_find_encoder(m_eAudioCodec);
+
+    VERBOSE(VB_RECORD, LOC + QString("Container start time is %1 AV_TIME_BASE "
+                                "units.").arg(pFormatCtxDecode->start_time));
+
+    int au_max_byte_delta = 0;
+
+    // Copy the stream information
+    std::vector<AVCodecContext*> opencodecs;
+    for (i = 0; i < pFormatCtxDecode->nb_streams; ++i)
+    {
+        AVStream *ist = pFormatCtxDecode->streams[i];
+        if ((ist->codec->codec_type == CODEC_TYPE_VIDEO) && b_drop_video)
+            continue;
+        if ((ist->codec->codec_type == CODEC_TYPE_AUDIO) && b_drop_audio)
+            continue;
+        if (i >= 2) continue;
+
+        AVStream *ost = av_new_stream(pFormatCtxEncode, i);
+
+        if ((ist->codec->codec_type == CODEC_TYPE_VIDEO) && b_transcode_video)
+        {
+            ost->codec->codec_type = ist->codec->codec_type;
+            ost->codec->bit_rate = video_bit_rate * 1000;
+            if ((ost->codec->bit_rate < ist->codec->bit_rate)
+                && (ist->codec->bit_rate < 1500*1000))
+                ost->codec->bit_rate = ist->codec->bit_rate;
+            //memcpy( ost->language, ist->language, sizeof(ost->language));
+            ost->codec->ildct_cmp = ist->codec->ildct_cmp;
+            ost->codec->sample_aspect_ratio.num
+                    = ist->codec->sample_aspect_ratio.num;
+            ost->codec->sample_aspect_ratio.den
+                    = ist->codec->sample_aspect_ratio.den;
+            ost->sample_aspect_ratio.num = ist->codec->sample_aspect_ratio.num;
+            ost->sample_aspect_ratio.den = ist->codec->sample_aspect_ratio.den;
+            ost->codec->width  = ist->codec->width;
+            ost->codec->height = ist->codec->height;
+
+            ost->disposition   = ist->disposition;
+            ost->quality       = ist->quality;
+            ost->codec->bits_per_raw_sample= ist->codec->bits_per_raw_sample;
+            //ost->codec->chroma_sample_location = ist->codec->chroma_sample_location;
+
+            if (!ost->codec->width)
+                ost->codec->width = 720;
+            if (!ost->codec->height)
+                ost->codec->height = 576;
+            ost->codec->pix_fmt = ist->codec->pix_fmt;
+
+            if (height != 0 && width != 0 && (ost->codec->width != width
+                    || ost->codec->height != height))
+            {
+                ost->codec->width = width;
+                ost->codec->height = height;
+
+                scaleContext = sws_getContext(ist->codec->width,
+                        ist->codec->height, ist->codec->pix_fmt, width, height,
+                        ost->codec->pix_fmt, 1, NULL, NULL, NULL);
+                if (!scaleContext)
+                {
+                    VERBOSE(VB_RECORD, LOC + QString("Could not create scale context!"));
+                    cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                    return;
+                }
+            }
+
+            ost->codec->gop_size     = ist->codec->gop_size; // emit one intra frame every gop_size frames
+            ost->codec->max_b_frames = ist->codec->max_b_frames;
+            if ((m_eVideoCodec == CODEC_ID_WMV2) || (m_eVideoCodec == CODEC_ID_FLV1))
+            {
+                ost->codec->max_b_frames = 0; //WMV2 and FLV1 do not accept b-frames
+                VERBOSE(VB_RECORD, LOC + QString("Setting FLV to 0 b-frames"));
+            }
+
+            ost->codec->time_base     = ist->codec->time_base;
+
+            ost->codec->time_base.den = ist->r_frame_rate.num;
+            ost->codec->time_base.num = ist->r_frame_rate.den;
+            ost->time_base            = ist->time_base;
+
+            if((av_q2d(ist->codec->time_base) > av_q2d(ist->time_base))
+                && (av_q2d(ist->time_base) < 1.0/1000))
+            {
+                ost->codec->time_base = ist->codec->time_base;
+                if (b_flash_video)
+                {
+                    ost->codec->time_base.num = 1;
+                    ost->codec->time_base.den = 25;
+                    ost->codec->gop_size      = (int) 2.0*((double)ost->codec->time_base.den / ost->codec->time_base.num) ; // emit one intra frame every 1 sec
+                    //ost->r_frame_rate = ost->time_base;
+                    //ost->codec->time_base.num = 1;
+                    //ost->codec->time_base.den = (int) (ost->codec->time_base.den / (double)ost->codec->time_base.num);
+                    VERBOSE(VB_RECORD, LOC + QString("Setting FLV video timebase to %1/%2,"
+                            " decoded=%3/%4=%5 < %6. "
+                            "Keyframes every %7 frames for op and %8 for ip,"
+                            " codec=%9")
+                            .arg(ost->time_base.num).arg(ost->time_base.den)
+                            .arg(ist->time_base.num).arg(ist->time_base.den)
+                            .arg(av_q2d(ist->time_base)).arg(1/1000.0)
+                            .arg(ost->codec->gop_size).arg(ist->codec->gop_size)
+                            .arg(m_eVideoCodec));
+                }
+                else if ((video_frame_rate_num > 0) && (video_frame_rate_den > 0))
+                {
+                    ost->codec->time_base.num = video_frame_rate_num;
+                    ost->codec->time_base.den = video_frame_rate_den;
+                }
+            }
+
+            //start time offset
+            if (ist->start_time != AV_NOPTS_VALUE)
+            {
+                v_decode_start_time = ist->start_time;
+                v_decode_pts_offset = av_rescale_q(ist->start_time, ist->time_base, AV_TIME_BASE_Q);
+                VERBOSE(VB_RECORD, LOC + QString("Video stream %1 start time is"
+                                            " %2 AV_TIME_BASE units = %3 frames.")
+                                            .arg(i).arg(ist->start_time)
+                                            .arg(v_decode_pts_offset));
+            }
+
+            //if(!ost->codec->codec_tag){
+            //    if(  pFormatCtxEncode->oformat->codec_tag
+            //        || av_codec_get_id (pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_tag) > 0
+            //        || av_codec_get_tag(pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_id) <= 0)
+            //        ost->codec->codec_tag = ist->codec->codec_tag;
+            //}
+
+            //flags
+            if (!strcmp(pFormatCtxEncode->oformat->name, "mp4")
+                || !strcmp(pFormatCtxEncode->oformat->name, "mov")
+                || !strcmp(pFormatCtxEncode->oformat->name, "3gp")
+                || !strcmp(pFormatCtxEncode->oformat->name, "flv"))
+            {
+                //VERBOSE(VB_RECORD, LOC + QString("set global header flag!!!"));
+                ost->codec->flags |= CODEC_FLAG_GLOBAL_HEADER;
+            }
+            if (!ost->codec->rc_initial_buffer_occupancy)
+                ost->codec->rc_initial_buffer_occupancy = ost->codec->rc_buffer_size * 3/4;
+
+            //fix for broken ffmpeg settings that libx264 does not accept
+            if (m_eVideoCodec == CODEC_ID_H264)
+            {
+                ost->codec->me_range  = 16;
+                ost->codec->max_qdiff = 4;
+                ost->codec->qmin      = 10;
+                ost->codec->qmax      = 51;
+                ost->codec->qcompress = 0.6;
+
+                //extra settings
+                ost->codec->gop_size  = 30;
+                ost->codec->trellis   = 1;
+                ost->codec->refs      = 1;
+                ost->codec->coder_type= FF_CODER_TYPE_VLC;
+                ost->codec->keyint_min= 25;
+                ost->codec->rc_eq     = "blurCplx^(1-qComp)";
+                //ost->codec->scenechange_threshold = 40;
+                //ost->codec->i_quant_factor = 0.71;
+                //ost->codec->bit_rate_tolerance = 200*1000;
+                //ost->codec->level = 30;
+            }
+
+            if (avcodec_open(ost->codec, pVideoCodecEncode) < 0)
+            {
+                VERBOSE(VB_RECORD, LOC
+                        + QString("could not open video codec %1!!!")
+                            .arg(pVideoCodecEncode->name));
+                cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                return;
+            }
+            opencodecs.push_back(ost->codec);
+
+            AVCodec *pCodecDecode = avcodec_find_decoder(ist->codec->codec_id);
+            if (pCodecDecode == NULL)
+            {
+                VERBOSE(VB_RECORD, LOC + QString("Could not find video decoder!"));
+                cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                return;
+            }
+
+            if (avcodec_open(ist->codec, pCodecDecode) < 0)
+            {
+                VERBOSE(VB_RECORD, LOC + QString("Could not open video decoder!"));
+                cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                break;
+            }
+            opencodecs.push_back(ist->codec);
+
+        }
+        else if ((ist->codec->codec_type == CODEC_TYPE_AUDIO) && b_transcode_audio)
+        {
+            //ost->codec = avcodec_alloc_context();
+            ost->codec->codec_type = ist->codec->codec_type;
+            ost->codec->bit_rate = (int)(audio_bit_rate * 1000);
+            ost->id = ist->id;
+            memcpy( ost->language, ist->language, sizeof(ost->language));
+            ost->codec->me_method  = ist->codec->me_method;
+            ost->codec->sample_fmt = ist->codec->sample_fmt;
+
+            audio_sample_size_bytes = av_get_bits_per_sample_format(ist->codec->sample_fmt) / 8;
+
+            if (!ost->codec->width)
+                ost->codec->width = 720;
+            if (!ost->codec->height)
+                ost->codec->height = 576;
+
+            //if(!ost->codec->codec_tag){
+            //    if(  pFormatCtxEncode->oformat->codec_tag
+            //        || av_codec_get_id (pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_tag) > 0
+            //        || av_codec_get_tag(pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_id) <= 0)
+            //        ost->codec->codec_tag = ist->codec->codec_tag;
+            //}
+
+            ost->codec->extradata = ist->codec->extradata;
+            ost->codec->extradata_size = ist->codec->extradata_size;
+
+            if (av_q2d(ist->codec->time_base) > av_q2d(ist->time_base)
+                    && av_q2d(ist->time_base) < 1.0 / 1000)
+                ost->codec->time_base = ist->codec->time_base;
+            else
+                ost->codec->time_base = ist->time_base;
+
+
+            ost->codec->time_base   = ist->codec->time_base;
+            ost->codec->sample_rate = ist->codec->sample_rate;
+            ost->codec->channels    = ist->codec->channels ? ist->codec->channels : 2;
+            ost->codec->block_align = 0;
+
+            if (audio_sample_rate)   //if specified
+            {
+                ost->codec->sample_rate    = audio_sample_rate;
+                ost->codec->time_base.num  = 1;
+                ost->codec->time_base.den  = audio_sample_rate;
+            }
+
+            if (b_flash_video)
+            {
+                //FLV1 only accepts 3 audio sample rates: 44100, 22050 and 11025
+                ost->codec->sample_rate    = 44100;
+                ost->codec->time_base.num  = 1;
+                ost->codec->time_base.den  = 44100;
+                if (ost->codec->channels > 2)
+                    ost->codec->channels   = 2;
+
+                //VERBOSE(VB_RECORD, LOC + QString("set global header flag!!!"));
+                ost->codec->flags |= CODEC_FLAG_GLOBAL_HEADER;
+            }
+
+            if (ist->codec->sample_rate != ost->codec->sample_rate)
+            {
+                //resample audio
+                if (ist->codec->channels > 2)
+                {
+                    //convert 5.1 surround sound to stereo
+                    b_multi_to_stereo = true;
+                    VERBOSE(VB_RECORD,
+                                LOC + QString("Converting #channels from %1 to %2")
+                                        .arg(ist->codec->channels)
+                                        .arg(ost->codec->channels));
+                    pAudioResampleCtx = audio_resample_init(ost->codec->channels,
+                                                            2,
+                                                            ost->codec->sample_rate,
+                                                            ist->codec->sample_rate);
+                }
+                else
+                {
+                    pAudioResampleCtx = audio_resample_init(ost->codec->channels,
+                                                            ist->codec->channels,
+                                                            ost->codec->sample_rate,
+                                                            ist->codec->sample_rate);
+                }
+                VERBOSE(VB_RECORD, LOC + QString("Resampling from %1 to %2 Hz")
+                                    .arg(ist->codec->sample_rate)
+                                    .arg(ost->codec->sample_rate));
+            }
+
+            if (ist->start_time != AV_NOPTS_VALUE)
+            {
+                a_decode_start_time = ist->start_time;
+                a_decode_pts_offset = av_rescale_q(ist->start_time, ist->time_base, AV_TIME_BASE_Q);
+                VERBOSE(VB_RECORD, LOC + QString("Audio stream %1 start time is"
+                                            " %2 AV_TIME_BASE units = %3 samples.")
+                                            .arg(i).arg(ist->start_time)
+                                            .arg(a_decode_pts_offset));
+            }
+
+            au_max_byte_delta = ost->codec->channels * ost->codec->sample_rate
+                                * audio_sample_size_bytes * 15;//15s desync max
+
+            if (!b_drop_audio && (avcodec_open(ost->codec, pAudioCodecEncode) < 0))
+            {
+                VERBOSE(VB_RECORD, LOC
+                            + QString("could not open audio codec... dropping it!"));
+                //dump_format(pFormatCtxEncode, i, pFormatCtxEncode->filename, 1);
+                b_drop_audio = true;
+            }
+            if (!b_drop_audio)
+            {
+            	opencodecs.push_back(ost->codec);
+            }
+
+            AVCodec *pCodecDecode = avcodec_find_decoder(ist->codec->codec_id);
+            if (pCodecDecode == NULL)
+            {
+                VERBOSE(VB_RECORD, LOC + QString("Could not find audio decoder!"));
+                cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                return;
+            }
+
+            if (avcodec_open(ist->codec, pCodecDecode) < 0)
+            {
+                VERBOSE(VB_RECORD, LOC + QString("Could not open audio decoder!"));
+                cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+                return;
+            }
+            opencodecs.push_back(ist->codec);
+        }
+        else
+        {
+            ost->stream_copy = 1;
+            ost->codec->codec_id = ist->codec->codec_id;
+            ost->codec->codec_type = ist->codec->codec_type;
+            ost->codec->codec_tag = ist->codec->codec_tag;
+            memcpy(ost->codec->codec_name, ist->codec->codec_name,
+                    sizeof(ost->codec->codec_name));
+            ost->codec->sub_id = ist->codec->sub_id;
+            ost->codec->me_method = ist->codec->me_method;
+            ost->codec->sample_fmt = ist->codec->sample_fmt;
+
+            //if(!ost->codec->codec_tag){
+            //    if(  pFormatCtxEncode->oformat->codec_tag
+            //        || av_codec_get_id (pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_tag) > 0
+            //        || av_codec_get_tag(pFormatCtxEncode->oformat->codec_tag, ist->codec->codec_id) <= 0)
+            //        ost->codec->codec_tag = ist->codec->codec_tag;
+            //}
+
+            ost->codec->bit_rate = ist->codec->bit_rate;
+            ost->codec->extradata = ist->codec->extradata;
+            ost->codec->extradata_size = ist->codec->extradata_size;
+
+            if (av_q2d(ist->codec->time_base) > av_q2d(ist->time_base)
+                    && av_q2d(ist->time_base) < 1.0 / 1000)
+                ost->codec->time_base = ist->codec->time_base;
+            else
+                ost->codec->time_base = ist->time_base;
+
+            switch (ost->codec->codec_type)
+            {
+            case CODEC_TYPE_AUDIO:
+                ost->codec->sample_rate
+                        = ist->codec->sample_rate ? ist->codec->sample_rate
+                                : 48000;
+                ost->codec->channels
+                        = ist->codec->channels ? ist->codec->channels : 2;
+                ost->codec->frame_size = ist->codec->frame_size;
+                ost->codec->block_align = ist->codec->block_align;
+                if (ost->codec->block_align == 1 && ost->codec->codec_id
+                        == CODEC_ID_MP3)
+                    ost->codec->block_align = 0;
+                if (ist->start_time != AV_NOPTS_VALUE)
+                {
+                    a_decode_start_time = ist->start_time;
+                    a_decode_pts_offset = av_rescale_q(ist->start_time, ist->time_base, AV_TIME_BASE_Q);
+                    VERBOSE(VB_RECORD, LOC + QString("Audio stream %1 start time is"
+                                                " %2 AV_TIME_BASE units = %3 samples.")
+                                                .arg(i).arg(ist->start_time)
+                                                .arg(a_decode_pts_offset));
+                }
+                break;
+            case CODEC_TYPE_VIDEO:
+                ost->codec->pix_fmt = ist->codec->pix_fmt;
+                ost->codec->width = ist->codec->width;
+                ost->codec->height = ist->codec->height;
+                ost->codec->has_b_frames = ist->codec->has_b_frames;
+                if (!ost->codec->width)
+                    ost->codec->width = 720;
+                if (!ost->codec->height)
+                    ost->codec->height = 576;
+                if (ist->start_time != AV_NOPTS_VALUE)
+                {
+                    v_decode_start_time = ist->start_time;
+                    v_decode_pts_offset = av_rescale_q(ist->start_time, ist->time_base, AV_TIME_BASE_Q);
+                    VERBOSE(VB_RECORD, LOC + QString("Video stream %1 start time is"
+                                                " %2 AV_TIME_BASE units = %3 samples.")
+                                                .arg(i).arg(ist->start_time)
+                                                .arg(v_decode_pts_offset));
+                }
+
+                break;
+            case CODEC_TYPE_SUBTITLE:
+                //not supported by flash
+                break;
+            default:
+                break;
+            }
+
+            ost->pts.num = ist->pts.num;
+            ost->pts.den = ist->pts.den;
+        }
+    }
+
+    if (av_set_parameters(pFormatCtxEncode, NULL) < 0)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Invalid output format parameters"));
+        cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+        return;
+    }
+    pFormatCtxEncode->preload   = (int)(0.5 * AV_TIME_BASE);
+    pFormatCtxEncode->max_delay = (int)(0.7 * AV_TIME_BASE);
+    dump_format(pFormatCtxEncode, i, pFormatCtxEncode->filename, 1);
+
+    //reduce log level because transcoding to flv produces a lot of logs
+    av_log_set_level(AV_LOG_QUIET);
+
+    int err = url_fopen(&pFormatCtxEncode->pb, pFormatCtxEncode->filename, URL_WRONLY);
+    if (err < 0)
+    {
+        VERBOSE(VB_RECORD,
+                    LOC + QString("Could not open output file [%1], err=%2!")
+                            .arg(pFormatCtxEncode->filename).arg(err));
+        if (err == AVERROR_IO)
+            VERBOSE(VB_RECORD, LOC + QString("err=%2 = EIO!").arg(err));
+        if (err == AVERROR_NOENT)
+            VERBOSE(VB_RECORD, LOC + QString("err=%2 = AVERROR_NOENT!").arg(err));
+        cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+        return;
+    }
+
+    if(url_setbufsize(pFormatCtxEncode->pb, 4000*1000) != 0)
+    {
+        //oom
+        VERBOSE(VB_RECORD, LOC + QString("Insufficient memory for buffer!"));
+        av_log_set_level(AV_LOG_QUIET);
+        cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+        return;
+    }
+
+    if (av_write_header(pFormatCtxEncode) < 0)
+    {
+        VERBOSE(VB_RECORD, LOC + QString("Could not  write header!"));
+        av_log_set_level(AV_LOG_QUIET);
+        cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+        return;
+    }
+
+    AVFrame *pFrame         = avcodec_alloc_frame();
+    AVFrame *newFrame       = pFrame;
+    int     frameFinished   = 0;
+    int     outbuf_size     = 100000;
+    uint8_t *outbuf         = (uint8_t*)av_malloc(outbuf_size * sizeof(uint8_t));
+
+
+    int     AUDIOSAMPLESMAX = AVCODEC_MAX_AUDIO_FRAME_SIZE
+                                + 16 /* for alignment */
+                                + FF_INPUT_BUFFER_PADDING_SIZE /*for optimized decodeers */;
+    int     audiosamplesize = AUDIOSAMPLESMAX;
+
+
+    //16-byte align to avoid segfaults on some architectures using SSE/ALTIVEC
+    size_t  audiobufsize1    = audiosamplesize * audio_sample_size_bytes * 2 /* max num channels */;
+    int16_t *audiosample1    = (int16_t*) av_malloc(audiobufsize1);
+
+    size_t  audiobufsize2   = audiobufsize1;
+    int16_t *audiosample2   = audiosample1;
+
+    if (pAudioResampleCtx)
+    {
+        audiobufsize2       = audiosamplesize * audio_sample_size_bytes * 2 /* max num channels */;
+        //16-byte align to avoid segfaults on some architectures using SSE/ALTIVEC
+        audiosample2        = (int16_t*) av_malloc(audiobufsize2);
+    }
+
+    size_t  audiobufsize3   = audiobufsize1;
+    int16_t *audiosample3   = audiosample1;
+    if (b_multi_to_stereo)
+    {
+        audiobufsize3       = audiosamplesize * audio_sample_size_bytes * 2 /* max num channels */;
+        //16-byte align to avoid segfaults on some architectures using SSE/ALTIVEC
+        audiosample3        = (int16_t*) av_malloc(audiobufsize3);
+    }
+
+
+    //fifo
+    int           audiofifosize = audio_sample_size_bytes * AUDIOSAMPLESMAX;
+    //buffer to read _out_ of the FIFO into
+    //no need for align16 because av_malloc (probably) handles this
+    uint8_t       *audiofifobuf = (uint8_t*)av_malloc(audiofifosize);
+    // FIFO to write incoming audio samples into
+    AVFifoBuffer  *audiofifo    = av_fifo_alloc(2 * AUDIOSAMPLESMAX);
+
+    //For de-interlacing
+    AVPicture *pPicture = NULL;
+
+    if (b_deinterlace)
+    {
+        pPicture = (AVPicture*)malloc(sizeof(AVPicture));
+    }
+
+    //For scaling
+    AVPicture   *newPicture = NULL;
+    uint8_t     *buffer     = NULL;
+    if (scaleContext)
+    {
+        int numBytes = avpicture_get_size(
+                        pFormatCtxEncode->streams[0]->codec->pix_fmt,
+                        pFormatCtxEncode->streams[0]->codec->width,
+                        pFormatCtxEncode->streams[0]->codec->height);
+        buffer = (uint8_t*)av_malloc(numBytes * sizeof(uint8_t));
+        memset(buffer, 0, numBytes);
+        newPicture = (AVPicture*)malloc(sizeof(AVPicture));
+        newFrame = avcodec_alloc_frame();
+        avpicture_fill((AVPicture *) newPicture, buffer,
+                        pFormatCtxEncode->streams[0]->codec->pix_fmt,
+                        pFormatCtxEncode->streams[0]->codec->width,
+                        pFormatCtxEncode->streams[0]->codec->height);
+    }
+
+    //Copy or Transcode
+    VERBOSE(VB_RECORD, LOC + QString("Starting transcode loop from %1 to %2")
+                                .arg(pFormatCtxDecode->filename)
+                                .arg(pFormatCtxEncode->filename));
+    int64_t nFrames         = 0;
+    int64_t nAudioFramesIn  = 0;
+    int64_t nVideoFramesIn  = 0;
+    int64_t nAudioFrames    = 0;
+    int64_t nAudioSamples   = 0;
+    int64_t nVideoFrames    = 0;
+    int64_t nFramesDropped  = 0;
+    int64_t nFramesDropped2 = 0;
+    int64_t nFramesDuped    = 0;
+    int64_t nFramesDuped2   = 0;
+    int64_t nSamplesDropped = 0;
+    int64_t nSamplesAdded   = 0;
+    int64_t nSamplesCompdPos= 0;
+    int64_t nSamplesCompdNeg= 0;
+    int64_t nErrors         = 0;
+    int64_t nErrorLimit     = 0;    //1000*1000;
+
+    int nDisplayIntervalCount = 0;
+
+    bool b_wrote_video_frame = false;
+    bool b_read_video_frame  = false;
+
+    while (av_read_frame(pFormatCtxDecode, &packet) >= 0)
+    {
+        b_wrote_video_frame = false;
+        b_read_video_frame  = false;
+
+        double av_desync_sec = fabs((double)(v_decode_pts - a_decode_pts) /AV_TIME_BASE);
+
+        dbug(VB_RECORD, QString("Read frame #%1").arg(nFrames));
+        if (m_bStopRequested)
+        {
+            VERBOSE(VB_RECORD, LOC + QString("Stop requested!"));
+            break;
+        }
+        //only two streams for now..
+        if (packet.stream_index >= 2) continue;
+
+        if (nErrorLimit && (nErrors > nErrorLimit))
+        {
+            VERBOSE(VB_RECORD, LOC + QString("Too many errors! Breaking..."));
+            break;
+        }
+
+        if ((packet.stream_index < pFormatCtxEncode->nb_streams)
+                && pFormatCtxEncode->streams[packet.stream_index]->stream_copy)
+        {
+            dbug(VB_RECORD, QString("Write (copy) frame %1").arg(nFrames));
+            if (av_interleaved_write_frame(pFormatCtxEncode, &packet))
+                VERBOSE(VB_RECORD, LOC + QString("Write (copy) frame failed!"));
+        }
+        else
+        {
+            AVStream       *pDecStream   = pFormatCtxDecode->streams[packet.stream_index];
+            AVCodecContext *pDecCodecCtx = pDecStream->codec;
+            if (pDecCodecCtx->codec_type == CODEC_TYPE_VIDEO)
+            {
+                nVideoFramesIn++;
+                AVStream       *pEncStream   = pFormatCtxEncode->streams[packet.stream_index];
+                AVCodecContext *pEncCodecCtx = pEncStream->codec;
+
+                b_read_video_frame = true;
+                int ret = avcodec_decode_video(pDecCodecCtx, pFrame, &frameFinished,
+                            packet.data, packet.size);
+                if (ret < 0)
+                {
+                    dbug(VB_RECORD, QString("Decode video frame #%1 failed, error=%2").arg(nVideoFramesIn).arg(ret));
+                    nErrors++;
+                }
+                else if (ret == 0)
+                {
+                    dbug(VB_RECORD, QString("Decode video frame #%1 dropped ret=%2").arg(nVideoFramesIn).arg(ret));
+                }
+                if (frameFinished)
+                {
+                    // deinterlace : must be done before any resize
+                    if (b_deinterlace && pFrame->interlaced_frame)
+                    {
+                        //convert AVFrame to AVPicture
+                        for (int i = 0; i < 3; i++)
+                        {
+                            pPicture->data[i]     = pFrame->data[i];
+                            pPicture->linesize[i] = pFrame->linesize[i];
+                        }
+
+                        //de-interlace in place
+                        if (avpicture_deinterlace(pPicture,
+                                pPicture, pDecCodecCtx->pix_fmt,
+                                pDecCodecCtx->width, pDecCodecCtx->height) < 0)
+                        {
+                            // if error, do not deinterlace
+                            dbug(VB_RECORD, LOC
+                                        + QString("De-interlacing video frame #%1 failed")
+                                            .arg(nVideoFrames));
+                        }
+                        else
+                        {
+                            //convert AVPicture back to AVFrame
+                            for (int i = 0; i < 3; i++)
+                            {
+                                pFrame->data[i]     = pPicture->data[i];
+                                pFrame->linesize[i] = pPicture->linesize[i];
+                            }
+                        }
+                    }
+
+                    //Do rescale
+                    if (scaleContext)
+                    {
+                        sws_scale(
+                                scaleContext,
+                                pFrame->data,
+                                pFrame->linesize,
+                                0,
+                                pDecCodecCtx->height,
+                                newPicture->data, newPicture->linesize);
+                        newFrame->data[0]     = newPicture->data[0];
+                        newFrame->linesize[0] = newPicture->linesize[0];
+                        newFrame->data[1]     = newPicture->data[1];
+                        newFrame->linesize[1] = newPicture->linesize[1];
+                        newFrame->data[2]     = newPicture->data[2];
+                        newFrame->linesize[2] = newPicture->linesize[2];
+                        newFrame->data[3]     = newPicture->data[3];
+                        newFrame->linesize[3] = newPicture->linesize[3];
+                    }
+
+                    if (packet.dts != AV_NOPTS_VALUE)
+                    {
+                        v_decode_pts  = av_rescale_q(packet.dts, pDecStream->time_base, AV_TIME_BASE_Q);
+                        v_decode_pts -= v_decode_pts_offset;    // m_ptsOffset is in AV_TIME_BASE units
+                    }
+
+                    double sync_ipts  = (double)v_decode_pts / AV_TIME_BASE;        // how many seconds into input stream are we?
+                    double nOutFrames = sync_ipts / av_q2d(pEncCodecCtx->time_base);// how many frames of output does this equate to?
+                    double vdelta     = nOutFrames - nVideoFrames;                    // what's the difference?
+                    int    nFrameReps = 1;
+
+                    if (vdelta < -1.1)
+                    {
+                        //don't drop key-frames
+                        if(!pFrame->key_frame)
+                        {
+                            nFrameReps = 0;
+                            dbug(VB_RECORD, LOC + QString("pts delta=%1 DROPPING frame!").arg(vdelta));
+                            nFramesDropped++;
+                        }
+                        nFramesDropped2++;
+                    }
+                    else if (vdelta > 1.1)
+                    {
+                        nFrameReps = lrintf(vdelta);
+                        nFramesDuped2 += (nFrameReps - 1);
+                        int nFrameRepsMax = 25 * 2;
+                        nFrameReps = (nFrameReps > nFrameRepsMax ? nFrameRepsMax : nFrameReps);
+                        nFramesDuped  += (nFrameReps - 1);
+                        dbug(VB_RECORD, LOC + QString("pts delta=%1 DUPING %2 frames")
+                                .arg(vdelta).arg(nFrameReps - 1));
+                    }
+
+                    for(int rep = 0; rep < nFrameReps; rep++)
+                    {
+                        newFrame->pts = nVideoFrames;
+
+                        //outbuf_size = ret;
+                        dbug(VB_RECORD, QString("Encoding video frame #%1 [size=%2]").arg(nVideoFrames).arg(ret));
+                        int out_size = avcodec_encode_video(pEncCodecCtx,
+                                            outbuf, outbuf_size,newFrame);
+                        if (out_size < 0)
+                        {
+                            dbug(VB_RECORD, QString("Encode video frame #%1 [size=%2] failed, error=%1")
+                                    .arg(nVideoFrames).arg(ret).arg(out_size));
+                            nErrors++;
+                        }
+                        else if (out_size == 0)
+                        {
+                            dbug(VB_RECORD, QString("Encode video frame #%1 [size=%2] was buffered or dropped ")
+                                                .arg(nVideoFrames).arg(out_size));
+                        }
+                        else
+                        {
+                            dbug(VB_RECORD, QString("Encoded video frame #%1 [size=%2]").arg(nVideoFrames).arg(out_size));
+                            AVPacket packet_out;
+                            av_init_packet(&packet_out);
+                            packet_out.data         = outbuf;
+                            packet_out.size         = out_size;
+                            packet_out.stream_index = packet.stream_index;
+                            if(pEncCodecCtx->coded_frame->key_frame)
+                                packet_out.flags   |= PKT_FLAG_KEY;
+                            if ((pEncCodecCtx->coded_frame)
+                                && (pEncCodecCtx->coded_frame->pts != AV_NOPTS_VALUE))
+                            {
+                                packet_out.pts = av_rescale_q(
+                                                    pEncCodecCtx->coded_frame->pts,
+                                                    pEncCodecCtx->time_base,
+                                                    pEncStream->time_base);
+                            }
+
+                            dbug(VB_RECORD, QString("Writing video frame #%1 [ret=%2, size=%3]").arg(nVideoFrames).arg(ret).arg(out_size));
+                            ret = av_interleaved_write_frame(pFormatCtxEncode, &packet_out);
+                            dbug(VB_RECORD, QString("Wrote video frame #%1 [ret=%2]").arg(nVideoFrames).arg(ret));
+                            if (ret)
+                            {
+                                VERBOSE(VB_RECORD, LOC
+                                        + QString("Write frame #%1 failed, error=%2")
+                                            .arg(nVideoFrames).arg(ret));
+                                nErrors++;
+                            }
+                            b_wrote_video_frame = true;
+                            av_free_packet(&packet_out);
+                            nVideoFrames++;
+                        }
+                    }
+                }
+            }
+            else if (!b_drop_audio && (pDecCodecCtx->codec_type == CODEC_TYPE_AUDIO))
+            {
+                nAudioFramesIn++;
+                AVStream       *pEncStream   = pFormatCtxEncode->streams[packet.stream_index];
+                AVCodecContext *pEncCodecCtx = pEncStream->codec;
+
+                audiosamplesize = audiobufsize1;
+                //packet.data[packet.size] = 0;
+                uint8_t *ptr = packet.data;
+                int      len = packet.size;
+
+                while(len > 0)
+                {
+                    int ret = avcodec_decode_audio2(pDecCodecCtx, audiosample1,
+                            &audiosamplesize, ptr, len); //&audiosamplesize, packet.data, packet.size);
+                    len -= ret;
+                    ptr += ret;
+                    if (ret < 0)
+                    {
+                        VERBOSE(VB_RECORD, QString("Decode audio frame #%1 failed, error=%2").arg(nAudioFramesIn).arg(ret));
+                        nErrors++;
+                        len = 0;
+                    }
+                    else if (ret == 0)
+                    {
+                        VERBOSE(VB_RECORD, QString("Decode audio frame #%1 [size=%2] was buffered or dropped ").arg(nAudioFramesIn).arg(ret));
+                        len = 0;
+                    }
+                    else
+                    {
+                        dbug(VB_RECORD, QString("Encoding audio frame #%1 [size=%2, ret=%3]").arg(nAudioFramesIn).arg(audiosamplesize).arg(ret));
+
+                        int16_t *audiosamplesdec = audiosample1;
+
+                        uint8_t *buf = (uint8_t*)audiosamplesdec;
+                        int     size = audiosamplesize;
+
+                        if (packet.dts != AV_NOPTS_VALUE)
+                        {
+                            a_decode_pts  = av_rescale_q(packet.dts, pDecStream->time_base, AV_TIME_BASE_Q);
+                            a_decode_pts -= a_decode_pts_offset;    // m_ptsOffset is in AV_TIME_BASE units
+                        }
+
+                        double sync_ipts = (double)(a_decode_pts) / AV_TIME_BASE;        // how many seconds into input stream are we?
+                        sync_ipts        = (sync_ipts > av_sync_offset_sec ? sync_ipts - av_sync_offset_sec: sync_ipts);
+
+                        double delta = (sync_ipts * pEncCodecCtx->sample_rate)
+                                        - nAudioSamples
+                                        - (av_fifo_size(audiofifo)
+                                            / (pEncCodecCtx->channels
+                                                * audio_sample_size_bytes));
+                        double idelta  = delta * pDecCodecCtx->sample_rate / pEncCodecCtx->sample_rate;
+                        int byte_delta = ((int)idelta) * audio_sample_size_bytes * pDecCodecCtx->channels;
+                        int n_empty_samples_to_insert = 0;
+
+                        //check if sync should be done
+                        double au_desync_sec   = fabs(delta / pEncCodecCtx->sample_rate);
+                        bool b_perform_av_sync = (av_desync_sec < 5)
+                                                  //&& (au_desync_sec < 5)
+                                                  && (FFABS(byte_delta) < au_max_byte_delta);
+                        //dont sync if a/v or audio desync is > 5 sec
+                        if (!b_perform_av_sync)
+                        {
+                            VERBOSE(VB_RECORD, LOC
+                                        + QString("desync [a/v=%1s, au=%2s] not "
+                                            "performing  sync for frame #%3 "
+                                            "bdelta=%4 nAudioSamples=%5 fifo_size=%6 "
+                                            "sync_ipts=%7 dts=%8!")
+                                            .arg(av_desync_sec).arg(au_desync_sec)
+                                            .arg(nFrames)
+                                            .arg(byte_delta).arg(nAudioSamples)
+                                            .arg(av_fifo_size(audiofifo))
+                                            .arg(sync_ipts).arg(packet.dts));
+                        }
+
+                        //FIXME resample delay
+                        if((fabs(delta) > 50) && b_perform_av_sync)
+                        {
+                            double audio_drift_threshold = 0.01;
+                            if(fabs(delta) > audio_drift_threshold * pEncCodecCtx->sample_rate)
+                            {
+                                if(byte_delta < 0)
+                                {
+                                    byte_delta = FFMAX(byte_delta, -size);
+                                    size += byte_delta;
+                                    buf  -= byte_delta;
+                                    dbug(VB_RECORD, LOC
+                                            + QString("sync delta=%1 discarding %2 audio bytes")
+                                                .arg(delta).arg((int)-byte_delta));
+                                    nSamplesDropped -= delta;
+                                }
+                                else
+                                {
+                                    n_empty_samples_to_insert = byte_delta;
+                                    nSamplesAdded += delta;
+                                    dbug(VB_RECORD, LOC
+                                            + QString("sync delta=%1 adding %2 audio samples (%3 bytes) of silence")
+                                                .arg(delta).arg((int)delta).arg(n_empty_samples_to_insert));
+                                }
+                                audiosamplesdec = (int16_t*)buf;
+                                audiosamplesize = size;
+                            }
+                            else if(pAudioResampleCtx)
+                            {
+                                int audio_sync_tolerance = (int)(pEncCodecCtx->sample_rate / 100);    //stretch squeeze by 1% max
+                                int comp = av_clip(delta, -audio_sync_tolerance, audio_sync_tolerance);
+                                dbug(VB_RECORD, LOC
+                                            + QString("sync delta=%1 resample "
+                                                "compensating %2 over %3 audio samples")
+                                                .arg(delta).arg(comp).arg(pEncCodecCtx->sample_rate));
+                                if (comp >= 0)
+                                    nSamplesCompdPos += comp;
+                                else
+                                    nSamplesCompdNeg -= comp;
+                                //fprintf(stderr, "drift:%f len:%d opts:%"PRId64" ipts:%"PRId64" fifo:%d\n", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));
+                                av_resample_compensate(*(struct AVResampleContext**)pAudioResampleCtx,
+                                        comp, pEncCodecCtx->sample_rate);
+                            }
+                        }
+
+                        int nresampled      = 0;
+                        int nframesizebytes = pEncCodecCtx->frame_size
+                                                * pEncCodecCtx->channels
+                                                * audio_sample_size_bytes;
+                        int nsamples        = audiosamplesize
+                                                / (pDecCodecCtx->channels
+                                                    * audio_sample_size_bytes);
+                        int nDecChannels    = pDecCodecCtx->channels;
+
+                        uint8_t *audiosamplefifo = NULL;
+
+
+                        if (b_multi_to_stereo)
+                        {
+                            nsamples  = multi_to_stereo(audiosample3,
+                                                        (audiobufsize3 / 2),
+                                                        audiosamplesdec, nsamples,
+                                                        pDecCodecCtx->channels);
+                            int oldaudiosamplesize = audiosamplesize;
+                            audiosamplesize = nsamples * 2 * audio_sample_size_bytes;
+                            nDecChannels    = 2;
+                            audiosamplesdec = audiosample3;
+                            dbug(VB_RECORD, LOC + QString("Multi-to-stereo audio: %1 -> %2 bytes")
+                                                .arg(oldaudiosamplesize).arg(audiosamplesize));
+                        }
+
+                        if (pAudioResampleCtx)
+                        {
+                            nresampled      = audio_resample(pAudioResampleCtx,
+                                                            audiosample2,
+                                                            audiosamplesdec,
+                                                            nsamples);
+                            audiosamplefifo = (uint8_t*) audiosample2;
+                            audiosamplesize = nresampled * nDecChannels
+                                                * audio_sample_size_bytes;
+                        }
+                        else
+                        {
+                            audiosamplefifo = (uint8_t*) audiosamplesdec;
+                        }
+
+                        int out_size = 0;
+                        av_fifo_generic_write(audiofifo, audiosamplefifo,
+                                audiosamplesize, NULL);
+
+                        int zeroed = 0;
+
+                        while (av_fifo_size(audiofifo) >= nframesizebytes)
+                        {
+                            if (n_empty_samples_to_insert > 0)
+                            {
+                                int insert = 0;
+                                //first insert empty samples for silence before reading from fifo
+                                if (n_empty_samples_to_insert < nframesizebytes)
+                                {
+                                    insert = n_empty_samples_to_insert;
+                                    if (insert > zeroed)
+                                    {
+                                        memset(audiofifobuf, 0, insert);    //insert bytes of silence
+                                        zeroed = insert;
+                                    }
+                                    //then fill the rest from the fifo
+                                    av_fifo_generic_read(audiofifo,
+                                            (audiofifobuf + insert),
+                                            (nframesizebytes - insert), NULL);
+                                }
+                                else
+                                {
+                                    insert = nframesizebytes;
+                                    if (insert > zeroed)
+                                    {
+                                        memset(audiofifobuf, 0, insert);
+                                        zeroed = insert;
+                                    }
+                                }
+                                n_empty_samples_to_insert -= insert;
+                                dbug(VB_RECORD, LOC
+                                            + QString("Added %1 empty bytes "
+                                                "(left=%2) and read %3 bytes from "
+                                                "fifo (%4)").arg(insert)
+                                                .arg(n_empty_samples_to_insert)
+                                                .arg(nframesizebytes - insert)
+                                                .arg(av_fifo_size(audiofifo)));
+                            }
+                            else
+                            {
+                                av_fifo_generic_read(audiofifo, audiofifobuf,
+                                        nframesizebytes, NULL);
+                            }
+
+                            out_size = avcodec_encode_audio(pEncCodecCtx, outbuf, outbuf_size,
+                                        (int16_t*)audiofifobuf);
+
+                            if (out_size < 0)
+                            {
+                                dbug(VB_RECORD, QString("Encode audio frame #%1 failed [ret=%2]")
+                                        .arg(nAudioFramesIn).arg(out_size));
+                            }
+                            else if (out_size == 0)
+                            {
+                                dbug(VB_RECORD, QString("Encode audio frame #%1 dropped or buffered [ret=%2]")
+                                        .arg(nAudioFramesIn).arg(out_size));
+                            }
+                            else
+                            {
+                                AVPacket packet_out;
+                                av_init_packet(&packet_out);
+
+                                packet_out.data         = outbuf;
+                                packet_out.size         = out_size;
+                                packet_out.stream_index = packet.stream_index;
+                                packet_out.flags       |= PKT_FLAG_KEY;
+
+                                if ((pEncCodecCtx->coded_frame)
+                                    && (pEncCodecCtx->coded_frame->pts != AV_NOPTS_VALUE))
+                                {
+                                    packet_out.pts = av_rescale_q(
+                                                        pEncCodecCtx->coded_frame->pts,
+                                                        pEncCodecCtx->time_base,
+                                                        pEncStream->time_base);    // - a_decode_pts_offset;
+                                }
+
+                                dbug(VB_RECORD, QString("Writing audio frame #%1 [size=%2]")
+                                        .arg(nAudioFrames).arg(out_size));
+
+                                if (av_interleaved_write_frame(pFormatCtxEncode, &packet_out) != 0)
+                                {
+                                    dbug(VB_RECORD, QString("write audio frame=#%1 pts=%2 failed") \
+                                                        .arg(nAudioFrames).arg(packet_out.pts));
+                                }
+                                nAudioFrames++;
+                                nAudioSamples += pEncCodecCtx->frame_size;
+
+                                dbug(VB_RECORD, QString("Wrote audio frame #%1 [size=%2, samples=%3] pts=%4")
+                                        .arg(nAudioFrames).arg(out_size).arg(pEncCodecCtx->frame_size).arg(packet_out.pts));
+                                av_free_packet(&packet_out);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        av_free_packet(&packet);
+        nFrames++;
+        //output once in ~30 sec
+        if (b_wrote_video_frame)
+        {
+            ++nDisplayIntervalCount;
+            if (nDisplayIntervalCount == 25 * 30)
+            {
+                nDisplayIntervalCount = 0;
+                VERBOSE(VB_RECORD, LOC
+                            + QString("Stats: in[total=%1, v=%2, a=%3], "
+                                "out[v=%4, a=%5], vsync[drop=%6/%7, dup=%8/%9], "
+                                "async[drop=%10, add=%11 comp=+%12/-%13], "
+                                "errors=%14")
+                                .arg(nFrames).arg(nVideoFramesIn).arg(nAudioFramesIn)
+                                .arg(nVideoFrames).arg(nAudioFrames)
+                                .arg(nFramesDropped).arg(nFramesDropped2)
+                                .arg(nFramesDuped).arg(nFramesDuped2)
+                                .arg(nSamplesDropped).arg(nSamplesAdded)
+                                .arg(nSamplesCompdPos).arg(nSamplesCompdNeg).arg(nErrors));
+            }
+        }
+    }
+    av_write_trailer(pFormatCtxEncode);
+    av_log_set_level(AV_LOG_QUIET);
+
+    if (b_multi_to_stereo)
+    {
+        av_free(audiosample3);
+    }
+    if (pAudioResampleCtx)
+    {
+        audio_resample_close(pAudioResampleCtx);
+        av_free(audiosample2);
+    }
+
+    url_fclose(pFormatCtxEncode->pb);
+    cleanup_av(pFormatCtxEncode, pFormatCtxDecode, scaleContext, opencodecs);
+    av_free(pFrame);
+
+    av_fifo_free(audiofifo);
+    av_free(audiofifobuf);
+
+    if (buffer)
+    {
+        av_free(buffer);
+        free(newPicture);
+        av_free(newFrame);
+    }
+
+    if (b_deinterlace)
+    {
+        free(pPicture);
+    }
+
+    av_free(outbuf);
+    av_free(audiosample1);
+
+    VERBOSE(VB_RECORD, LOC
+                + QString("Stats: in[total=%1, v=%2, a=%3], "
+                    "out[v=%4, a=%5], vsync[drop=%6/%7, dup=%8/%9], "
+                    "async[drop=%10, add=%11 comp=+%12/-%13], "
+                    "errors=%14")
+                    .arg(nFrames).arg(nVideoFramesIn).arg(nAudioFramesIn)
+                    .arg(nVideoFrames).arg(nAudioFrames)
+                    .arg(nFramesDropped).arg(nFramesDropped2)
+                    .arg(nFramesDuped).arg(nFramesDuped2)
+                    .arg(nSamplesDropped).arg(nSamplesAdded)
+                    .arg(nSamplesCompdPos).arg(nSamplesCompdNeg).arg(nErrors));
+
+    if (m_nDeleteDelaySecs > 0)
+    {
+        //delete file
+        sleep(m_nDeleteDelaySecs);
+        bool bDeleted = QFile::exists(m_sOutputFileName)
+                        && QFile::remove(m_sOutputFileName);
+        VERBOSE(VB_RECORD, LOC + QString("Delete output file %1 after %2 sec,"
+                "result=%3.").arg(m_sOutputFileName).arg(m_nDeleteDelaySecs)
+                .arg((bDeleted ? "OK" : "ERROR")));
+    }
+
+    VERBOSE(VB_RECORD, LOC + QString("done!"));
+    return;
+}
Index: programs/mythbackend/mythbackend.pro
===================================================================
--- programs/mythbackend/mythbackend.pro	(revision 4503)
+++ programs/mythbackend/mythbackend.pro	(working copy)
@@ -11,7 +11,7 @@
 INSTALLS = target
 
 setting.path = $${PREFIX}/share/mythtv/
-setting.files += devicemaster.xml deviceslave.xml MXML_scpd.xml
+setting.files += devicemaster.xml deviceslave.xml MXML_scpd.xml AVT_scpd.xml SRS_scpd.xml
 
 INSTALLS += setting
 
@@ -22,12 +22,14 @@
 HEADERS += playbacksock.h scheduler.h server.h housekeeper.h backendutil.h
 HEADERS += upnpcdstv.h upnpcdsmusic.h upnpcdsvideo.h mediaserver.h
 HEADERS += mythxml.h upnpmedia.h main_helpers.h backendcontext.h
+HEADERS += upnpcdsepg.h upnpavt.h upnpsrs.h transcoder.h
 
 SOURCES += autoexpire.cpp encoderlink.cpp filetransfer.cpp httpstatus.cpp
 SOURCES += main.cpp mainserver.cpp playbacksock.cpp scheduler.cpp server.cpp
 SOURCES += housekeeper.cpp backendutil.cpp
 SOURCES += upnpcdstv.cpp upnpcdsmusic.cpp upnpcdsvideo.cpp mediaserver.cpp
 SOURCES += mythxml.cpp upnpmedia.cpp main_helpers.cpp backendcontext.cpp
+SOURCES += upnpcdsepg.cpp upnpavt.cpp upnpsrs.cpp transcoder.cpp
 
 using_oss:DEFINES += USING_OSS
 
Index: programs/mythbackend/mythxml.h
===================================================================
--- programs/mythbackend/mythxml.h	(revision 4503)
+++ programs/mythbackend/mythxml.h	(working copy)
@@ -4,6 +4,8 @@
 // Purpose - MythTV XML protocol HttpServerExtension
 //
 // Created By  : David Blain                    Created On : Oct. 24, 2005
+// Modified By : Harold Sutherland              Modified On: Jul. 13, 2009
+// Modified By : Kunal Kandekar                 Modified On: Mar. 01, 2010
 // Modified By :                                Modified On:
 //
 //////////////////////////////////////////////////////////////////////////////
@@ -17,6 +19,7 @@
 
 #include "upnp.h"
 #include "eventing.h"
+#include "transcoder.h"
 
 #include "autoexpire.h"
 #include "mythcontext.h"
@@ -59,6 +62,9 @@
     MXML_GetFileList            = 21,
     MXML_GetFileLinks           = 22,
 
+    MXML_ChangeChannel          = 23,
+    MXML_GetLiveTV              = 24,
+
 } MythXMLMethod;
 
 /////////////////////////////////////////////////////////////////////////////
@@ -131,6 +137,18 @@
         void    GetDeviceDesc  ( HTTPRequest *pRequest );
         void    GetFile        ( HTTPRequest *pRequest, QString sFileName );
 
+        void    ChangeChannel  ( HTTPRequest      *pRequest );
+        void    GetLiveTV      ( HttpWorkerThread *pThread,
+                                 HTTPRequest      *pRequest );
+        void    ConfigureTranscoder
+                               ( HTTPRequest      *pRequest,
+        		                 LiveTranscoder   *transcoder );
+        int     TranscodeVideo ( HttpWorkerThread *pThread,
+                                 HTTPRequest      *pRequest,
+                                 const QString    &sId,
+                                 bool             bTranscodeByDefault,
+                                 bool             bForkByDefault,
+                                 bool             bIsLive );
     public:
                  MythXML( UPnpDevice *pDevice , const QString &sSharePath);
         virtual ~MythXML();
@@ -149,6 +167,9 @@
                                       ProgramInfo  *pInfo,
                                       bool          bDetails = true );
 
+    //static members
+    public:
+        static QMutex recordingInstanceLock;
 };
 
 /////////////////////////////////////////////////////////////////////////////
@@ -183,6 +204,8 @@
         QString         m_sBaseFileName;
         QString         m_sFileName;
         QString         m_sVideoID;
+        void            *m_oData;
+        void            (*m_pfdestructor)(void *object);
 
         int             m_nTrackNumber;
 
@@ -198,6 +221,8 @@
             m_eType        = DT_Music;
             m_nTrackNumber = nTrackNumber;
             m_sFileName    = sFileName;
+            m_oData        = NULL;
+            m_pfdestructor = NULL;            
         }
 
         ThreadData( const QString &sChanId,
@@ -209,8 +234,24 @@
             m_sStartTime   = sStartTime;
             m_sFileName    = sFileName;
             m_nTrackNumber = 0;
+            m_oData        = NULL;
+            m_pfdestructor = NULL;
         }
 
+        ThreadData( ThreadDataType eType,
+                    const QString &sVideoID,
+                    const QString &sFileName,
+                    void          *oData,
+                    void          (*pfDestructor)(void *))
+        {
+            m_eType        = eType;
+            m_sVideoID     = sVideoID;
+            m_sFileName    = sFileName;
+            m_oData        = oData;
+            m_pfdestructor = pfDestructor;
+            m_nTrackNumber = 0;
+        }
+
         ThreadData( const QString &sVideoID,
                     const QString &sFileName )
         {
@@ -223,6 +264,7 @@
 
         virtual ~ThreadData()
         {
+            if (m_oData && m_pfdestructor) m_pfdestructor(m_oData);
         }
 
         void SetFileData( const QString &sStorageGroup,
Index: programs/mythbackend/mainserver.cpp
===================================================================
--- programs/mythbackend/mainserver.cpp	(revision 4503)
+++ programs/mythbackend/mainserver.cpp	(working copy)
@@ -118,7 +118,9 @@
 
 QMutex MainServer::truncate_and_close_lock;
 const uint MainServer::kMasterServerReconnectTimeout = 1000; //ms
+MainServer *MainServer::mainServer;
 
+
 class ProcessRequestThread : public QThread
 {
   public:
@@ -230,6 +232,7 @@
         sched->SetMainServer(this);
     if (expirer)
         expirer->SetMainServer(this);
+    MainServer::SetInstance(this);
 
     autoexpireUpdateTimer = new QTimer(this);
     connect(autoexpireUpdateTimer, SIGNAL(timeout()), this,
@@ -1873,6 +1876,28 @@
         delete_file_immediately( sFileName, followLinks, true);
     }
 
+    /* Delete any transcoded files . */
+    QStringList extensions;
+    extensions << "flv" << "swf" << "mp4" << "mpeg";
+    for (uint iext = 0; iext < extensions.size(); ++iext)
+    {
+		QString nameFilter = fInfo.fileName() + "*." + extensions.at(iext);
+		// QDir's nameFilter uses spaces or semicolons to separate globs,
+		// so replace them with the "match any character" wildcard
+		// since mythrename.pl may have included them in filenames
+		nameFilter.replace(QRegExp("( |;)"), "?");
+		QDir      dir  ( fInfo.path(), nameFilter );
+
+		for (uint nIdx = 0; nIdx < dir.count(); nIdx++)
+		{
+			QString sFileName = QString( "%1/%2" )
+								   .arg( fInfo.path() )
+								   .arg( dir[ nIdx ] );
+
+			delete_file_immediately( sFileName, followLinks, true);
+		}
+    }
+
     DeleteRecordedFiles(ds);
 
     DoDeleteInDB(ds);
Index: programs/mythbackend/mediaserver.h
===================================================================
--- programs/mythbackend/mediaserver.h	(revision 4503)
+++ programs/mythbackend/mediaserver.h	(working copy)
@@ -4,6 +4,8 @@
 // Purpose - uPnp Media Server main Class
 //
 // Created By  : David Blain                    Created On : Jan. 15, 2007
+// Modified By : Harold Sutherland              Modified On: Oct. 16, 2009
+// Modified By : Kunal Kandekar                 Modified On: Jan. 19, 2010
 // Modified By :                                Modified On:
 //
 //////////////////////////////////////////////////////////////////////////////
@@ -18,6 +20,8 @@
 #include "upnpcmgr.h"
 #include "upnpmsrr.h"
 #include "upnpmedia.h"
+#include "upnpsrs.h"
+#include "upnpavt.h"
 
 //////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////
@@ -34,6 +38,8 @@
 
         UPnpCDS         *m_pUPnpCDS;     // Do not delete (auto deleted)
         UPnpCMGR        *m_pUPnpCMGR;    // Do not delete (auto deleted)
+        UPnpSRS         *m_pUPnpSRS;      // Do not delete (auto deleted)
+        UPnpAVT         *m_pUPnpAVT;      // Do not delete (auto deleted)
         UPnpMedia       *upnpMedia;
 
         QString          m_sSharePath;
Index: programs/mythbackend/upnpcdsepg.h
===================================================================
--- programs/mythbackend/upnpcdsepg.h	(revision 0)
+++ programs/mythbackend/upnpcdsepg.h	(revision 0)
@@ -0,0 +1,59 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: upnpcdsepg.h
+//                                                                            
+// Purpose - uPnp Content Directory Extention for Recorded EPG 
+//                                                                            
+// Created By  : Harold Sutherland              Created On : Jun. 23, 2009
+// Modified By :                                Modified On:                  
+//                                                                            
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef UPnpCDSEPG_H_
+#define UPnpCDSEPG_H_
+
+#include "mainserver.h"
+#include "upnpcds.h"
+              
+//////////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpCDSEpg : public UPnpCDSExtension
+{
+    private:
+
+        static UPnpCDSRootInfo g_RootNodes[];
+        static int             g_nRootCount;
+
+        QStringMap             m_mapBackendIp;
+        QStringMap             m_mapBackendPort;
+
+    protected:
+
+        virtual bool             IsBrowseRequestForUs( UPnpCDSRequest *pRequest );
+        virtual bool             IsSearchRequestForUs( UPnpCDSRequest *pRequest );
+
+        virtual UPnpCDSRootInfo *GetRootInfo   (int nIdx);
+        virtual int              GetRootCount  ( );
+        virtual QString          GetTableName  ( QString sColumn );
+        virtual QString          GetItemListSQL( QString sColumn = "" );
+
+        virtual void             BuildItemQuery( MSqlQuery        &query, 
+                                                 const QStringMap &mapParams );
+
+        virtual void             AddItem( const QString           &sObjectId,
+                                          UPnpCDSExtensionResults *pResults,
+                                          bool                     bAddRef, 
+                                          MSqlQuery               &query );
+
+    public:
+
+        UPnpCDSEpg( ) : UPnpCDSExtension( "Program Guide", "Epg",
+                                          "object.item.videoItem" )
+        {
+        }
+
+        virtual ~UPnpCDSEpg() {}
+};
+
+#endif
Index: programs/mythbackend/upnpsrs.h
===================================================================
--- programs/mythbackend/upnpsrs.h	(revision 0)
+++ programs/mythbackend/upnpsrs.h	(revision 0)
@@ -0,0 +1,247 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: UPnpSRS.cpp
+// Created     : Jul 13 2009
+// Modified    : Mar 01 2010
+//
+// Authors     : Kunal Kandekar, Harold Sutherland
+//
+// Purpose     : UPnP Scheduled Recording Service
+//                                                                            
+// Copyright (c) 
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef UPNPSRS_H_
+#define UPNPSRS_H_
+
+#include "httpserver.h"
+#include "eventing.h"
+#include "scheduler.h"
+#include "mainserver.h"
+#include "upnpcds.h"
+#include "upnp.h"
+#include "upnpsrsobjects.h"
+
+typedef enum 
+{
+    SRSM_Unknown                    =  0,
+    SRSM_GetSortCapabilities        =  1,
+    SRSM_GetPropertyList            =  2,
+    SRSM_GetAllowedValues           =  3,
+    SRSM_GetStateUpdateID           =  4,
+    SRSM_BrowseRecordSchedules      =  5,
+    SRSM_BrowseRecordTasks          =  6,
+    SRSM_CreateRecordSchedule       =  7,
+    SRSM_DeleteRecordSchedule       =  8,
+    SRSM_GetRecordSchedule          =  9,
+    SRSM_EnableRecordSchedule       = 10,
+    SRSM_DisableRecordSchedule      = 11,
+    SRSM_DeleteRecordTask           = 12,
+    SRSM_GetRecordTask              = 13,
+    SRSM_EnableRecordTask           = 14,
+    SRSM_DisableRecordTask          = 15,
+    SRSM_ResetRecordTask            = 16,
+    SRSM_GetRecordScheduleConflicts = 17,
+    SRSM_GetRecordTaskConflicts     = 18,
+    SRSM_GetServiceDescription      = 19 
+
+} UPnpSRSMethod;
+
+//////////////////////////////////////////////////////////////////////////////
+
+typedef enum 
+{
+    SRSSTATUS_Unknown               = 0,
+    SRSSTATUS_OK                    = 1,
+
+} UPnpSRSRecordingStatus;
+
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpSRSRequest
+{
+    public:
+        QString           m_sFilter;
+        short             m_nStartingIndex;
+        short             m_nRequestedCount;
+        QString           m_sSortCriteria;
+
+        QString           m_sElements;
+
+        // Browse specific properties
+
+        QString           m_sRecordScheduleID;
+
+        // Search specific properties
+
+        QString           m_sSearchCriteria;
+        QStringList       m_sSearchList;
+        QString           m_sSearchClass;
+
+    public:
+
+        UPnpSRSRequest() : m_nStartingIndex ( 0 ),
+                           m_nRequestedCount( 0 )
+        {
+        }
+};
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//
+// UPnpSRS Class Definition
+//
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpSRS : public Eventing
+{
+    private:
+
+        QString         m_sServiceDescFileName;
+        QString         m_sControlUrl;
+
+        static QMutex   globalSRSLock;
+
+
+        UPnpSRSMethod   GetMethod                       ( const QString &sURI );
+
+        void            HandleGetSortCapabilities       ( HTTPRequest *pRequest );
+        void            HandleGetPropertyList           ( HTTPRequest *pRequest );
+        void            HandleGetAllowedValues          ( HTTPRequest *pRequest );
+        void            HandleGetStateUpdateID          ( HTTPRequest *pRequest );
+        void            HandleBrowseRecordSchedules     ( HTTPRequest *pRequest );
+        void            HandleBrowseRecordTasks         ( HTTPRequest *pRequest );
+        void            HandleCreateRecordSchedule      ( HTTPRequest *pRequest );
+        void            HandleDeleteRecordSchedule      ( HTTPRequest *pRequest );
+        void            HandleGetRecordSchedule         ( HTTPRequest *pRequest );
+        void            HandleEnableRecordSchedule      ( HTTPRequest *pRequest );
+        void            HandleDisableRecordSchedule     ( HTTPRequest *pRequest );
+        void            HandleDeleteRecordTask          ( HTTPRequest *pRequest );
+        void            HandleGetRecordTask             ( HTTPRequest *pRequest );
+        void            HandleEnableRecordTask          ( HTTPRequest *pRequest );
+        void            HandleDisableRecordTask         ( HTTPRequest *pRequest );
+        void            HandleResetRecordTask           ( HTTPRequest *pRequest );
+        void            HandleGetRecordScheduleConflicts( HTTPRequest *pRequest );
+        void            HandleGetRecordTaskConflicts    ( HTTPRequest *pRequest );
+
+    protected:
+
+        // Implement UPnpServiceImpl methods that we can
+
+        virtual QString GetServiceType      () { return "urn:schemas-upnp-org:service:ScheduledRecording:2"; }
+        virtual QString GetServiceId        () { return "urn:upnp-org:serviceId:SRS_2-0"; }
+        virtual QString GetServiceControlURL() { return m_sControlUrl.mid( 1 ); }
+        virtual QString GetServiceDescURL   () { return m_sControlUrl.mid( 1 ) + "/GetServDesc"; }
+
+    public:
+        UPnpSRS(       UPnpDevice *pDevice,
+                 const QString    &sSharePath);
+
+        virtual ~UPnpSRS();
+
+        virtual bool     ProcessRequest( HttpWorkerThread *pThread, HTTPRequest *pRequest );
+
+        //static functions
+        static int             GetPendingMatchingRecs      ( RecordingInfo *pginfo,
+                                                             RecList       &sortList );
+        static RecordingInfo  *GetRecordingFromAllScheduled( int           recordId  );
+        static RecordingInfo  *GetRecordingFromAllPending  ( int           recordId  );
+        static int             AddScheduledRecording       ( RecordingInfo *rec      );
+        static int             GetAllScheduledPrograms     ( RecList       &recList  );
+        static int             LoadRecordingInfo           ( RecordingInfo *pginfo   );
+        static QStringList     GetScheduleStateValue       ( RecordingInfo *pginfo   );
+        static QStringList     GetTaskStateValues          ( RecordingInfo *pginfo,
+                                                             const QString &taskId   );
+        static QString         GetTaskErrorValues          ( RecordingInfo *pginfo,
+                                                             const QString  &taskId,
+                                                             const QString  &schedError);
+        static SRSObject      *ToRecordScheduleSRSObject   ( RecordingInfo *pginfo,
+                                                             SRSObject     *input = NULL );
+        static RecordingInfo  *FromRecordScheduleSRSObject ( SRSObject     *srsObject );
+        static QList<SRSObject*> ToRecordTaskSRSObjects    ( RecordingInfo *pginfo    );
+        static bool            ParseCdsEpgId               ( const QString &cdsId,
+                                                             QString       &sChanId,
+                                                             QString       &sStartTime,
+                                                             QString       &sEndtime  );
+
+
+        const static QString  sSRSStartTag;
+        const static QString  sSRSEndTag;
+        const static QString  sSRSSupportedProgramCodeType;
+
+        const static QString  sXMLStartTag;
+        const static QString  sStateEventStartTag;
+        const static QString  sStateEventEndTag;
+
+        const static char     *sStateEventRecordScheduleCreated;
+        const static char     *sStateEventRecordScheduleDeleted;
+        const static char     *sStateEventRecordScheduleModified;
+        const static char     *sStateEventRecordTaskCreated;
+        const static char     *sStateEventRecordTaskDeleted;
+        const static char     *sStateEventRecordTaskModified;
+
+        static QMutex         StateUpdateIDMutex;
+        static int            nStateUpdateID;
+
+        const static QString  recordScheduleAllowedValuesXML;
+        const static QString  recordTaskAllowedValuesXML;
+        const static QString  recordSchedulePartsAllowedValuesXML;
+
+};
+
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//
+// UPnpSRMonitor Class Definition
+//
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+
+class UPnpSRMonitor : public QThread
+{
+    private:
+        UPnpSRMonitor()
+        {
+        }
+
+        static QMutex         instanceLock;
+        static UPnpSRMonitor *instance;
+        static QSet<UPnpSRS*> srsInstances;
+        static QSet<QString>  alreadyEvented;
+
+    public:
+        ~UPnpSRMonitor()
+        {
+
+        }
+
+        static void spawn()
+        {
+            QMutexLocker locker(&UPnpSRMonitor::instanceLock);
+            if (!instance)
+            {
+                instance = new UPnpSRMonitor();
+                instance->start();
+            }
+        }
+        static  void NotifyEvented ( const QString &sEventSummary );
+        static  void RegisterSRS   ( UPnpSRS* srs );
+        static  void UnregisterSRS ( UPnpSRS* srs );
+        virtual void run();
+};
+#endif
Index: programs/mythbackend/upnpavt.cpp
===================================================================
--- programs/mythbackend/upnpavt.cpp	(revision 0)
+++ programs/mythbackend/upnpavt.cpp	(revision 0)
@@ -0,0 +1,1537 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: UPnpAVT.cpp
+// Created     : Jun 29, 2009
+// Modified    : Jan 19, 2010
+//
+// Authors     : Kunal Kandekar
+//
+// Purpose     : UPnP AVTransport Service
+//                                                                            
+// Copyright (c) 2010
+//                                          
+// This library is free software; you can redistribute it and/or 
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#include "upnp.h"
+#include "upnpavt.h"
+#include "upnputil.h"
+#include "mythcontext.h"
+#include "playbacksock.h"
+#include "recordingrule.h"
+#include "cardutil.h"
+
+#include <QHostInfo>
+#include <QUrl>
+#include <qtextdocument.h>
+
+//Initialize static const members
+const QStringList  UPnpAVTState::NonLastChangeEvented = QString("RelativeTimePosition,AbsoluteTimePosition,"
+        "RelativeCounterPosition,AbsoluteCounterPosition,LastChange").split(',');
+const QString UPnpAVTState::AVTState_TransportState_STOPPED               = "STOPPED";
+const QString UPnpAVTState::AVTState_TransportState_PLAYING               = "PLAYING";
+const QString UPnpAVTState::AVTState_TransportState_TRANSITIONING         = "TRANSITIONING";
+const QString UPnpAVTState::AVTState_TransportState_PAUSED_PLAYBACK       = "PAUSED_PLAYBACK";
+const QString UPnpAVTState::AVTState_TransportState_PAUSED_RECORDING      = "PAUSED_RECORDING";
+const QString UPnpAVTState::AVTState_TransportState_RECORDING             = "RECORDING";
+const QString UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT      = "NO_MEDIA_PRESENT";
+const QString UPnpAVTState::AVTState_TransportStatus_OK                   = "OK";
+const QString UPnpAVTState::AVTState_TransportStatus_ERROR_OCCURRED       = "ERROR_OCCURRED";
+const QString UPnpAVTState::AVTState_CurrentMediaCategory_NO_MEDIA        = "NO_MEDIA";
+const QString UPnpAVTState::AVTState_CurrentMediaCategory_TRACK_AWARE     = "TRACK_AWARE";
+const QString UPnpAVTState::AVTState_CurrentMediaCategory_TRACK_UNAWARE   = "TRACK_UNAWARE";
+const QString UPnpAVTState::AVTState_PlaybackStorageMedium_HDD            = "HDD";
+const QString UPnpAVTState::AVTState_PlaybackStorageMedium_NETWORK        = "NETWORK";
+const QString UPnpAVTState::AVTState_RecordStorageMedium_HDD              = "HDD";
+const QString UPnpAVTState::AVTState_CurrentPlayMode_DIRECT_1             = "DIRECT_1";
+const QString UPnpAVTState::AVTState_RecordMediumWriteStatus_WRITABLE     = "WRITABLE";
+const QString UPnpAVTState::AVTState_PossiblePlaybackStorageMedia_LIVE_TV = "NETWORK,HDD";
+const QString UPnpAVTState::AVTState_PossibleRecordStorageMedia_LIVE_TV   = "HDD";
+const QString UPnpAVTState::AVTState_TransportPlaySpeed_1                 = "1";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_0_EP        = "0:EP";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_1_LP        = "1:LP";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_2_SP        = "2:SP";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_0_BASIC     = "0:BASIC";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_1_MEDIUM    = "1:MEDIUM";
+const QString UPnpAVTState::AVTState_CurrentRecordQualityMode_2_HIGH      = "2:HIGH";
+const QString UPnpAVTState::AVTState_PossibleRecordQualityModes_LIVE_TV   = "0:BASIC,1:MEDIUM,2:HIGH";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_PLAY         = "Play";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_STOP         = "Stop";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_PAUSE        = "Pause";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_SEEK         = "Seek";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_NEXT         = "Next";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_PREVIOUS     = "Previous";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_RECORD       = "Record";
+const QString UPnpAVTState::AVTState_CurrentTransportActions_LIVE_TV      = "Play,Stop,Record";
+const QString UPnpAVTState::AVTState_DRMState_OK                          = "OK";
+const QString UPnpAVTState::AVTState_DRMState_UNKNOWN                     = "UNKNOWN";
+const QString UPnpAVTState::AVTState_DRMState_PROCESSING_CONTENT_KEY      = "PROCESSING_CONTENT_KEY";
+const QString UPnpAVTState::AVTState_DRMState_CONTENT_KEY_FAILURE         = "CONTENT_KEY_FAILURE";
+const QString UPnpAVTState::AVTState_DRMState_ATTEMPTING_AUTHENTICATION   = "ATTEMPTING_AUTHENTICATION";
+const QString UPnpAVTState::AVTState_DRMState_FAILED_AUTHENTICATION       = "FAILED_AUTHENTICATION";
+const QString UPnpAVTState::AVTState_DRMState_NOT_AUTHENTICATED           = "NOT_AUTHENTICATED";
+const QString UPnpAVTState::AVTState_DRMState_DEVICE_REVOCATION           = "DEVICE_REVOCATION";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_TRACK_NR         = "TRACK_NR";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_ABS_TIME         = "ABS_TIME";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_REL_TIME         = "REL_TIME";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_ABS_COUNT        = "ABS_COUNT";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_REL_COUNT        = "REL_COUNT";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_CHANNEL_FREQ     = "CHANNEL_FREQ";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_TAPE_INDEX       = "TAPE-INDEX";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_REL_TAPE_INDEX   = "REL_TAPE-INDEX";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_FRAME            = "FRAME";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_REL_FRAME        = "REL_FRAME";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_STRING                    = "string";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_UI4                       = "ui4";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_I4                        = "i4";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_FLOAT                     = "float";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_DURATION                  = "00:00:00";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_ServiceType_AVTRANSPORT_2 = "AVTransport:2";
+const QString UPnpAVTState::AVTState_A_ARG_TYPE_StateVariableList_ALL     = "*";
+const QString UPnpAVTState::AVTState_Duration_00_00_00                    = "00:00:00";
+const QString UPnpAVTState::AVTState_NOT_IMPLEMENTED                      = "NOT_IMPLEMENTED";
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+UPnpAVTState::UPnpAVTState( QString &sInstanceID )
+{
+    InstanceID = sInstanceID;
+    encoder    = NULL;
+    chain      = NULL;
+    framerate  = 0;
+    AddAVTStateVariables();
+    SetAVTDefaultStateValues();
+    lastChangeSet.clear(); //we don't want changes from constructor to be notified
+}
+
+UPnpAVTState::~UPnpAVTState()
+{
+
+}
+
+QString UPnpAVTState::GetLastChangeValues()
+{
+    QString sLastChange = QString("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+            "<Event\n"
+            "  xmlns=\"urn:schemas-upnp-org:metadata-1-0/AVT\"\n"
+            "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
+            "  xsi:schemaLocation=\"\n"
+            "    urn:schemas-upnp-org:metadata-1-0/RCS/ \n"
+            "     http://www.upnp.org/schemas/av/rcs-event-v1-20060531.xsd\">\n\t"
+            "<InstanceID val=\"%1\">").arg(InstanceID);
+    for (QSet<QString>::const_iterator itr = lastChangeSet.constBegin();
+            itr != lastChangeSet.constEnd(); ++itr) {
+        QString sName = *itr;
+        sLastChange.append(QString("\n\t\t<%1 val=\"%2\"/>").arg(sName)
+                            .arg(Qt::escape(GetValue<QString>(sName))));
+    }
+    lastChangeSet.clear();
+    sLastChange.append("\n\t</InstanceID>\n</Event>");
+    VERBOSE(VB_UPNP, QString("UPnpAVTState::GetLastChangeValues : %1").arg(sLastChange));
+    return sLastChange;
+}
+
+void UPnpAVTState::AddAVTStateVariables()
+{
+    AddVariable( new StateVariable< QString >( "TransportState"              , false ) );
+    AddVariable( new StateVariable< QString >( "TransportStatus"             , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentMediaCategory"        , false ) );
+    AddVariable( new StateVariable< QString >( "PlaybackStorageMedium"       , false ) );
+    AddVariable( new StateVariable< QString >( "RecordStorageMedium"         , false ) );
+    AddVariable( new StateVariable< QString >( "PossiblePlaybackStorageMedia", false ) );
+    AddVariable( new StateVariable< QString >( "PossibleRecordStorageMedia"  , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentPlayMode"             , false ) );
+    AddVariable( new StateVariable< QString >( "TransportPlaySpeed"          , false ) );
+    AddVariable( new StateVariable< QString >( "RecordMediumWriteStatus"     , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentRecordQualityMode"    , false ) );
+    AddVariable( new StateVariable< QString >( "PossibleRecordQualityModes"  , false ) );
+    AddVariable( new StateVariable< QString >( "NumberOfTracks"              , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentTrack"                , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentTrackDuration"        , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentMediaDuration"        , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentTrackMetaData"        , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentTrackURI"             , false ) );
+    AddVariable( new StateVariable< QString >( "AVTransportURI"              , false ) );
+    AddVariable( new StateVariable< QString >( "AVTransportURIMetaData"      , false ) );
+    AddVariable( new StateVariable< QString >( "NextAVTransportURI"          , false ) );
+    AddVariable( new StateVariable< QString >( "NextAVTransportURIMetaData"  , false ) );
+    AddVariable( new StateVariable< QString >( "RelativeTimePosition"        , false ) );
+    AddVariable( new StateVariable< QString >( "AbsoluteTimePosition"        , false ) );
+    AddVariable( new StateVariable< QString >( "RelativeCounterPosition"     , false ) );
+    AddVariable( new StateVariable< QString >( "AbsoluteCounterPosition"     , false ) );
+    AddVariable( new StateVariable< QString >( "CurrentTransportActions"     , false ) );
+    AddVariable( new StateVariable< QString >( "DRMState"                    , false ) );
+}
+
+void UPnpAVTState::SetAVTDefaultStateValues()
+{
+    SetValue< QString >( "TransportState"              , UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT );
+    SetValue< QString >( "TransportStatus"             , UPnpAVTState::AVTState_TransportStatus_OK );
+    SetValue< QString >( "CurrentMediaCategory"        , UPnpAVTState::AVTState_CurrentMediaCategory_TRACK_UNAWARE );
+    SetValue< QString >( "PlaybackStorageMedium"       , UPnpAVTState::AVTState_PlaybackStorageMedium_NETWORK );
+    SetValue< QString >( "RecordStorageMedium"         , UPnpAVTState::AVTState_RecordStorageMedium_HDD );
+    SetValue< QString >( "PossiblePlaybackStorageMedia", UPnpAVTState::AVTState_PossiblePlaybackStorageMedia_LIVE_TV );
+    SetValue< QString >( "PossibleRecordStorageMedia"  , UPnpAVTState::AVTState_PossibleRecordStorageMedia_LIVE_TV );
+    SetValue< QString >( "CurrentPlayMode"             , UPnpAVTState::AVTState_CurrentPlayMode_DIRECT_1 );
+    SetValue< QString >( "TransportPlaySpeed"          , UPnpAVTState::AVTState_TransportPlaySpeed_1 );
+    SetValue< QString >( "RecordMediumWriteStatus"     , UPnpAVTState::AVTState_RecordMediumWriteStatus_WRITABLE );
+    SetValue< QString >( "CurrentRecordQualityMode"    , UPnpAVTState::AVTState_CurrentRecordQualityMode_1_MEDIUM );
+    SetValue< QString >( "PossibleRecordQualityModes"  , UPnpAVTState::AVTState_PossibleRecordQualityModes_LIVE_TV );
+    //TODO: see if we can Set the below two values to the channel numbers from myth
+    SetValue< QString >( "NumberOfTracks"              , QString::number(0) );
+    SetValue< QString >( "CurrentTrack"                , QString::number(0) );
+    SetValue< QString >( "CurrentTrackDuration"        , UPnpAVTState::AVTState_Duration_00_00_00 );
+    SetValue< QString >( "CurrentMediaDuration"        , UPnpAVTState::AVTState_Duration_00_00_00 );
+    SetValue< QString >( "NextAVTransportURI"          , UPnpAVTState::AVTState_NOT_IMPLEMENTED );
+    SetValue< QString >( "NextAVTransportURIMetaData"  , UPnpAVTState::AVTState_NOT_IMPLEMENTED );
+    SetValue< QString >( "RelativeTimePosition"        , UPnpAVTState::AVTState_Duration_00_00_00 );
+    SetValue< QString >( "AbsoluteTimePosition"        , UPnpAVTState::AVTState_Duration_00_00_00 );
+    SetValue< QString >( "RelativeCounterPosition"     , QString::number(0) );
+    SetValue< QString >( "AbsoluteCounterPosition"     , QString::number(0) );
+    SetValue< QString >( "CurrentTransportActions"     , UPnpAVTState::AVTState_CurrentTransportActions_LIVE_TV );
+    SetValue< QString >( "DRMState"                    , UPnpAVTState::AVTState_DRMState_OK );
+/*
+    SetValue< QString >( "CurrentTrackMetaData"        , "" );
+    SetValue< QString >( "CurrentTrackURI"             , ""  );
+    SetValue< QString >( "AVTransportURI"              , "" );
+    SetValue< QString >( "AVTransportURIMetaData"      , "" );
+    SetValue< QString >( "A_ARG_TYPE_SeekMode"         , UPnpAVTState::AVTState_A_ARG_TYPE_SeekMode_TRACK_NR );
+    SetValue< QString >( "A_ARG_TYPE_SeekTarget"       , UPnpAVTState::AVTState_A_ARG_TYPE_UI4 );
+    SetValue< QString >( "A_ARG_TYPE_InstanceID"       , QString::number(0) );
+    SetValue< QString >( "A_ARG_TYPE_DeviceUDN"        , UPnpAVTState::AVTState_A_ARG_TYPE_STRING );
+    SetValue< QString >( "A_ARG_TYPE_ServiceType"      , UPnpAVTState::AVTState_A_ARG_TYPE_ServiceType_AVTRANSPORT_2 );
+    SetValue< QString >( "A_ARG_TYPE_ServiceID"        , UPnpAVTState::AVTState_A_ARG_TYPE_STRING );
+    SetValue< QString >( "A_ARG_TYPE_StateVariableList", UPnpAVTState::AVTState_A_ARG_TYPE_StateVariableList_ALL );
+*/
+}
+
+//static member declarations
+QMutex                        UPnpAVT::instanceStateMapLock;
+QHash<QString, UPnpAVTState*> UPnpAVT::m_mapInstanceIDState;
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpAVT::UPnpAVT (        UPnpDevice *pDevice, 
+                   const  QString    &sSharePath )
+        : Eventing( "UPnpAVT", "AVT_Event", sSharePath )
+{
+
+    QString sUPnpDescPath = UPnp::g_pConfig->GetValue( "UPnP/DescXmlPath",
+                                                       sSharePath );
+    m_sSharePath           = sSharePath;
+    m_sServiceDescFileName = sUPnpDescPath + "AVT_scpd.xml";
+    m_sControlUrl          = "/AVT_Control";
+
+    // Add our Service Definition to the device.
+
+    RegisterService( pDevice );
+
+    //the only variable we event
+    AddVariable( new StateVariable< QString >( "LastChange"                  , true  ) );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpAVT::~UPnpAVT()
+{
+
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpAVTMethod UPnpAVT::GetMethod( const QString &sURI )
+{                        
+    if (sURI == "GetServDesc"               ) return AVTM_GetServiceDescription      ;
+    if (sURI == "SetAVTransportURI"         ) return AVTM_SetAVTransportURI          ;
+    if (sURI == "SetNextAVTransportURI"     ) return AVTM_SetNextAVTransportURI      ;
+    if (sURI == "GetMediaInfo"              ) return AVTM_GetMediaInfo               ; 
+    if (sURI == "GetMediaInfo_Ext"          ) return AVTM_GetMediaInfo_Ext           ;           
+    if (sURI == "GetTransportInfo"          ) return AVTM_GetTransportInfo           ;           
+    if (sURI == "GetPositionInfo"           ) return AVTM_GetPositionInfo            ;           
+    if (sURI == "GetDeviceCapabilities"     ) return AVTM_GetDeviceCapabilities      ;           
+    if (sURI == "GetTransportSettings"      ) return AVTM_GetTransportSettings       ;           
+    if (sURI == "Stop"                      ) return AVTM_Stop                       ;           
+    if (sURI == "Play"                      ) return AVTM_Play                       ;           
+    if (sURI == "Pause"                     ) return AVTM_Pause                      ;           
+    if (sURI == "Record"                    ) return AVTM_Record                     ;           
+    if (sURI == "Seek"                      ) return AVTM_Seek                       ;           
+    if (sURI == "Next"                      ) return AVTM_Next                       ;           
+    if (sURI == "Previous"                  ) return AVTM_Previous                   ;           
+    if (sURI == "SetPlayMode"               ) return AVTM_SetPlayMode                ;           
+    if (sURI == "SetRecordQualityMode"      ) return AVTM_SetRecordQualityMode       ;            
+    if (sURI == "GetCurrentTransportActions") return AVTM_GetCurrentTransportActions ;           
+    if (sURI == "GetDRMState"               ) return AVTM_GetDRMState                ;           
+    if (sURI == "GetStateVariables"         ) return AVTM_GetStateVariables          ;
+    if (sURI == "SetStateVariables"         ) return AVTM_SetStateVariables          ;
+
+    return AVTM_Unknown;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+bool UPnpAVT::ProcessRequest( HttpWorkerThread *pThread, HTTPRequest *pRequest )
+{
+    if (pRequest)
+    {
+        if (Eventing::ProcessRequest( pThread, pRequest ))
+            return true;
+
+        if ( pRequest->m_sBaseUrl != m_sControlUrl )
+        {
+            VERBOSE( VB_UPNP, QString("UPnpAVT::ProcessRequest - BaseUrl (%1) not ours...").arg(pRequest->m_sBaseUrl ));
+            return false;
+        }
+
+        VERBOSE( VB_UPNP, QString("UPnpAVT::ProcessRequest - Method (%1)").arg(pRequest->m_sMethod ));
+
+        switch( GetMethod( pRequest->m_sMethod ) )
+        {
+            case AVTM_GetServiceDescription      : pRequest->FormatFileResponse    ( m_sServiceDescFileName ); break;
+
+            case AVTM_SetAVTransportURI          : HandleSetAVTransportURI          ( pRequest ); break;
+            case AVTM_SetNextAVTransportURI      : HandleSetNextAVTransportURI      ( pRequest ); break;
+            case AVTM_GetMediaInfo               : HandleGetMediaInfo               ( pRequest ); break;
+            case AVTM_GetMediaInfo_Ext           : HandleGetMediaInfo_Ext           ( pRequest ); break;
+            case AVTM_GetTransportInfo           : HandleGetTransportInfo           ( pRequest ); break;
+            case AVTM_GetPositionInfo            : HandleGetPositionInfo            ( pRequest ); break;
+            case AVTM_GetDeviceCapabilities      : HandleGetDeviceCapabilities      ( pRequest ); break;
+            case AVTM_GetTransportSettings       : HandleGetTransportSettings       ( pRequest ); break;
+            case AVTM_Stop                       : HandleStop                       ( pRequest ); break;
+            case AVTM_Play                       : HandlePlay                       ( pRequest ); break;
+            case AVTM_Pause                      : HandlePause                      ( pRequest ); break;
+            case AVTM_Record                     : HandleRecord                     ( pRequest ); break;
+            case AVTM_Seek                       : HandleSeek                       ( pRequest ); break;
+            case AVTM_Next                       : HandleNext                       ( pRequest ); break;
+            case AVTM_Previous                   : HandlePrevious                   ( pRequest ); break;
+            case AVTM_SetPlayMode                : HandleSetPlayMode                ( pRequest ); break;
+            case AVTM_SetRecordQualityMode       : HandleSetRecordQualityMode       ( pRequest ); break;
+            case AVTM_GetCurrentTransportActions : HandleGetCurrentTransportActions ( pRequest ); break;
+            case AVTM_GetDRMState                : HandleGetDRMState                ( pRequest ); break;
+            case AVTM_GetStateVariables          : HandleGetStateVariables          ( pRequest ); break;
+            case AVTM_SetStateVariables          : HandleSetStateVariables          ( pRequest ); break;
+            
+            default:
+                UPnp::FormatErrorResponse( pRequest, UPnPResult_InvalidAction );
+                break;
+        }       
+        return true;
+    }
+
+    return false;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpAVTState *UPnpAVT::GetAVTState( QString &sInstanceID )
+{
+    UPnpAVTState *state = NULL;
+    QMutexLocker locker(&UPnpAVT::instanceStateMapLock);
+    if (UPnpAVT::m_mapInstanceIDState.contains(sInstanceID))
+        state = UPnpAVT::m_mapInstanceIDState.value(sInstanceID);
+    return state;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+UPnpAVTState *UPnpAVT::CreateAVTState( QString &sInstanceID )
+{
+    UPnpAVTState *state = NULL;
+    QMutexLocker locker(&UPnpAVT::instanceStateMapLock);
+    if (!UPnpAVT::m_mapInstanceIDState.contains(sInstanceID))
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::CreateAVTState : InstanceId='%1'").arg(sInstanceID));
+        state = new UPnpAVTState(sInstanceID);
+        UPnpAVT::m_mapInstanceIDState.insert(sInstanceID, state);
+    }
+    return state;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpAVT::DeleteAVTState( QString &sInstanceID )
+{
+    UPnpAVTState *state = NULL;
+    QMutexLocker locker(&UPnpAVT::instanceStateMapLock);
+    if (UPnpAVT::m_mapInstanceIDState.contains(sInstanceID))
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::DeleteAVTState : InstanceId='%1'").arg(sInstanceID));
+        state = UPnpAVT::m_mapInstanceIDState.value(sInstanceID);
+        UPnpAVT::m_mapInstanceIDState.remove(sInstanceID);
+        delete state;
+        return 1;
+    }
+    return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+EncoderLink *UPnpAVT::GetFreeRecorder( QString       &pbshost,
+                                       const QString &sChanId,
+                                       unsigned int  nSourceId,
+                                       QString       &sChanNum )
+{
+    QStringList strlist;
+    int retval = -1;
+
+    EncoderLink *encoder = NULL;
+    QString enchost;
+
+    bool lastcard = false;
+
+    if (gContext->GetSetting("LastFreeCard", "0") == "1")
+        lastcard = true;
+
+    QMap<int, EncoderLink *> *encoderList = MainServer::GetInstance()->encoderList;
+
+    QMap<int, EncoderLink *>::Iterator iter = encoderList->begin();
+    unsigned int nChanId = sChanId.toUInt();
+    for (; iter != encoderList->end(); ++iter)
+    {
+        EncoderLink *elink = *iter;
+
+        uint chanid, srcid = 0;
+        QString callsign, channame, channum, xmltv;
+        chanid = nChanId;
+
+        if (elink->GetChannelInfo(chanid, srcid, callsign, channum, channame, xmltv))
+        {
+            //check if source matches
+            VERBOSE(VB_UPNP, QString("Channum = %1, expected source = %2 encoder source = %3 (lastcard=%4).")
+                                .arg( channum )
+                                .arg( nSourceId )
+                                .arg( srcid )
+                                .arg( lastcard ));
+            if (srcid != nSourceId)
+                continue;
+
+            sChanNum = "";
+            sChanNum = channum;
+        }
+
+
+        if (!lastcard)
+        {
+            if (elink->IsLocal())
+                enchost = gContext->GetHostName();
+            else
+                enchost = elink->GetHostName();
+
+            if (enchost == pbshost && elink->IsConnected() &&
+                !elink->IsBusy() && !elink->IsTunerLocked())
+            {
+                encoder = elink;
+                retval = iter.key();
+                VERBOSE(VB_UPNP, QString("Card %1 is local.")
+                        .arg(iter.key()));
+                break;
+            }
+        }
+
+        if ((retval == -1 || lastcard) && elink->IsConnected() &&
+            !elink->IsBusy() && !elink->IsTunerLocked())
+        {
+            encoder = elink;
+            retval = iter.key();
+        }
+        VERBOSE(VB_UPNP, QString("Checking card %1. Best card so far %2")
+                            .arg(iter.key()).arg(retval));
+    }
+
+    return encoder;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::StopLiveTV( UPnpAVTState *state )
+{
+    if (state->encoder)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::StopLiveTV : Stopping rec=%1 for chainid=%2")
+                            .arg(state->encoder->GetCardID()).arg(state->chain->GetID()));
+        state->encoder->StopLiveTV();
+        //wait until it stops?
+        int nRetries = 5;
+        while (state->encoder->GetState() != kState_None)
+        {
+            VERBOSE(VB_UPNP, QString("UPnpAVT::StopLiveTV : State != None, retrying shortly %1").arg(nRetries));
+            sleep(1);
+            if( --nRetries <= 0)
+                break;
+            VERBOSE(VB_UPNP, QString("UPnpAVT::StopLiveTV : Could not reach None state!"));
+            //something's wrong, cancel live TV we just spawned!
+        }
+        state->encoder = NULL;
+        //DispatchBackendMessages(state->chainid);
+        if (state->chain)
+        {
+            state->chain->DestroyChain();
+            delete state->chain;
+            state->chain   = NULL;
+        }
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+EncoderLink *UPnpAVT::GetRecorderForChain( QString &sChainId )
+{
+    EncoderLink *enc = NULL;
+    QMap<int, EncoderLink *> *encoderList = MainServer::GetInstance()->encoderList;
+    QMap<int, EncoderLink *>::Iterator iter = encoderList->begin();
+    for (; iter != encoderList->end(); ++iter)
+    {
+        EncoderLink *elink = *iter;
+        if (elink->GetChainID() == sChainId)
+        {
+            enc = elink;
+            break;
+        }
+    }
+    return enc;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::DispatchBackendMessages( QString &sChainId )
+{
+    QString message = QString("RECORDING_LIST_CHANGE");
+    VERBOSE(VB_UPNP, QString("UPnpAVT::DispatchBackendMessages : "
+                        "Dispatching backend message '%1'...").arg( message ));
+    MythEvent me1(message);
+    gContext->dispatch(me1);
+
+    if (!sChainId.isEmpty())
+    {
+        message = QString("LIVETV_CHAIN  UPDATE %1" ).arg( sChainId );
+        VERBOSE(VB_UPNP, QString("UPnpAVT::DispatchBackendMessages : "
+                            "Dispatching backend message '%1'...").arg( message ));
+        MythEvent me2(message);
+        gContext->dispatch(me2);
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+int UPnpAVT::ProcessLiveTVRequest( const QString &sChanId, unsigned int nSourceId,
+        UPnpAVTState *state)
+{
+    //A channid = -1 or NONE  means stop live tv
+    if ((sChanId == "-1") || (sChanId == "NONE"))
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Stopping live TV."));
+        if (state->encoder)
+        {
+            if (state->encoder->IsReallyRecording() && state->encoder->GetRecording())
+            {
+                QString channum = QString::null;
+                QString input = QString::null;
+                state->encoder->GetRecording()->GetChannel(channum, input);
+                VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                    "Stopping live TV for channel %1 on recorder %2.")
+                                    .arg(channum)
+                                    .arg(state->encoder->GetCardID()));
+            }
+            else
+            {
+                VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                    "Stopping live TV on recorder %1.")
+                                    .arg(state->encoder->GetCardID()));
+            }
+            StopLiveTV(state);
+        }
+        else
+        {
+            VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                "No encoder for InstanceID='%1'")
+                                .arg(state->InstanceID));
+        }
+        return 0;
+    }
+
+    //stop the recorder we have, unless it's recording exactly what we want
+    if (state->encoder)
+    {
+        //check if this encoder has the source we want
+        uint chanid, srcid = 0;
+        QString callsign, channame, channum, xmltv;
+        chanid = sChanId.toUInt();
+        if (state->encoder->GetChannelInfo(chanid, srcid, callsign, channum, channame, xmltv))
+        {
+            if (srcid != nSourceId)
+            {
+                //this encoder does not have the source we want. stop it and go on.
+                VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                    "Encoder for chainid='%1' does not have source=%2, "
+                                    "we wanted=%3. Stopping Live TV.")
+                                    .arg(state->chain->GetID()).arg(srcid)
+                                    .arg(nSourceId));
+            }
+            else
+            {
+                //this one has the right source, check if it also has the channel we want
+                ProgramInfo *pginfo = state->encoder->GetRecording();
+                if (pginfo)
+                {
+                    QString chanid  = pginfo->chanid;
+                    delete pginfo;
+
+                    if (chanid == sChanId)
+                    {
+                        //already recording the channel we want
+                        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                            "Already recording channid = %1 "
+                                            "(= %2) on recorder = %3")
+                                            .arg( sChanId ).arg( chanid )
+                                            .arg( state->encoder->GetCardID() ));
+                        return 0;
+                    }
+                    else
+                    {
+                        //not recording the channel we want, but we own the right encoder, so stop it for now
+                        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                            "Changing to channid = %1 on recorder = %2")
+                                            .arg( sChanId )
+                                            .arg( state->encoder->GetCardID() ));
+                    }
+                }
+                else
+                {
+                    //can't say what we are recording, so stop it just be sure
+                    VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                    "Could not get ProgramInfo for channid=%1 "
+                                    "on encoder=%2, stopping it to be sure.")
+                                    .arg(chanid).arg(state->encoder->GetCardID()));
+                }
+            }
+        }
+        else
+        {
+            //can't say what we are recording, so stop it just be sure
+            VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                                "Could not get ChannelInfo for channid=%1 "
+                                "on encoder=%2, stopping it to be sure.")
+                                .arg(chanid).arg(state->encoder->GetCardID()));
+        }
+        StopLiveTV(state);
+    }
+
+    QString sChanNum = "";
+    state->encoder = GetFreeRecorder(state->hostname, sChanId, nSourceId, sChanNum);
+
+    VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                        "For channum='%1' free rec = %2").arg( sChanNum )
+                        .arg( ( state->encoder ? state->encoder->GetCardID() : -1 ) ));
+
+    if (!state->encoder)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                            "Could not get free rec for channum='%1' source = %2")
+                            .arg( sChanNum ).arg( nSourceId ));
+        return -1;
+    }
+    QString sRecordingFilename;
+
+    state->chain = new LiveTVChain();//MainServer::GetInstance()->GetExistingChain(chainid);
+
+    QString sChainID = state->chain->InitializeNewChain(state->chainseed);
+    state->chain->LoadFromExistingChain(sChainID);
+
+    //chain->SetHostSocket(pbssock);
+    state->encoder->SpawnLiveTV(state->chain, false, sChanNum);
+
+    int nRetries = 3;
+
+    //backend messages
+    //DispatchBackendMessages(state->chain->GetID());
+
+    //check in a loop
+    while (!state->encoder->IsReallyRecording())
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Not recording yet... retrying shortly %1").arg(nRetries));
+        sleep(1);
+        if( --nRetries >= 0)
+            continue;
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Not recording yet!!!"));
+        //something's wrong, cancel live TV we just spawned!
+        StopLiveTV(state);
+        return -1;
+    }
+
+    nRetries = 3;
+    while (state->encoder->GetState() != kState_WatchingLiveTV)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : State != LiveTV, retrying shortly %1").arg(nRetries));
+        sleep(1);
+        if( --nRetries >= 0)
+            continue;
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Could not reach LiveTV state!"));
+        //something's wrong, cancel live TV we just spawned!
+        StopLiveTV(state);
+        return -1;
+    }
+
+    //all these calls are to simulate what MythFrontend does, don't know why it does this
+    state->framerate = state->encoder->GetFramerate();
+    state->encoder->FrontendReady();
+
+    if (MainServer::GetScheduler())
+    {
+        QStringList strList;
+        MainServer::GetScheduler()->getAllPending(strList);
+        //VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Got pending='%1'!").arg( strList.join(",") ));
+    }
+
+    //wait until frames are written, or until 3 seconds pass
+    nRetries = 10;
+    long long timeoutusec = (long long)(10*1000*1000)/nRetries;
+    long long nFrames = state->encoder->GetFramesWritten();
+    while (nFrames <= 0)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                            "Frames written=%1, retrying shortly %2")
+                            .arg(nFrames).arg(nRetries));
+        usleep(timeoutusec);
+        nFrames = state->encoder->GetFramesWritten();
+        if( --nRetries >= 0)
+            continue;
+
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Could not get any frames written!"));
+        //something's wrong, cancel live TV we just spawned
+        StopLiveTV(state);
+        return -1;
+    }
+    VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Frames written=%1")
+                        .arg(nFrames));
+
+    ProgramInfo *pginfo = state->encoder->GetRecording();
+    nRetries = 6;
+    while (pginfo == NULL)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                "ProgramInfo NULL, retrying shortly %1").arg(nRetries));
+        sleep(1);
+        pginfo = state->encoder->GetRecording();
+        if( --nRetries <= 0)
+            break;
+    }
+
+    if (pginfo)
+    {
+        sRecordingFilename = pginfo->GetFileName();
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : "
+                            "Encoder now recording [%1] to file='%2'/url='%3'")
+                            .arg(pginfo->toString()).arg(sRecordingFilename)
+                            .arg(pginfo->GetPlaybackURL(false, true)));
+        delete pginfo;
+    }
+    else
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : ProgramInfo not found!"));
+        //something's wrong, cancel live TV we just spawned!
+        StopLiveTV(state);
+        state->encoder = NULL;
+        return -1;
+    }
+
+    VERBOSE(VB_UPNP, QString("UPnpAVT::ProcessLiveTVRequest : Encoder now recording at file '%1'")
+                        .arg(sRecordingFilename));
+    return 1;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+QString UPnpAVT::GetChainSeedForClient( HTTPRequest *pRequest, QString &sInstanceID, QString &sHostname )
+{
+    int socket = pRequest->getSocketHandle();
+    MythSocket *msock = new MythSocket(socket);
+    QString sAddress  = msock->peerAddress().toString();
+    QHostInfo info    = QHostInfo::fromName(sAddress);
+    sHostname = info.hostName();
+    msock->DownRef();
+
+    VERBOSE(VB_UPNP, QString("UPnpAVT::GetChainSeedForClient : "
+                        "Client hostname=%1 and address=%2  on socket=%4")
+                        .arg(sHostname).arg(sAddress).arg(socket));
+    //.arg(QDateTime::currentDateTime().toString("yyyy-MM-ddThh:mm:ss"))
+    QString chainid = QString("%1/%2-UPnP:%3").arg( sHostname )
+                         .arg( sAddress ).arg( sInstanceID );
+    return chainid;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSetAVTransportURI( HTTPRequest *pRequest )
+{
+    QString sInstanceID         = pRequest->m_mapParams[ "InstanceID" ];
+    QString sCurrentURI         = pRequest->m_mapParams[ "CurrentURI" ];
+    QString sCurrentURIMetaData = pRequest->m_mapParams[ "CurrentURIMetaData" ];
+
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : %1 '%2' '%3'")
+                        .arg(sInstanceID).arg(sCurrentURI).arg(sCurrentURIMetaData));
+
+    //XML un-escape the URI
+    if (sCurrentURI.contains("&amp;") || sCurrentURI.contains("&gt;") || sCurrentURI.contains("&lt;"))
+    {
+        sCurrentURI.replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">")
+                   .replace("&quot;","\"").replace("&apos;","'");
+        VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : escaped='%1'").arg(sCurrentURI));
+    }
+
+    QUrl    url(sCurrentURI);
+    QString sChanId   = url.queryItemValue("ChanId");
+    unsigned int nSourceId = 0;
+
+    bool ok = true;
+    unsigned int nChanId = sChanId.toUInt(&ok);
+    if (ok)
+        nSourceId = ChannelUtil::GetSourceIDForChannel(nChanId);
+
+    QString sSourceId = url.queryItemValue("SourceId");
+    if (!sSourceId.isEmpty())
+    {
+        ok = true;
+        unsigned int nSourceIdFromURL = sSourceId.toUInt(&ok);
+        if (nSourceIdFromURL != nSourceId)
+        {
+            VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : Warning"
+                                " - channel util source='%1' does not match "
+                                "url source=%2").arg(nSourceId)
+                                .arg(nSourceIdFromURL));
+        }
+        nSourceId = nSourceIdFromURL;
+    }
+
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        state            = CreateAVTState(sInstanceID);
+        state->hostname  = "";
+        state->chainseed = GetChainSeedForClient(pRequest, sInstanceID, state->hostname);
+    }
+
+    if (state->GetValue<QString>("TransportState")
+            == UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT)
+    {
+        state->SetValue< QString >( "TransportState", UPnpAVTState::AVTState_TransportState_STOPPED );
+        SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+    }
+
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : ChanId='%1' SourceId='%2'")
+                        .arg(sChanId).arg(nSourceId));
+
+    state->SetValue< QString >( "TransportState", UPnpAVTState::AVTState_TransportState_TRANSITIONING );
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+
+    int result = ProcessLiveTVRequest(sChanId, nSourceId, state);
+    if ( result >= 1)
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : LiveTV start successful, setting state."));
+        //set appropriate state variables, except TransportState, which may need to be set in HandlePlay()
+        state->SetValue< QString >( "TransportState"              , UPnpAVTState::AVTState_TransportState_STOPPED );
+        state->SetValue< QString >( "TransportStatus"             , UPnpAVTState::AVTState_TransportStatus_OK );
+        state->SetValue< QString >( "CurrentTrackMetaData"        , sCurrentURIMetaData );
+        state->SetValue< QString >( "CurrentTrackURI"             , sCurrentURI  );
+        state->SetValue< QString >( "AVTransportURI"              , sCurrentURI );
+        state->SetValue< QString >( "AVTransportURIMetaData"      , sCurrentURIMetaData );
+        state->SetValue< QString >( "NumberOfTracks"              , QString::number(1) );
+        state->SetValue< QString >( "CurrentTrack"                , QString::number(1) );
+    }
+    else
+    {
+        VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetAVTransportURI : LiveTV start problem '%1'")
+                            .arg(result));
+        state->SetValue< QString >( "TransportState"              , UPnpAVTState::AVTState_TransportState_STOPPED );
+        state->SetValue< QString >( "CurrentTrackMetaData"        , "" );
+        state->SetValue< QString >( "CurrentTrackURI"             , ""  );
+        state->SetValue< QString >( "AVTransportURI"              , "" );
+        state->SetValue< QString >( "AVTransportURIMetaData"      , "" );
+        state->SetValue< QString >( "NumberOfTracks"              , QString::number(0) );
+        state->SetValue< QString >( "CurrentTrack"                , QString::number(0) );
+    }
+
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+
+    if (result < 0)   //we stopped, but not because we wanted to
+    {
+        //delete state
+        DeleteAVTState(sInstanceID);
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_ResourceNotFound, QString("Resource not found.") );
+        return;
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSetNextAVTransportURI( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetNextAVTransportURI : Not implemented"));
+    UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+            QString("Transition not available.") );
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::PopulateMediaInfoList( NameValues &list, UPnpAVTState *state )
+{
+    list.push_back( NameValue("NrTracks"          , state->GetValue<QString>("NumberOfTracks"))             );
+    list.push_back( NameValue("MediaDuration"     , state->GetValue<QString>("CurrentMediaDuration"))       );
+    list.push_back( NameValue("CurrentURI"        , state->GetValue<QString>("AVTransportURI"))             );
+    list.push_back( NameValue("CurrentURIMetaData", state->GetValue<QString>("AVTransportURIMetaData"))     );
+    list.push_back( NameValue("NextURI"           , state->GetValue<QString>("NextAVTransportURI"))         );
+    list.push_back( NameValue("NextURIMetaData"   , state->GetValue<QString>("NextAVTransportURIMetaData")) );
+    list.push_back( NameValue("PlayMedium"        , state->GetValue<QString>("PlaybackStorageMedium"))      );
+    list.push_back( NameValue("RecordMedium"      , state->GetValue<QString>("RecordStorageMedium"))        );
+    list.push_back( NameValue("WriteStatus"       , state->GetValue<QString>("RecordMediumWriteStatus"))    );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetMediaInfo( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetMediaInfo : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    PopulateMediaInfoList(list, state);
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetMediaInfo_Ext( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetMediaInfoExt : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("CurrentType", state->GetValue<QString>("CurrentMediaCategory"))    );
+    PopulateMediaInfoList(list, state);
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetTransportInfo( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetTransportInfo : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("CurrentTransportState" , state->GetValue<QString>("TransportState"))     );
+    list.push_back( NameValue("CurrentTransportStatus", state->GetValue<QString>("TransportStatus"))    );
+    list.push_back( NameValue("CurrentSpeed"          , state->GetValue<QString>("TransportPlaySpeed")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetPositionInfo( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetPositionInfo : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("Track"         , state->GetValue<QString>("CurrentTrack"))            );
+    list.push_back( NameValue("TrackDuration" , state->GetValue<QString>("CurrentTrackDuration"))    );
+    list.push_back( NameValue("TrackMetaData" , state->GetValue<QString>("CurrentTrackMetaData"))    );
+    list.push_back( NameValue("TrackURI"      , state->GetValue<QString>("CurrentTrackURI"))         );
+    list.push_back( NameValue("RelTime"       , state->GetValue<QString>("RelativeTimePosition"))    );
+    list.push_back( NameValue("AbsTime"       , state->GetValue<QString>("AbsoluteTimePosition"))    );
+    list.push_back( NameValue("RelCount"      , state->GetValue<QString>("RelativeCounterPosition")) );
+    list.push_back( NameValue("AbsCount"      , state->GetValue<QString>("AbsoluteCounterPosition")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetDeviceCapabilities( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetDeviceCapabilities : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("PlayMedia"      , state->GetValue<QString>("PossiblePlaybackStorageMedia"))    );
+    list.push_back( NameValue("RecMedia"       , state->GetValue<QString>("PossibleRecordStorageMedia"))    );
+    list.push_back( NameValue("RecQualityModes", state->GetValue<QString>("PossibleRecordQualityModes"))    );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetTransportSettings( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetTransportSettings : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("PlayMode"      , state->GetValue<QString>("CurrentPlayMode"))    );
+    list.push_back( NameValue("RecQualityMode", state->GetValue<QString>("CurrentRecordQualityMode"))    );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleStop( HTTPRequest *pRequest )
+{
+    QString sInstanceID = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleStop : InstanceId='%1'").arg(sInstanceID));
+
+    UPnpAVTState *state = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+
+    if (state->GetValue<QString>( "TransportState" )
+            == UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT )
+    {
+        //not allowed
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+                QString("Transition not available.") );
+        return;
+    }
+
+    if (ProcessLiveTVRequest("-1", -1, state) < 0)
+    {
+         VERBOSE(VB_UPNP, QString("UPnpAVT::HandleStop : Could not stop cleanly."));
+    }
+
+    if (state->GetValue< QString >("TransportState") == UPnpAVTState::AVTState_TransportState_RECORDING )
+    {
+        //TODO - do something differently if state is recording?
+    }
+
+    state->SetValue< QString >( "TransportState"              , UPnpAVTState::AVTState_TransportState_STOPPED );
+    state->SetValue< QString >( "CurrentTrackMetaData"        , "" );
+    state->SetValue< QString >( "CurrentTrackURI"             , "" );
+    state->SetValue< QString >( "AVTransportURI"              , "" );
+    state->SetValue< QString >( "AVTransportURIMetaData"      , "" );
+    state->SetValue< QString >( "NumberOfTracks"              , QString::number(0) );
+    state->SetValue< QString >( "CurrentTrack"                , QString::number(0) );
+
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+
+    //delete state
+    DeleteAVTState(sInstanceID);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandlePlay( HTTPRequest *pRequest )
+{
+    QString sInstanceID = pRequest->m_mapParams[ "InstanceID" ];
+    QString sSpeed      = pRequest->m_mapParams[ "Speed" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandlePlay : InstanceId='%1' speed='%2'")
+                        .arg(sInstanceID).arg(sSpeed));
+    UPnpAVTState *state = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    QString sCurrentState = state->GetValue<QString>( "TransportState" );
+
+    if (sCurrentState == UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT)
+    {
+        //need to call SetAVTransportURI first
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_NoContents,
+                QString("No contents.") );
+        return;
+    }
+
+    if ((sCurrentState != UPnpAVTState::AVTState_TransportState_STOPPED)
+        && (sCurrentState != UPnpAVTState::AVTState_TransportState_PLAYING)
+        && (sCurrentState != UPnpAVTState::AVTState_TransportState_PAUSED_PLAYBACK))
+    {
+        //only above states allowed
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+                QString("Transition not available.") );
+        return;
+    }
+    state->SetValue< QString >( "TransportState"    , UPnpAVTState::AVTState_TransportState_PLAYING );
+    state->SetValue< QString >( "TransportPlaySpeed", sSpeed );
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandlePause( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandlePause : Not implemented"));
+    UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+            QString("Transition not available.") );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleRecord( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleRecord : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+
+    //state machine
+    QString sCurrentState = state->GetValue<QString>( "TransportState" );
+    if (sCurrentState == UPnpAVTState::AVTState_TransportState_NO_MEDIA_PRESENT)
+    {
+        //need to call SetAVTransportURI first
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_NoContents,
+                QString("No contents.") );
+        return;
+    }
+
+    //spec recommends only allowing transition from STOPPED and PAUSED_RECORDING states, but we allow more
+    if ((sCurrentState != UPnpAVTState::AVTState_TransportState_STOPPED)
+        && (sCurrentState != UPnpAVTState::AVTState_TransportState_PAUSED_RECORDING)
+        && (sCurrentState != UPnpAVTState::AVTState_TransportState_PLAYING)
+        && (sCurrentState != UPnpAVTState::AVTState_TransportState_PAUSED_PLAYBACK))
+    {
+        //only above states allowed
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+                QString("Transition not available.") );
+        return;
+    }
+
+    QString sAVTransportURI = state->GetValue<QString>( "AVTransportURI" );
+    if (sAVTransportURI.isEmpty())
+    {
+        //don't know what to record, assume bad instance ID
+        VERBOSE(VB_UPNP, "UPnpAVT::HandleRecord : AVTransportURI not set");
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+
+    EncoderLink *enc           = state->encoder;    //GetRecorderForChain(state->chainid);
+    ProgramInfo *progInfo      = NULL;
+    if (enc)
+    {
+        //we are already recording it, just persist the recording
+        progInfo = enc->GetRecording();
+        if (!progInfo)
+        {
+            VERBOSE(VB_UPNP, "UPnpAVT::HandleRecord : ProgInfo not available!");
+            UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                    QString("Invalid InstanceID.") );
+            return;
+        }
+        //RecStatusType result = enc->StartRecording(progInfo);
+        //VERBOSE(VB_UPNP, QString("UPnpAVT::HandleRecord : StartRecording [%1] result = %2!").arg(progInfo->toString()).arg(result));
+
+        if (progInfo->title == gContext->GetSetting("UnknownTitle"))
+        {
+            progInfo->title = "LiveTV "
+                                +(progInfo->chanstr.isEmpty() ?
+                                        "" : progInfo->chanstr+" ")
+                                + "["+progInfo->chanid+"]"
+                                + (progInfo->channame.isEmpty() ?
+                                        "" : (" "+progInfo->channame))
+                                + " "
+                                + (progInfo->startts
+                                        .toString("yyyy-MMM-dd ddd hh:mm:ss"));
+        }
+        VERBOSE(VB_UPNP, QString("UPnpSRS::HandleRecord : "
+                            "Attempting to record proginfo title='%1' on "
+                            "chanid %2 from %3 to %4.")
+                            .arg(progInfo->title).arg(progInfo->chanid)
+                            .arg(progInfo->startts
+                                    .toString("yyyy-MMM-dd ddd hh:mm:ss"))
+                            .arg(progInfo->endts
+                                    .toString("yyyy-MMM-dd ddd hh:mm:ss")));
+
+        //enc->SetLiveRecording(1); //doesn't work
+        //DispatchBackendMessages(state->chain->GetID());
+
+        //from TVRec::NotifySchedulerOfRecording(RecordingInfo *rec)
+        if (MainServer::GetScheduler())
+        {
+            // Notify scheduler of the recording.
+            RecordingInfo *rec = new RecordingInfo(*progInfo);
+            // + set up recording so it can be resumed
+            rec->cardid    = enc->GetCardID();
+            rec->inputid   = CardUtil::GetInputID(rec->cardid, enc->GetInput());
+
+            rec->rectype = rec->GetRecordingRule()->m_type;
+
+            if (rec->rectype == kNotRecording)
+            {
+                rec->rectype = kSingleRecord;
+                rec->GetRecordingRule()->m_type = kSingleRecord;
+            }
+
+            // + remove DefaultEndOffset which would mismatch the live session
+            rec->GetRecordingRule()->m_endOffset = 0;
+
+            // + save rsInactive recstatus to so that a reschedule call
+            //   doesn't start recording this on another card before we
+            //   send the SCHEDULER_ADD_RECORDING message to the scheduler.
+            rec->recstatus = rsInactive;
+            rec->AddHistory(false);
+
+            // + save RecordingRule so that we get a recordid
+            //   (don't allow signalChange(), avoiding unneeded reschedule)
+            rec->GetRecordingRule()->Save(false);
+
+            // + save recordid to recorded entry
+            rec->ApplyRecordRecID();
+
+            // + set proper recstatus (saved later)
+            rec->recstatus = rsRecording;
+
+            MainServer::GetScheduler()->AddRecording(*rec);
+            delete rec;
+        }
+
+        delete progInfo;
+
+        state->SetValue< QString >( "TransportState"    , UPnpAVTState::AVTState_TransportState_RECORDING );
+        SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+    }
+    else
+    {
+       VERBOSE(VB_UPNP, "UPnpAVT::HandleRecord : Encoder not available!");
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSeek( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSeek : Not implemented"));
+    UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+            QString("Transition not available.") );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleNext( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleNext : Not implemented"));
+    UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+            QString("Transition not available.") );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandlePrevious( HTTPRequest *pRequest )
+{
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandlePrevious : Not implemented"));
+    UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_TransitionNotAvailable,
+            QString("Transition not available.") );
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSetPlayMode( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    QString sNewPlayMode = pRequest->m_mapParams[ "NewPlayMode" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetPlayMode : InstanceId='%1' NewPlayMode='%2'")
+                        .arg(sInstanceID).arg(sNewPlayMode));
+
+    state->SetValue< QString >( "CurrentPlayMode", sNewPlayMode );
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSetRecordQualityMode( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    QString sNewRecordQualityMode = pRequest->m_mapParams[ "NewRecordQualityMode" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetRecordQualityMode : InstanceId='%1' NewRecordQualityMode='%2'")
+                        .arg(sInstanceID).arg(sNewRecordQualityMode));
+
+    QString sPossibleRecordQualityModes = state->GetValue< QString >("PossibleRecordQualityModes");
+    if (!sPossibleRecordQualityModes.contains(sNewRecordQualityMode, Qt::CaseInsensitive))
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_RecordQualityNotSupported,
+                QString("Record Quality Not Supported.") );
+        return;
+    }
+    state->SetValue< QString >( "CurrentRecordQualityMode", sNewRecordQualityMode );
+    SetValue< QString >("LastChange", Qt::escape(state->GetLastChangeValues()));
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetCurrentTransportActions( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetCurrentTransportActions : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("Actions", state->GetValue<QString>("CurrentTransportActions")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetDRMState( HTTPRequest *pRequest )
+{
+    QString sInstanceID  = pRequest->m_mapParams[ "InstanceID" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetDRMState : InstanceId='%1'").arg(sInstanceID));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    NameValues list;
+    list.push_back( NameValue("CurrentDRMState", state->GetValue<QString>("DRMState")) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleGetStateVariables( HTTPRequest *pRequest )
+{
+    QString sInstanceID         = pRequest->m_mapParams[ "InstanceID" ];
+    QString sStateVariableList  = pRequest->m_mapParams[ "StateVariableList" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleGetStateVariables : InstanceId='%1' "
+                        "StateVariableList='%2'").arg(sInstanceID).arg(sStateVariableList));
+    UPnpAVTState *state  = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    if (sStateVariableList.isEmpty())
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidStateVariableList,
+                QString("Invalid State Variable List.") );
+        return;
+    }
+
+    //XML header from AVTransport:2 spec, very simple structure, so using string concat instead of QtXml.
+    QString sSVValuePairs = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+            "<stateVariableValuePairs \n"
+            " xmlns=\"urn:schemas-upnp-org:av:avs\"\n"
+            " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n"
+            " xsi:schemaLocation=\"urn:schemas-upnp-org:av:avs http://www.upnp.org/schemas/av/avs-v1-20060531.xsd\">\n";
+
+    SVMap &svmap = ((UPnpAVTState*)state)->GetSVMap();
+    if (sStateVariableList == "*") //get all state variables
+    {
+        for(SVMap::iterator itr = svmap.begin(); itr != svmap.end(); ++itr)
+        {
+            QString                sName = itr.key();
+            StateVariable<QString> *pSV  = dynamic_cast< StateVariable<QString> *>(itr.value());
+            if (!UPnpAVTState::IsEvented(sName))
+                continue;
+            //else add it to the list we want
+            sSVValuePairs.append( QString("\t<stateVariable variableName=\"%1\">\n\t\t%2\n\t</stateVariable>\n")
+                                    .arg(sName).arg( Qt::escape( pSV->GetValue() ) ));
+        }
+    }
+    else  //get individually
+    {
+        QStringList sStateVariables = sStateVariableList.split(',');
+        for(int i = 0; i < sStateVariables.size(); ++i)
+        {
+            QString sName = sStateVariables.at(i);
+            if (!UPnpAVTState::IsEvented(sName))
+                continue;
+            SVMap::iterator itr = svmap.find(sName);
+            if (itr == svmap.end())    //unknown state variable... return error
+            {
+                UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidStateVariableList,
+                        QString("Invalid State Variable List.") );
+                return;
+            }
+            StateVariable<QString> *pSV  = dynamic_cast< StateVariable<QString> *>(itr.value());
+            //else add it to the list
+            sSVValuePairs.append( QString("\t<stateVariable variableName=\"%1\">\n\t\t%2\n\t</stateVariable>\n")
+                                    .arg(sName).arg( pSV->GetValue() ));
+        }
+    }
+    sSVValuePairs.append("</stateVariableValuePairs>");
+    sSVValuePairs = Qt::escape(sSVValuePairs);
+    VERBOSE(VB_UPNP, QString("result = '%1'").arg(sSVValuePairs));
+    NameValues list;
+    list.push_back( NameValue("StateVariableList", sSVValuePairs) );
+    pRequest->FormatActionResponse(list);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
+void UPnpAVT::HandleSetStateVariables( HTTPRequest *pRequest )
+{
+    QString sInstanceID     = pRequest->m_mapParams[ "InstanceID" ];
+    QString sAVTransportUDN = pRequest->m_mapParams[ "AVTransportUDN" ];
+    QString sServiceType    = pRequest->m_mapParams[ "ServiceType" ];
+    QString sServiceId      = pRequest->m_mapParams[ "ServiceId" ];
+    QString sValuePairs     = pRequest->m_mapParams[ "StateVariableValuePairs" ];
+    VERBOSE(VB_UPNP, QString("UPnpAVT::HandleSetStateVariables : InstanceId='%1' "
+            "AVTransportUDN='%2' ServiceType='%3' ServiceId='%4' "
+            "StateVariableValuePairs='%5'")
+            .arg(sInstanceID).arg(sAVTransportUDN).arg(sServiceType)
+            .arg(sServiceId).arg(sValuePairs));
+    UPnpAVTState *state     = GetAVTState(sInstanceID);
+    if (!state)
+    {
+        UPnp::FormatErrorResponse(pRequest, UPnPResult_AVT_InvalidInstanceID,
+                QString("Invalid InstanceID.") );
+        return;
+    }
+    //not implemented
+    NameValues list;
+    pRequest->FormatActionResponse(list);
+}
+
+/* vim: set expandtab tabstop=4 shiftwidth=4: */
